// Copyright (C) 2023 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

module;

#include <stormkit/core/as_casts_macro.hpp>
#include <stormkit/core/flags_macro.hpp>
#include <stormkit/core/hash_macro.hpp>
#include <stormkit/core/platform_macro.hpp>

export module stormkit.Gpu:Core.Types;

import std;

import stormkit.core;
import stormkit.Gpu.Vulkan;

export {
    namespace stormkit::gpu {
        inline constexpr auto QUEUE_FAMILY_IGNORED = UInt32 { vk::QueueFamilyIgnored };

        enum class PhysicalDeviceType : UInt8 {
            Discrete_GPU   = as<UInt8>(vk::PhysicalDeviceType::eDiscreteGpu),
            Virtual_GPU    = as<UInt8>(vk::PhysicalDeviceType::eVirtualGpu),
            Integrated_GPU = as<UInt8>(vk::PhysicalDeviceType::eIntegratedGpu),
            CPU            = as<UInt8>(vk::PhysicalDeviceType::eCpu),
            Other          = as<UInt8>(vk::PhysicalDeviceType::eOther),
        };

        enum class QueueFlag : UInt8 {
            NONE           = 0,
            Graphics       = as<UInt8>(vk::QueueFlagBits::eGraphics),
            Compute        = as<UInt8>(vk::QueueFlagBits::eCompute),
            Transfer       = as<UInt8>(vk::QueueFlagBits::eTransfer),
            Sparse_Binding = as<UInt8>(vk::QueueFlagBits::eSparseBinding),
        };

        enum class ShaderStageFlag : UInt8 {
            NONE     = 0,
            Vertex   = as<UInt8>(vk::ShaderStageFlagBits::eVertex),
            Fragment = as<UInt8>(vk::ShaderStageFlagBits::eFragment),
            Geometry = as<UInt8>(vk::ShaderStageFlagBits::eGeometry),
            Compute  = as<UInt8>(vk::ShaderStageFlagBits::eCompute),
        };

        enum class PrimitiveTopology : UInt8 {
            Point_List     = as<UInt8>(vk::PrimitiveTopology::ePointList),
            Line_List      = as<UInt8>(vk::PrimitiveTopology::eLineList),
            Line_Strip     = as<UInt8>(vk::PrimitiveTopology::eLineStrip),
            Triangle_List  = as<UInt8>(vk::PrimitiveTopology::eTriangleList),
            Triangle_Strip = as<UInt8>(vk::PrimitiveTopology::eTriangleStrip),
            Triangle_Fan   = as<UInt8>(vk::PrimitiveTopology::eTriangleFan),
        };

        enum class PolygonMode : UInt8 {
            Fill  = as<UInt8>(vk::PolygonMode::eFill),
            Line  = as<UInt8>(vk::PolygonMode::eLine),
            Point = as<UInt8>(vk::PolygonMode::ePoint),
        };

        enum class CullModeFlag : UInt8 {
            NONE       = as<UInt8>(vk::CullModeFlagBits::eNONE),
            Front      = as<UInt8>(vk::CullModeFlagBits::eFront),
            Back       = as<UInt8>(vk::CullModeFlagBits::eBack),
            Front_Back = Front | Back,
        };

        enum class FrontFace : UInt8 {
            Clockwise         = as<UInt8>(vk::FrontFace::eClockwise),
            Counter_Clockwise = as<UInt8>(vk::FrontFace::eCounterClockwise),
        };

        enum class SampleCountFlag : UInt8 {
            NONE = 0,
            C1   = as<UInt8>(vk::SampleCountFlagBits::e1),
            C2   = as<UInt8>(vk::SampleCountFlagBits::e2),
            C4   = as<UInt8>(vk::SampleCountFlagBits::e4),
            C8   = as<UInt8>(vk::SampleCountFlagBits::e8),
            C16  = as<UInt8>(vk::SampleCountFlagBits::e16),
            C32  = as<UInt8>(vk::SampleCountFlagBits::e32),
            C64  = as<UInt8>(vk::SampleCountFlagBits::e64),
        };

        enum class ColorComponentFlag : UInt8 {
            NONE = 0,
            R    = as<UInt8>(vk::ColorComponentFlagBits::eR),
            G    = as<UInt8>(vk::ColorComponentFlagBits::eG),
            B    = as<UInt8>(vk::ColorComponentFlagBits::eB),
            A    = as<UInt8>(vk::ColorComponentFlagBits::eA),
            RG   = R | G,
            RGB  = RG | B,
            RGBA = RGB | A,
        };

        enum class BlendFactor : UInt8 {
            One                      = as<UInt8>(vk::BlendFactor::eOne),
            Zero                     = as<UInt8>(vk::BlendFactor::eZero),
            Src_Color                = as<UInt8>(vk::BlendFactor::eSrcColor),
            One_Minus_Src_Color      = as<UInt8>(vk::BlendFactor::eOneMinusSrcColor),
            Dst_Color                = as<UInt8>(vk::BlendFactor::eDstColor),
            One_Minus_Dst_Color      = as<UInt8>(vk::BlendFactor::eOneMinusDstColor),
            Src_Alpha                = as<UInt8>(vk::BlendFactor::eSrcAlpha),
            One_Minus_Src_Alpha      = as<UInt8>(vk::BlendFactor::eOneMinusSrcAlpha),
            Dst_Alpha                = as<UInt8>(vk::BlendFactor::eDstAlpha),
            One_Minus_Dst_Alpha      = as<UInt8>(vk::BlendFactor::eOneMinusDstAlpha),
            Constant_Color           = as<UInt8>(vk::BlendFactor::eConstantColor),
            One_Minus_Constant_Color = as<UInt8>(vk::BlendFactor::eOneMinusConstantColor),
            Constant_Alpha           = as<UInt8>(vk::BlendFactor::eConstantAlpha),
            One_Minus_Constant_Alpha = as<UInt8>(vk::BlendFactor::eOneMinusConstantAlpha),
            Src_Alpha_Saturate       = as<UInt8>(vk::BlendFactor::eSrcAlphaSaturate),
            Src1_Color               = as<UInt8>(vk::BlendFactor::eSrc1Color),
            One_Minus_Src1_Color     = as<UInt8>(vk::BlendFactor::eOneMinusSrc1Color),
            Src1_Alpha               = as<UInt8>(vk::BlendFactor::eSrc1Alpha),
            One_Minus_Src1_Alpha     = as<UInt8>(vk::BlendFactor::eOneMinusSrc1Alpha),
        };

        enum class BlendOperation : UInt8 {
            Add               = as<UInt8>(vk::BlendOp::eAdd),
            Substract         = as<UInt8>(vk::BlendOp::eSubtract),
            Reverse_Substract = as<UInt8>(vk::BlendOp::eReverseSubtract),
            Min               = as<UInt8>(vk::BlendOp::eMin),
            Max               = as<UInt8>(vk::BlendOp::eMax),
        };

        enum class LogicOperation : UInt8 {
            Clear         = as<UInt8>(vk::LogicOp::eClear),
            And           = as<UInt8>(vk::LogicOp::eAnd),
            And_Reverse   = as<UInt8>(vk::LogicOp::eAndReverse),
            Copy          = as<UInt8>(vk::LogicOp::eCopy),
            And_Inverted  = as<UInt8>(vk::LogicOp::eAndInverted),
            No_Operation  = as<UInt8>(vk::LogicOp::eNoOp),
            Xor           = as<UInt8>(vk::LogicOp::eXor),
            Or            = as<UInt8>(vk::LogicOp::eOr),
            Nor           = as<UInt8>(vk::LogicOp::eNor),
            Equivalent    = as<UInt8>(vk::LogicOp::eEquivalent),
            Invert        = as<UInt8>(vk::LogicOp::eInvert),
            Or_Reverse    = as<UInt8>(vk::LogicOp::eOrReverse),
            Copy_Inverted = as<UInt8>(vk::LogicOp::eCopyInverted),
            Or_Inverted   = as<UInt8>(vk::LogicOp::eOrInverted),
            Nand          = as<UInt8>(vk::LogicOp::eNand),
            Set           = as<UInt8>(vk::LogicOp::eSet),
        };

        enum class PixelFormat : UInt8 {
            R8_SNORM    = as<UInt8>(vk::format::eR8Snorm),
            RG8_SNORM   = as<UInt8>(vk::format::eR8G8Snorm),
            RGB8_SNORM  = as<UInt8>(vk::format::eR8G8B8Snorm),
            RGBA8_SNORM = as<UInt8>(vk::format::eR8G8B8A8Snorm),

            R8_UNORM    = as<UInt8>(vk::format::eR8Unorm),
            RG8_UNORM   = as<UInt8>(vk::format::eR8G8Unorm),
            RGB8_UNORM  = as<UInt8>(vk::format::eR8G8B8Unorm),
            RGBA8_UNORM = as<UInt8>(vk::format::eR8G8B8A8Unorm),

            R16_SNORM    = as<UInt8>(vk::format::eR16Snorm),
            RG16_SNORM   = as<UInt8>(vk::format::eR16G16Snorm),
            RGB16_SNORM  = as<UInt8>(vk::format::eR16G16B16Snorm),
            RGBA16_SNORM = as<UInt8>(vk::format::eR16G16B16A16Snorm),

            R16_UNORM    = as<UInt8>(vk::format::eR16Unorm),
            RG16_UNORM   = as<UInt8>(vk::format::eR16G16Unorm),
            RGB16_UNORM  = as<UInt8>(vk::format::eR16G16B16Unorm),
            RGBA16_UNORM = as<UInt8>(vk::format::eR16G16B16A16Unorm),

            A2_RGB10_UNorm = as<UInt8>(vk::format::eA2R10G10B10UnormPack32),

            RGBA4_UNORM_Pack16 = as<UInt8>(vk::format::eR4G4B4A4UnormPack16),

            A1_RGB5_UNorm_Pack16 = as<UInt8>(vk::format::eA1R5G5B5UnormPack16),

            R5_G6_B5_UNorm_Pack16 = as<UInt8>(vk::format::eR5G6B5UnormPack16),

            BGR8_UNORM  = as<UInt8>(vk::format::eB8G8R8Unorm),
            BGRA8_UNORM = as<UInt8>(vk::format::eB8G8R8A8Unorm),

            R8I    = as<UInt8>(vk::format::eR8Sint),
            RG8I   = as<UInt8>(vk::format::eR8G8Sint),
            RGB8I  = as<UInt8>(vk::format::eR8G8B8Sint),
            RGBA8I = as<UInt8>(vk::format::eR8G8B8A8Sint),

            R8U    = as<UInt8>(vk::format::eR8Uint),
            RG8U   = as<UInt8>(vk::format::eR8G8Uint),
            RGB8U  = as<UInt8>(vk::format::eR8G8B8Uint),
            RGBA8U = as<UInt8>(vk::format::eR8G8B8A8Uint),

            R16I    = as<UInt8>(vk::format::eR16Sint),
            RG16I   = as<UInt8>(vk::format::eR16G16Sint),
            RGB16I  = as<UInt8>(vk::format::eR16G16B16Sint),
            RGBA16I = as<UInt8>(vk::format::eR16G16B16A16Sint),

            R16U    = as<UInt8>(vk::format::eR16Uint),
            RG16U   = as<UInt8>(vk::format::eR16G16Uint),
            RGB16U  = as<UInt8>(vk::format::eR16G16B16Uint),
            RGBA16U = as<UInt8>(vk::format::eR16G16B16A16Uint),

            R32I    = as<UInt8>(vk::format::eR32Sint),
            RG32I   = as<UInt8>(vk::format::eR32G32Sint),
            RGB32I  = as<UInt8>(vk::format::eR32G32B32Sint),
            RGBA32I = as<UInt8>(vk::format::eR32G32B32A32Sint),

            R32U    = as<UInt8>(vk::format::eR32Uint),
            RG32U   = as<UInt8>(vk::format::eR32G32Uint),
            RGB32U  = as<UInt8>(vk::format::eR32G32B32Uint),
            RGBA32U = as<UInt8>(vk::format::eR32G32B32A32Uint),

            A2_RGB10U_Pack32 = as<UInt8>(vk::format::eA2R10G10B10UintPack32),

            R16F    = as<UInt8>(vk::format::eR16Sfloat),
            RG16F   = as<UInt8>(vk::format::eR16G16Sfloat),
            RGB16F  = as<UInt8>(vk::format::eR16G16B16Sfloat),
            RGBA16F = as<UInt8>(vk::format::eR16G16B16A16Sfloat),

            R32F    = as<UInt8>(vk::format::eR32Sfloat),
            RG32F   = as<UInt8>(vk::format::eR32G32Sfloat),
            RGB32F  = as<UInt8>(vk::format::eR32G32B32Sfloat),
            RGBA32F = as<UInt8>(vk::format::eR32G32B32A32Sfloat),

            BG11_R10F_Pack32 = as<UInt8>(vk::format::eB10G11R11UfloatPack32),

            SRGB8  = as<UInt8>(vk::format::eR8G8B8Srgb),
            SRGBA8 = as<UInt8>(vk::format::eR8G8B8A8Srgb),
            SBGR8  = as<UInt8>(vk::format::eB8G8R8Srgb),
            SBGRA8 = as<UInt8>(vk::format::eB8G8R8A8Srgb),

            Depth16  = as<UInt8>(vk::format::eD16Unorm),
            Depth24  = as<UInt8>(vk::format::eX8D24UnormPack32),
            Depth32F = as<UInt8>(vk::format::eD32Sfloat),

            Depth16_Stencil8  = as<UInt8>(vk::format::eD16UnormS8Uint),
            Depth24_Stencil8  = as<UInt8>(vk::format::eD24UnormS8Uint),
            Depth32F_Stencil8 = as<UInt8>(vk::format::eD32SfloatS8Uint),

            Undefined = as<UInt8>(vk::format::eUndefined),
        };

        enum class AttachmentLoadOperation : UInt8 {
            Clear     = as<UInt8>(vk::AttachmentLoadOp::eClear),
            Load      = as<UInt8>(vk::AttachmentLoadOp::eLoad),
            Dont_Care = as<UInt8>(vk::AttachmentLoadOp::eDontCare),
        };

        enum class AttachmentStoreOperation : UInt8 {
            Store     = as<UInt8>(vk::AttachmentStoreOp::eStore),
            Dont_Care = as<UInt8>(vk::AttachmentStoreOp::eDontCare),
        };

        enum class PipelineBindPoint : UInt8 {
            Graphics = as<UInt8>(vk::PipelineBindPoint::eGraphics),
            Compute  = as<UInt8>(vk::PipelineBindPoint::eCompute),
        };

        enum class ImageLayout : UInt32 {
            General                  = as<UInt32>(vk::ImageLayout::eGeneral),
            Color_Attachment_Optimal = as<UInt32>(vk::ImageLayout::eColorAttachmentOptimal),
            Depth_Stencil_Attachment_Optimal
                = as<UInt32>(vk::ImageLayout::eDepthStencilAttachmentOptimal),
            Depth_Stencil_Read_Only_Optimal
                = as<UInt32>(vk::ImageLayout::eDepthStencilReadOnlyOptimal),
            Shader_Read_Only_Optimal = as<UInt32>(vk::ImageLayout::eShaderReadOnlyOptimal),
            Transfer_Src_Optimal     = as<UInt32>(vk::ImageLayout::eTransferSrcOptimal),
            Transfer_Dst_Optimal     = as<UInt32>(vk::ImageLayout::eTransferDstOptimal),
            Preinitialized           = as<UInt32>(vk::ImageLayout::ePreinitialized),
            Depth_Read_Only_Stencil_Attachment_Optimal
                = as<UInt32>(vk::ImageLayout::eDepthReadOnlyStencilAttachmentOptimal),
            Depth_Attachment_Stencil_Read_Only_Optimal
                = as<UInt32>(vk::ImageLayout::eDepthAttachmentStencilReadOnlyOptimal),
            Present_Src    = as<UInt32>(vk::ImageLayout::ePresentSrcKHR),
            Shared_Present = as<UInt32>(vk::ImageLayout::eSharedPresentKHR),
            Undefined      = as<UInt32>(vk::ImageLayout::eUndefined),
        };

        enum class ImageAspectMaskFlag : UInt8 {
            NONE    = 0,
            Color   = as<UInt8>(vk::ImageAspectFlagBits::eColor),
            Depth   = as<UInt8>(vk::ImageAspectFlagBits::eDepth),
            Stencil = as<UInt8>(vk::ImageAspectFlagBits::eStencil),
        };

        enum class VertexInputRate : UInt8 {
            Vertex   = as<UInt8>(vk::VertexInputRate::eVertex),
            Instance = as<UInt8>(vk::VertexInputRate::eInstance),
        };

        enum class ImageCreateFlag : UInt16 {
            NONE             = 0,
            Sparse_Binding   = as<UInt16>(vk::ImageCreateFlagBits::eSparseBinding),
            Sparse_Residency = as<UInt16>(vk::ImageCreateFlagBits::eSparseResidency),
            Sparse_Aliased   = as<UInt16>(vk::ImageCreateFlagBits::eSparseAliased),
            Mutable_Format   = as<UInt16>(vk::ImageCreateFlagBits::eMutableFormat),
            Cube_Compatible  = as<UInt16>(vk::ImageCreateFlagBits::eCubeCompatible),
            Alias            = as<UInt16>(vk::ImageCreateFlagBits::eAlias),
            Split_Instance_Bind_Regions
                = as<UInt16>(vk::ImageCreateFlagBits::eSplitInstanceBindRegions),
            Array_2D_Compatible = as<UInt16>(vk::ImageCreateFlagBits::e2DArrayCompatible),
            Block_Texel_View_Compatible
                = as<UInt16>(vk::ImageCreateFlagBits::eBlockTexelViewCompatible),
            Extended_Usage = as<UInt16>(vk::ImageCreateFlagBits::eExtendedUsage),
            Protected      = as<UInt16>(vk::ImageCreateFlagBits::eProtected),
            Disjoint       = as<UInt16>(vk::ImageCreateFlagBits::eDisjoint),
        };

        enum class Format : UInt8 {
            Byte  = as<UInt8>(vk::format::eR8Sint),
            Byte2 = as<UInt8>(vk::format::eR8G8Sint),
            Byte3 = as<UInt8>(vk::format::eR8G8B8Sint),
            Byte4 = as<UInt8>(vk::format::eR8G8B8A8Sint),

            Byte_Norm  = as<UInt8>(vk::format::eR8Snorm),
            Byte2_Norm = as<UInt8>(vk::format::eR8G8Snorm),
            Byte3_Norm = as<UInt8>(vk::format::eR8G8B8Snorm),
            Byte4_Norm = as<UInt8>(vk::format::eR8G8B8A8Snorm),

            Byte_Scaled  = as<UInt8>(vk::format::eR8Sscaled),
            Byte2_Scaled = as<UInt8>(vk::format::eR8G8Sscaled),
            Byte3_Scaled = as<UInt8>(vk::format::eR8G8B8Sscaled),
            Byte4_Scaled = as<UInt8>(vk::format::eR8G8B8A8Sscaled),

            UByte  = as<UInt8>(vk::format::eR8Uint),
            UByte2 = as<UInt8>(vk::format::eR8G8Uint),
            UByte3 = as<UInt8>(vk::format::eR8G8B8Uint),
            UByte4 = as<UInt8>(vk::format::eR8G8B8A8Uint),

            UByte_Norm  = as<UInt8>(vk::format::eR8Unorm),
            UByte2_Norm = as<UInt8>(vk::format::eR8G8Unorm),
            UByte3_Norm = as<UInt8>(vk::format::eR8G8B8Unorm),
            UByte4_Norm = as<UInt8>(vk::format::eR8G8B8A8Unorm),

            UByte_Ucaled  = as<UInt8>(vk::format::eR8Uscaled),
            UByte2_Ucaled = as<UInt8>(vk::format::eR8G8Uscaled),
            UByte3_Ucaled = as<UInt8>(vk::format::eR8G8B8Uscaled),
            UByte4_Ucaled = as<UInt8>(vk::format::eR8G8B8A8Uscaled),

            Short  = as<UInt8>(vk::format::eR16Sint),
            Short2 = as<UInt8>(vk::format::eR16G16Sint),
            Short3 = as<UInt8>(vk::format::eR16G16B16Sint),
            Short4 = as<UInt8>(vk::format::eR16G16B16A16Sint),

            Short_Norm  = as<UInt8>(vk::format::eR16Sfloat),
            Short2_Norm = as<UInt8>(vk::format::eR16G16Sfloat),
            Short3_Norm = as<UInt8>(vk::format::eR16G16B16Sfloat),
            Short4_Norm = as<UInt8>(vk::format::eR16G16B16A16Sfloat),

            Short_Scaled  = as<UInt8>(vk::format::eR16Sscaled),
            Short2_Scaled = as<UInt8>(vk::format::eR16G16Sscaled),
            Short3_Scaled = as<UInt8>(vk::format::eR16G16B16Sscaled),
            Short4_Scaled = as<UInt8>(vk::format::eR16G16B16A16Sscaled),

            UShort  = as<UInt8>(vk::format::eR16Uint),
            UShort2 = as<UInt8>(vk::format::eR16G16Uint),
            UShort3 = as<UInt8>(vk::format::eR16G16B16Uint),
            UShort4 = as<UInt8>(vk::format::eR16G16B16A16Uint),

            UShort_Norm  = as<UInt8>(vk::format::eR16Unorm),
            UShort2_Norm = as<UInt8>(vk::format::eR16G16Unorm),
            UShort3_Norm = as<UInt8>(vk::format::eR16G16B16Unorm),
            UShort4_Norm = as<UInt8>(vk::format::eR16G16B16A16Unorm),

            UShort_Ucaled  = as<UInt8>(vk::format::eR16Uscaled),
            UShort2_Ucaled = as<UInt8>(vk::format::eR16G16Uscaled),
            UShort3_Ucaled = as<UInt8>(vk::format::eR16G16B16Uscaled),
            UShort4_Ucaled = as<UInt8>(vk::format::eR16G16B16A16Uscaled),

            Int  = as<UInt8>(vk::format::eR32Sint),
            Int2 = as<UInt8>(vk::format::eR32G32Sint),
            Int3 = as<UInt8>(vk::format::eR32G32B32Sint),
            Int4 = as<UInt8>(vk::format::eR32G32B32A32Sint),

            UInt  = as<UInt8>(vk::format::eR32Uint),
            UInt2 = as<UInt8>(vk::format::eR32G32Uint),
            UInt3 = as<UInt8>(vk::format::eR32G32B32Uint),
            UInt4 = as<UInt8>(vk::format::eR32G32B32A32Uint),

            Long  = as<UInt8>(vk::format::eR64Sint),
            Long2 = as<UInt8>(vk::format::eR64G64Sint),
            Long3 = as<UInt8>(vk::format::eR64G64B64Sint),
            Long4 = as<UInt8>(vk::format::eR64G64B64A64Sint),

            ULong  = as<UInt8>(vk::format::eR64Uint),
            ULong2 = as<UInt8>(vk::format::eR64G64Uint),
            ULong3 = as<UInt8>(vk::format::eR64G64B64Uint),
            ULong4 = as<UInt8>(vk::format::eR64G64B64A64Uint),

            Float  = as<UInt8>(vk::format::eR32Sfloat),
            Float2 = as<UInt8>(vk::format::eR32G32Sfloat),
            Float3 = as<UInt8>(vk::format::eR32G32B32Sfloat),
            Float4 = as<UInt8>(vk::format::eR32G32B32A32Sfloat),

            Double  = as<UInt8>(vk::format::eR64Sfloat),
            Double2 = as<UInt8>(vk::format::eR64G64Sfloat),
            Double3 = as<UInt8>(vk::format::eR64G64B64Sfloat),
            Double4 = as<UInt8>(vk::format::eR64G64B64A64Sfloat),

            Undefined = as<UInt8>(vk::format::eUndefined),
        };

        enum class BufferUsageFlag : UInt16 {
            Vertex        = as<UInt16>(vk::BufferUsageFlagBits::eVertexBuffer),
            Index         = as<UInt16>(vk::BufferUsageFlagBits::eIndexBuffer),
            Transfer_Src  = as<UInt16>(vk::BufferUsageFlagBits::eTransferSrc),
            Transfer_Dst  = as<UInt16>(vk::BufferUsageFlagBits::eTransferDst),
            Uniform       = as<UInt16>(vk::BufferUsageFlagBits::eUniformBuffer),
            Storage       = as<UInt16>(vk::BufferUsageFlagBits::eStorageBuffer),
            Uniform_Texel = as<UInt16>(vk::BufferUsageFlagBits::eUniformTexelBuffer),
            Storage_Texel = as<UInt16>(vk::BufferUsageFlagBits::eStorageTexelBuffer),
            Indirect      = as<UInt16>(vk::BufferUsageFlagBits::eIndirectBuffer),
        };

        enum class ImageUsageFlag : UInt16 {
            Transfer_Src             = as<UInt16>(vk::ImageUsageFlagBits::eTransferSrc),
            Transfer_Dst             = as<UInt16>(vk::ImageUsageFlagBits::eTransferDst),
            Sampled                  = as<UInt16>(vk::ImageUsageFlagBits::eSampled),
            Storage                  = as<UInt16>(vk::ImageUsageFlagBits::eStorage),
            Color_Attachment         = as<UInt16>(vk::ImageUsageFlagBits::eColorAttachment),
            Depth_Stencil_Attachment = as<UInt16>(vk::ImageUsageFlagBits::eDepthStencilAttachment),
            Transient_Attachment     = as<UInt16>(vk::ImageUsageFlagBits::eTransientAttachment),
            Input_Attachment         = as<UInt16>(vk::ImageUsageFlagBits::eInputAttachment),
        };

        enum class MemoryPropertyFlag : UInt8 {
            Device_Local  = as<UInt8>(vk::MemoryPropertyFlagBits::eDeviceLocal),
            Host_Visible  = as<UInt8>(vk::MemoryPropertyFlagBits::eHostVisible),
            Host_Coherent = as<UInt8>(vk::MemoryPropertyFlagBits::eHostCoherent),
            Host_Cached   = as<UInt8>(vk::MemoryPropertyFlagBits::eHostCached),
        };

        enum class CommandBufferLevel : UInt8 {
            Primary   = as<UInt8>(vk::CommandBufferLevel::ePrimary),
            Secondary = as<UInt8>(vk::CommandBufferLevel::eSecondary),
        };

        enum class DescriptorType : UInt8 {
            Sampler                = as<UInt8>(vk::DescriptorType::eSampler),
            Combined_Image_Sampler = as<UInt8>(vk::DescriptorType::eCombinedImageSampler),
            Sampled_Image          = as<UInt8>(vk::DescriptorType::eSampledImage),
            Storage_Image          = as<UInt8>(vk::DescriptorType::eStorageImage),
            Uniform_Texel_Buffer   = as<UInt8>(vk::DescriptorType::eUniformTexelBuffer),
            Storage_Texel_Buffer   = as<UInt8>(vk::DescriptorType::eStorageTexelBuffer),
            Uniform_Buffer         = as<UInt8>(vk::DescriptorType::eUniformBuffer),
            Storage_Buffer         = as<UInt8>(vk::DescriptorType::eStorageBuffer),
            Uniform_Buffer_Dynamic = as<UInt8>(vk::DescriptorType::eUniformBufferDynamic),
            Storage_Buffer_Dynamic = as<UInt8>(vk::DescriptorType::eStorageBufferDynamic),
            Input_Attachment       = as<UInt8>(vk::DescriptorType::eInputAttachment),
        };

        enum class CompareOperation : UInt8 {
            Never            = as<UInt8>(vk::CompareOp::eNever),
            Less             = as<UInt8>(vk::CompareOp::eLess),
            Equal            = as<UInt8>(vk::CompareOp::eEqual),
            Less_Or_Equal    = as<UInt8>(vk::CompareOp::eLessOrEqual),
            Greater          = as<UInt8>(vk::CompareOp::eGreater),
            Not_Equal        = as<UInt8>(vk::CompareOp::eNotEqual),
            Greater_Or_Equal = as<UInt8>(vk::CompareOp::eGreaterOrEqual),
            Always           = as<UInt8>(vk::CompareOp::eAlways),
        };

        enum class Filter : UInt32 {
            Nearest   = as<UInt32>(vk::Filter::eNearest),
            Linear    = as<UInt32>(vk::Filter::eLinear),
            Cubic_Img = as<UInt32>(vk::Filter::eCubicIMG),
        };

        enum class SamplerAddressMode : UInt8 {
            Repeat               = as<UInt8>(vk::SamplerAddressMode::eRepeat),
            Mirrored_Repeat      = as<UInt8>(vk::SamplerAddressMode::eMirroredRepeat),
            Clamp_To_Edge        = as<UInt8>(vk::SamplerAddressMode::eClampToEdge),
            Clamp_To_Border      = as<UInt8>(vk::SamplerAddressMode::eClampToBorder),
            Mirror_Clamp_To_Edge = as<UInt8>(vk::SamplerAddressMode::eMirrorClampToEdge),
        };

        enum class BorderColor : UInt8 {
            Float_TRANSPARENT_BLACK = as<UInt8>(vk::BorderColor::eFloatTRANSPARENTBLACK),
            Int_TRANSPARENT_BLACK   = as<UInt8>(vk::BorderColor::eIntTRANSPARENTBLACK),
            Float_Opaque_BLACK      = as<UInt8>(vk::BorderColor::eFloatOpaqueBLACK),
            Int_Opaque_BLACK        = as<UInt8>(vk::BorderColor::eIntOpaqueBLACK),
            Float_Opaque_WHITE      = as<UInt8>(vk::BorderColor::eFloatOpaqueWHITE),
            Int_opaque_WHITE        = as<UInt8>(vk::BorderColor::eIntOpaqueWHITE),
        };

        enum class SamplerMipmapMode : UInt8 {
            Nearest = as<UInt8>(vk::SamplerMipmapMode::eNearest),
            Linear  = as<UInt8>(vk::SamplerMipmapMode::eLinear),
        };

        enum class Result : Int32 {
            Success                       = as<Int32>(vk::Result::eSuccess),
            Not_Ready                     = as<Int32>(vk::Result::eNotReady),
            Timeout                       = as<Int32>(vk::Result::eTimeout),
            Event_Set                     = as<Int32>(vk::Result::eEventSet),
            Event_RESET                   = as<Int32>(vk::Result::eEventRESET),
            Incomplete                    = as<Int32>(vk::Result::eIncomplete),
            Error_Out_Of_host_Memory      = as<Int32>(vk::Result::eErrorOutOfHostMemory),
            Error_Out_Of_Device_Memory    = as<Int32>(vk::Result::eErrorOutOfDeviceMemory),
            Error_Initialization_Failed   = as<Int32>(vk::Result::eErrorInitializationFailed),
            Error_Device_Lost             = as<Int32>(vk::Result::eErrorDeviceLost),
            Error_Memory_Map_Failed       = as<Int32>(vk::Result::eErrorMemoryMapFailed),
            Error_Layer_Not_Present       = as<Int32>(vk::Result::eErrorLayerNotPresent),
            Error_EXTension_Not_Present   = as<Int32>(vk::Result::eErrorExtensionNotPresent),
            Error_Feature_Not_Present     = as<Int32>(vk::Result::eErrorFeatureNotPresent),
            Error_Incompatible_Driver     = as<Int32>(vk::Result::eErrorIncompatibleDriver),
            Error_Too_Many_Objects        = as<Int32>(vk::Result::eErrorTooManyObjects),
            Error_Format_Not_Supported    = as<Int32>(vk::Result::eErrorFormatNotSupported),
            Error_Fragmented_Pool         = as<Int32>(vk::Result::eErrorFragmentedPool),
            Error_Unknown                 = as<Int32>(vk::Result::eErrorUnknown),
            Error_Out_Of_Pool_Memory      = as<Int32>(vk::Result::eErrorOutOfPoolMemory),
            Error_Invalid_EXTernal_Handle = as<Int32>(vk::Result::eErrorInvalidExternalHandle),
            Error_Fragmentation           = as<Int32>(vk::Result::eErrorFragmentation),
            Error_Invalid_Opaque_Capture_Address
                = as<Int32>(vk::Result::eErrorInvalidOpaqueCaptureAddress),
            Error_Surface_Lost         = as<Int32>(vk::Result::eErrorSurfaceLostKHR),
            Error_Native_Window_In_Use = as<Int32>(vk::Result::eErrorNativeWindowInUseKHR),
            Suboptimal                 = as<Int32>(vk::Result::eSuboptimalKHR),
            Error_Out_Of_Data          = as<Int32>(vk::Result::eErrorOutOfDateKHR),
            Error_Incompatible_Display = as<Int32>(vk::Result::eErrorIncompatibleDisplayKHR),
            Error_Validation_Failed    = as<Int32>(vk::Result::eErrorValidationFailedEXT),
            Error_Not_Permitted        = as<Int32>(vk::Result::eErrorNotPermittedEXT),
#if defined(VK_USE_PLATFORM_WIN32_KHR)
            Error_Fullscreen_Exclusive_Mode_Lost
                = as<Int32>(vk::Result::eErrorFullScreenExclusiveModeLostEXT),
#endif
            Thread_Idle               = as<Int32>(vk::Result::eThreadIdleKHR),
            Thread_Done               = as<Int32>(vk::Result::eThreadDoneKHR),
            Operation_Deferred        = as<Int32>(vk::Result::eOperationDeferredKHR),
            Operation_Not_Deferred    = as<Int32>(vk::Result::eOperationNotDeferredKHR),
            Pipeline_Compile_Required = as<Int32>(vk::Result::ePipelineCompileRequired),
        };

        enum class ImageType : UInt8 {
            T1D = as<UInt8>(vk::ImageType::e1D),
            T2D = as<UInt8>(vk::ImageType::e2D),
            T3D = as<UInt8>(vk::ImageType::e3D),
        };

        enum class ImageViewType : UInt8 {
            T1D        = as<UInt8>(vk::ImageViewType::e1D),
            T2D        = as<UInt8>(vk::ImageViewType::e2D),
            T3D        = as<UInt8>(vk::ImageViewType::e3D),
            Cube       = as<UInt8>(vk::ImageViewType::eCube),
            T1D_Array  = as<UInt8>(vk::ImageViewType::e1DArray),
            T2D_Array  = as<UInt8>(vk::ImageViewType::e2DArray),
            Cube_Array = as<UInt8>(vk::ImageViewType::eCubeArray),
        };

        enum class DebugObjectType : UInt32 {
            Unknown               = as<UInt32>(vk::ObjectType::eUnknown),
            Instance              = as<UInt32>(vk::ObjectType::eInstance),
            Physical_Device       = as<UInt32>(vk::ObjectType::ePhysicalDevice),
            Device                = as<UInt32>(vk::ObjectType::eDevice),
            Queue                 = as<UInt32>(vk::ObjectType::eQueue),
            Semaphore             = as<UInt32>(vk::ObjectType::eSemaphore),
            Command_Buffer        = as<UInt32>(vk::ObjectType::eCommandBuffer),
            Fence                 = as<UInt32>(vk::ObjectType::eFence),
            Device_Memory         = as<UInt32>(vk::ObjectType::eDeviceMemory),
            Buffer                = as<UInt32>(vk::ObjectType::eBuffer),
            Image                 = as<UInt32>(vk::ObjectType::eImage),
            Event                 = as<UInt32>(vk::ObjectType::eEvent),
            Query_Pool            = as<UInt32>(vk::ObjectType::eQueryPool),
            Buffer_View           = as<UInt32>(vk::ObjectType::eBufferView),
            Image_View            = as<UInt32>(vk::ObjectType::eImageView),
            Shader_Module         = as<UInt32>(vk::ObjectType::eShaderModule),
            Pipeline_Cache        = as<UInt32>(vk::ObjectType::ePipelineCache),
            Pipeline_Layout       = as<UInt32>(vk::ObjectType::ePipelineLayout),
            Render_Pass           = as<UInt32>(vk::ObjectType::eRenderPass),
            Pipeline              = as<UInt32>(vk::ObjectType::ePipeline),
            PipelineLayout        = as<UInt32>(vk::ObjectType::ePipelineLayout),
            Descriptor_Set_Layout = as<UInt32>(vk::ObjectType::eDescriptorSetLayout),
            Sampler               = as<UInt32>(vk::ObjectType::eSampler),
            Descriptor_Pool       = as<UInt32>(vk::ObjectType::eDescriptorPool),
            Descriptor_Set        = as<UInt32>(vk::ObjectType::eDescriptorSet),
            FrameBuffer           = as<UInt32>(vk::ObjectType::eFramebuffer),
            Command_Pool          = as<UInt32>(vk::ObjectType::eCommandPool),
            Surface               = as<UInt32>(vk::ObjectType::eSurfaceKHR),
            Swapchain             = as<UInt32>(vk::ObjectType::eSwapchainKHR),
            Debug_Report_Callback = as<UInt32>(vk::ObjectType::eDebugReportCallbackEXT),
            Display_KHR           = as<UInt32>(vk::ObjectType::eDisplayKHR),
        };

        enum class AccessFlag : UInt32 {
            NONE                   = as<UInt32>(vk::AccessFlagBits::eNONEKHR),
            Indirect_Command_Read  = as<UInt32>(vk::AccessFlagBits::eIndirectCommandRead),
            Vertex_Attribute_Read  = as<UInt32>(vk::AccessFlagBits::eVertexAttributeRead),
            Uniform_Read           = as<UInt32>(vk::AccessFlagBits::eUniformRead),
            Input_Attachment_Read  = as<UInt32>(vk::AccessFlagBits::eInputAttachmentRead),
            Shader_Read            = as<UInt32>(vk::AccessFlagBits::eShaderRead),
            Shader_Write           = as<UInt32>(vk::AccessFlagBits::eShaderWrite),
            Color_Attachment_Read  = as<UInt32>(vk::AccessFlagBits::eColorAttachmentRead),
            Color_Attachment_Write = as<UInt32>(vk::AccessFlagBits::eColorAttachmentWrite),
            Depth_Stencil_Attachment_Read
                = as<UInt32>(vk::AccessFlagBits::eDepthStencilAttachmentRead),
            Depth_Stencil_Attachment_Write
                = as<UInt32>(vk::AccessFlagBits::eDepthStencilAttachmentWrite),
            Transfer_Read  = as<UInt32>(vk::AccessFlagBits::eTransferRead),
            Transfer_Write = as<UInt32>(vk::AccessFlagBits::eTransferWrite),
            Host_Read      = as<UInt32>(vk::AccessFlagBits::eHostRead),
            Host_Write     = as<UInt32>(vk::AccessFlagBits::eHostWrite),
            Memory_Read    = as<UInt32>(vk::AccessFlagBits::eMemoryRead),
            Memory_Write   = as<UInt32>(vk::AccessFlagBits::eMemoryWrite),
        };

        enum class PipelineStageFlag : UInt32 {
            NONE          = as<UInt32>(vk::PipelineStageFlagBits::eNONEKHR),
            Top_Of_Pipe   = as<UInt32>(vk::PipelineStageFlagBits::eTopOfPipe),
            Draw_Indirect = as<UInt32>(vk::PipelineStageFlagBits::eDrawIndirect),
            Vertex_Input  = as<UInt32>(vk::PipelineStageFlagBits::eVertexInput),
            Vertex_Shader = as<UInt32>(vk::PipelineStageFlagBits::eVertexShader),
            Tessellation_Control_Shader
                = as<UInt32>(vk::PipelineStageFlagBits::eTessellationControlShader),
            Tessellation_Evaluation_Shader
                = as<UInt32>(vk::PipelineStageFlagBits::eTessellationEvaluationShader),
            Geometry_Shader         = as<UInt32>(vk::PipelineStageFlagBits::eGeometryShader),
            Fragment_Shader         = as<UInt32>(vk::PipelineStageFlagBits::eFragmentShader),
            Early_Fragment_Tests    = as<UInt32>(vk::PipelineStageFlagBits::eEarlyFragmentTests),
            Late_Fragment_Tests     = as<UInt32>(vk::PipelineStageFlagBits::eLateFragmentTests),
            Color_Attachment_Output = as<UInt32>(vk::PipelineStageFlagBits::eColorAttachmentOutput),
            Compute_Shader          = as<UInt32>(vk::PipelineStageFlagBits::eComputeShader),
            Transfer                = as<UInt32>(vk::PipelineStageFlagBits::eTransfer),
            Bottom_Of_Pipe          = as<UInt32>(vk::PipelineStageFlagBits::eBottomOfPipe),
            Host                    = as<UInt32>(vk::PipelineStageFlagBits::eHost),
            All_Graphics            = as<UInt32>(vk::PipelineStageFlagBits::eAllGraphics),
            All_Commands            = as<UInt32>(vk::PipelineStageFlagBits::eAllCommands),
        };

        enum class DependencyFlag : UInt8 {
            NONE         = 0,
            By_Region    = as<UInt8>(vk::DependencyFlagBits::eByRegion),
            Device_Group = as<UInt8>(vk::DependencyFlagBits::eByRegion),
            View_Local   = as<UInt8>(vk::DependencyFlagBits::eViewLocal),
        };

        enum class DynamicState : UInt8 {
            Viewport             = as<UInt8>(vk::DynamicState::eViewport),
            Scissor              = as<UInt8>(vk::DynamicState::eScissor),
            Line_Width           = as<UInt8>(vk::DynamicState::eLineWidth),
            Depth_Bias           = as<UInt8>(vk::DynamicState::eDepthBias),
            Blend_Constants      = as<UInt8>(vk::DynamicState::eBlendConstants),
            Depth_Bounds         = as<UInt8>(vk::DynamicState::eDepthBounds),
            Stencil_Compare_Mask = as<UInt8>(vk::DynamicState::eStencilCompareMask),
            Stencil_Write_Mask   = as<UInt8>(vk::DynamicState::eStencilWriteMask),
            Stencil_Reference    = as<UInt8>(vk::DynamicState::eStencilReference),
        };

        enum class ImageTiling : UInt32 {
            Optimal = as<UInt32>(vk::ImageTiling::eOptimal),
            Linear  = as<UInt32>(vk::ImageTiling::eLinear),
            DRM_Ext = as<UInt32>(vk::ImageTiling::eDrmFormatModifierEXT),
        };

        enum class StencilFaceFlag : UInt8 {
            Front          = as<UInt8>(vk::StencilFaceFlagBits::eFront),
            Back           = as<UInt8>(vk::StencilFaceFlagBits::eBack),
            Front_And_Back = Front | Back
        };

        enum class GeometryType : UInt8 {
            Triangles = as<UInt8>(vk::GeometryTypeKHR::eTriangles),
            AABBS     = as<UInt8>(vk::GeometryTypeKHR::eAabbs),
            Instances = as<UInt8>(vk::GeometryTypeKHR::eInstances)
        };

        enum class GeometryFlag : UInt8 {
            Opaque = as<UInt8>(vk::GeometryFlagBitsKHR::eOpaque),
            No_Duplicate_Any_Hit_Invocation
                = as<UInt8>(vk::GeometryFlagBitsKHR::eNoDuplicateAnyHitInvocation)
        };

        enum class ColorSpace : UInt32 {
            SRGB_NonLinear       = as<UInt32>(vk::ColorSpaceKHR::eSrgbNonlinear),
            Display_P3_NonLinear = as<UInt32>(vk::ColorSpaceKHR::eDisplayP3NonlinearEXT),
            // COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT    = 1000104002,
            // COLOR_SPACE_DISPLAY_P3_LINEAR_EXT       = 1000104003,
            // COLOR_SPACE_DCI_P3_NONLINEAR_EXT        = 1000104004,
            // COLOR_SPACE_BT709_LINEAR_EXT            = 1000104005,
            // COLOR_SPACE_BT709_NONLINEAR_EXT         = 1000104006,
            // COLOR_SPACE_BT2020_LINEAR_EXT           = 1000104007,
            // COLOR_SPACE_HDR10_ST2084_EXT            = 1000104008,
            // COLOR_SPACE_DOLBYVISION_EXT             = 1000104009,
            // COLOR_SPACE_HDR10_HLG_EXT               = 1000104010,
            // COLOR_SPACE_ADOBERGB_LINEAR_EXT         = 1000104011,
            // COLOR_SPACE_ADOBERGB_NONLINEAR_EXT      = 1000104012,
            // COLOR_SPACE_PASS_THROUGH_EXT            = 1000104013,
            // COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT = 1000104014,
            // COLOR_SPACE_DISPLAY_NATIVE_AMD          = 1000213000,
            // COLORSPACE_SRGB_NONLINEAR_KHR           = COLOR_SPACE_SRGB_NONLINEAR_KHR,
            // COLOR_SPACE_DCI_P3_LINEAR_EXT           = COLOR_SPACE_DISPLAY_P3_LINEAR_EXT,
        };

        enum class PresentMode : UInt32 {
            Immediate                 = as<UInt32>(vk::PresentModeKHR::eImmediate),
            Mailbox                   = as<UInt32>(vk::PresentModeKHR::eMailbox),
            Fifo                      = as<UInt32>(vk::PresentModeKHR::eFifo),
            Fifo_Relaxed              = as<UInt32>(vk::PresentModeKHR::eFifoRelaxed),
            Shared_Demand_Refresh     = as<UInt32>(vk::PresentModeKHR::eSharedDemandRefresh),
            Shared_Continuous_Refresh = as<UInt32>(vk::PresentModeKHR::eSharedContinuousRefresh),
        };

        struct SurfaceFormat {
            PixelFormat format;
            ColorSpace  color_space;
        };

        struct MemoryBarrier {
            AccessFlag src;
            AccessFlag dst;
        };

        struct RenderCapabilities {
            struct {
                bool robust_buffer_access;
                bool full_draw_index_uint32;
                bool image_cube_array;
                bool independent_blend;
                bool geometry_shader;
                bool tessellation_shader;
                bool sampler_rate_shading;
                bool dual_src_blend;
                bool logic_op;
                bool multi_draw_indirect;
                bool draw_indirect_first_instance;
                bool depth_clamp;
                bool depth_bias_clamp;
                bool fill_Mode_non_solid;
                bool depth_bounds;
                bool wide_lines;
                bool large_points;
                bool alpha_to_one;
                bool multi_viewport;
                bool sampler_anisotropy;
                bool texture_compression_etc2;
                bool texture_compression_astc_ldr;
                bool texture_compression_bc;
                bool occlusion_query_precise;
                bool pipeline_statistics_query;
                bool vertex_pipeline_stores_and_atomics;
                bool fragment_stores_and_atomics;
                bool shader_tessellation_and_geometry_point_size;
                bool shader_image_gather_extended;
                bool shader_storage_image_extended_formats;
                bool shader_storage_image_multisample;
                bool shader_storage_image_read_without_format;
                bool shader_storage_image_write_without_format;
                bool shader_uniform_buffer_array_dynamic_indexing;
                bool shader_sampled_image_array_dynamic_indexing;
                bool shader_storage_buffer_array_dynamic_indexing;
                bool shader_storage_image_array_dynamic_indexing;
                bool shader_clip_distance;
                bool shader_cull_distance;
                bool shader_float_64;
                bool shader_int_64;
                bool shader_int_16;
                bool shader_resource_residency;
                bool shader_resource_min_lod;
                bool sparse_binding;
                bool sparse_residency_buffer;
                bool sparse_residency_image_2D;
                bool sparse_residency_image_3D;
                bool sparse_residency_2_samples;
                bool sparse_residency_4_samples;
                bool sparse_residency_6_samples;
                bool sparse_residency_8_samples;
                bool sparse_residency_16_samples;
                bool sparse_residency_aliased;
                bool variable_multisample_rate;
                bool inherited_queries;
            } features;

            struct {
                UInt32                     max_image_dimension_1D;
                UInt32                     max_image_dimension_2D;
                UInt32                     max_image_dimension_3D;
                UInt32                     max_image_dimension_cube;
                UInt32                     max_image_array_layers;
                UInt32                     max_texel_buffer_elements;
                UInt32                     max_uniform_buffer_range;
                std::optional<UInt32>      max_storage_buffer_range;
                UInt32                     max_push_constants_size;
                std::optional<UInt32>      max_memory_allocation_count;
                std::optional<UInt32>      max_sampler_allocation_count;
                std::optional<UInt64>      buffer_image_granularity;
                std::optional<UInt64>      sparse_address_space_size;
                std::optional<UInt32>      max_bound_descriptor_sets;
                UInt32                     max_per_stage_descriptor_samplers;
                UInt32                     max_per_stage_descriptor_uniform_buffers;
                UInt32                     max_per_stage_descriptor_storage_buffers;
                UInt32                     max_per_stage_descriptor_sampled_images;
                UInt32                     max_per_stage_descriptor_storage_images;
                std::optional<UInt32>      max_per_stage_descriptor_input_attachments;
                std::optional<UInt32>      max_per_stage_resources;
                UInt32                     max_descriptor_set_samplers;
                UInt32                     max_descriptor_set_uniform_buffers;
                UInt32                     max_descriptor_set_uniform_buffers_dynamic;
                UInt32                     max_descriptor_set_storage_buffers;
                UInt32                     max_descriptor_set_storage_buffers_dynamic;
                UInt32                     max_descriptor_set_sampled_images;
                UInt32                     max_descriptor_set_storage_images;
                std::optional<UInt32>      max_descriptor_set_input_attachments;
                UInt32                     max_vertex_input_attributes;
                UInt32                     max_vertex_input_bindings;
                UInt32                     max_vertex_input_attribute_offset;
                std::optional<UInt32>      max_vertex_input_binding_stride;
                UInt32                     max_vertex_output_components;
                UInt32                     max_tessellation_generation_level;
                UInt32                     max_tessellation_patch_size;
                UInt32                     max_tessellation_control_per_vertex_input_components;
                UInt32                     max_tessellation_control_per_vertex_output_components;
                UInt32                     max_tessellation_control_per_patch_output_components;
                UInt32                     max_tessellation_control_total_output_components;
                UInt32                     max_tessellation_evaluation_input_components;
                UInt32                     max_tessellation_evaluation_output_components;
                UInt32                     max_geometry_shader_invocations;
                UInt32                     max_geometry_input_components;
                UInt32                     max_geometry_output_components;
                UInt32                     max_geometry_output_vertices;
                UInt32                     max_geometry_total_output_components;
                UInt32                     max_fragment_input_components;
                UInt32                     max_fragment_output_attachments;
                UInt32                     max_fragment_dual_src_attachments;
                UInt32                     max_fragment_combined_output_resources;
                UInt32                     max_compute_shared_memory_size;
                std::array<UInt32, 3>      max_compute_work_group_count;
                UInt32                     max_compute_work_group_invocations;
                std::array<UInt32, 3>      max_compute_work_group_size;
                std::optional<UInt32>      sub_pixel_precision_bits;
                std::optional<UInt32>      sub_texel_precision_bits;
                std::optional<UInt32>      mipmap_precision_bits;
                UInt32                     max_draw_indexed_index_value;
                std::optional<UInt32>      max_draw_indirect_count;
                float                      max_sampler_lod_bias;
                float                      max_sampler_anisotropy;
                UInt32                     max_viewports;
                std::array<UInt32, 2>      max_viewport_dimensions;
                std::array<float, 2>       viewport_bounds_range;
                std::optional<UInt32>      viewport_sub_pixel_bits;
                std::optional<RangeExtent> min_memory_map_alignment;
                std::optional<UInt64>      min_texel_buffer_offset_alignment;
                UInt64                     min_uniform_buffer_offset_alignment;
                UInt64                     min_storage_buffer_offset_alignment;
                Int32                      min_texel_offset;
                UInt32                     max_texel_offset;
                Int32                      min_texel_gather_offset;
                UInt32                     max_texel_gather_offset;
                float                      min_interpolation_offset;
                float                      max_interpolation_offset;
                std::optional<UInt32>      sub_pixel_interpolation_offset_bits;
                UInt32                     max_framebuffer_width;
                UInt32                     max_framebuffer_height;
                UInt32                     max_framebuffer_layers;
                SampleCountFlag            framebuffer_color_sample_counts;
                SampleCountFlag            framebuffer_depth_sample_counts;
                SampleCountFlag            framebuffer_stencil_sample_counts;
                SampleCountFlag            framebuffer_no_attachments_sample_counts;
                UInt32                     max_color_attachments;
                SampleCountFlag            sampled_image_color_sample_counts;
                SampleCountFlag            sampled_image_integer_sample_counts;
                SampleCountFlag            sampled_image_depth_sample_counts;
                SampleCountFlag            sampled_image_stencil_sample_counts;
                SampleCountFlag            storage_image_sample_counts;
                UInt32                     max_sample_mask_words;
                bool                       timestamp_compute_and_engine;
                float                      timestamp_period;
                UInt32                     max_clip_distances;
                UInt32                     max_cull_distances;
                UInt32                     max_combined_clip_and_cull_distances;
                UInt32                     discrete_queue_priorities;
                std::array<float, 2>       point_size_range;
                std::array<float, 2>       line_width_range;
                float                      point_size_granularity;
                float                      line_width_granularity;
                bool                       strict_lines;
                bool                       standard_sample_locations;
                std::optional<UInt64>      optimal_buffer_copy_offset_alignment;
                std::optional<UInt64>      optimal_buffer_copy_row_pitch_alignment;
                UInt64                     non_coherent_atom_size;
            } limits;
        };

        struct ImageSubresourceRange {
            ImageAspectMaskFlag aspect_mask = ImageAspectMaskFlag::Color;

            UInt32 base_mip_level   = 0u;
            UInt32 level_count      = 1u;
            UInt32 base_array_layer = 0u;
            UInt32 layer_count      = 1u;
        };

        struct ImageSubresourceLayers {
            ImageAspectMaskFlag aspect_mask = ImageAspectMaskFlag::Color;

            UInt32 mip_level        = 0u;
            UInt32 base_array_layer = 0u;
            UInt32 layer_count      = 1u;
        };

        struct Viewport {
            math::Vector2F position;
            math::ExtentF  extent;
            math::Vector2F depth;

            constexpr operator vk::Viewport() const noexcept;
        };

        struct Scissor {
            math::Vector2I offset;
            math::ExtentU  extent;

            constexpr operator vk::Rect2D() const noexcept;
        };

        struct ClearColor {
            RGBColorF color = stormkit::RGBColorDef::SILVER<float>;
        };

        struct ClearDepthStencil {
            float  depth   = 1.f;
            UInt32 stencil = 0;
        };

        using ClearValue = std::variant<ClearColor, ClearDepthStencil>;

        struct BufferImageCopy {
            UInt32 buffer_offset;
            UInt32 buffer_row_length;
            UInt32 buffer_image_height;

            ImageSubresourceLayers subresource_layers;

            math::Vector3I offset;
            math::ExtentU  extent;
        };

        struct BlitRegion {
            ImageSubresourceLayers src;
            ImageSubresourceLayers dst;

            std::array<math::Vector3F, 2> src_offset;
            std::array<math::Vector3F, 2> dst_offset;
        };

        struct PushConstantRange {
            ShaderStageFlag stages;
            UInt32          offset;
            RangeExtent     size;
        };

        struct PhysicalDeviceInfo {
            UInt64      device_id;
            std::string device_name;
            UInt64      vendor_id;
            std::string vendor_name;

            UInt32 api_major_version;
            UInt32 api_minor_version;
            UInt32 api_patch_version;

            UInt32 driver_major_version;
            UInt32 driver_minor_version;
            UInt32 driver_patch_version;

            std::array<UInt8, vk::UuidSize> pipeline_cache_uuid;

            PhysicalDeviceType type;
        };

        struct QueueFamily {
            QueueFlag flags;
            UInt32    count;
        };

        using ClearValue = std::variant<ClearColor, ClearDepthStencil>;
        using SpirvID    = UInt32;

        template<class T>
        using Expected = std::expected<T, Result>;

        [[nodiscard]]
        constexpr auto isDepthOnlyFormat(PixelFormat format) noexcept -> bool;
        [[nodiscard]]
        constexpr auto isDepthStencilFormat(PixelFormat format) noexcept -> bool;
        [[nodiscard]]
        constexpr auto isDepthFormat(PixelFormat format) noexcept -> bool;

        [[nodiscard]]
        constexpr auto get_format_channel_count(PixelFormat format) noexcept -> UInt8;
        [[nodiscard]]
        constexpr auto getArraySizeByChannelFor(PixelFormat format) noexcept -> UInt8;

        [[nodiscard]]
        auto computeMipLevel(const math::ExtentU& extent) noexcept -> UInt32;
        [[nodiscard]]
        constexpr auto
            computeUniformBufferOffsetAlignement(RangeExtent               size,
                                                 const RenderCapabilities& capabilities) noexcept
            -> RangeExtent;

        [[nodiscard]]
        auto to_string(const PhysicalDeviceInfo& data) noexcept;

    } // namespace stormkit::gpu

    ASCASTER_STRICT_DECLARE(vk::Viewport, stormkit::gpu::Viewport)
    ASCASTER_STRICT_DECLARE(vk::Rect2D, stormkit::gpu::Scissor)

    FLAG_ENUM(stormkit::gpu::QueueFlag)
    FLAG_ENUM(stormkit::gpu::ShaderStageFlag)
    FLAG_ENUM(stormkit::gpu::SampleCountFlag)
    FLAG_ENUM(stormkit::gpu::ColorComponentFlag)
    FLAG_ENUM(stormkit::gpu::ImageAspectMaskFlag)
    FLAG_ENUM(stormkit::gpu::ImageCreateFlag)
    FLAG_ENUM(stormkit::gpu::CullModeFlag)
    FLAG_ENUM(stormkit::gpu::BufferUsageFlag)
    FLAG_ENUM(stormkit::gpu::ImageUsageFlag)
    FLAG_ENUM(stormkit::gpu::MemoryPropertyFlag)
    FLAG_ENUM(stormkit::gpu::AccessFlag)
    FLAG_ENUM(stormkit::gpu::PipelineStageFlag)
    FLAG_ENUM(stormkit::gpu::DependencyFlag)
    FLAG_ENUM(stormkit::gpu::StencilFaceFlag)
    FLAG_ENUM(stormkit::gpu::GeometryFlag)
    HASH_FUNC(stormkit::gpu::Viewport, value.position, value.extent, value.depth)
    HASH_FUNC(stormkit::gpu::Scissor, value.offset, value.extent)
}

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit::gpu {
    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE constexpr auto isDepthOnlyFormat(PixelFormat format) noexcept -> bool {
        return format == PixelFormat::Depth16
               or format == PixelFormat::Depth24
               or format == PixelFormat::Depth32F;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE constexpr auto isDepthStencilFormat(PixelFormat format) noexcept -> bool {
        return format == PixelFormat::Depth16_Stencil8
               or format == PixelFormat::Depth24_Stencil8
               or format == PixelFormat::Depth32F_Stencil8;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE constexpr auto isDepthFormat(PixelFormat format) noexcept -> bool {
        return isDepthOnlyFormat(format) or isDepthStencilFormat(format);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE constexpr auto get_format_channel_count(PixelFormat format) noexcept
        -> UInt8 {
        switch (format) {
            case PixelFormat::R8_SNORM:
            case PixelFormat::R8_UNORM:
            case PixelFormat::R16_SNORM:
            case PixelFormat::R16_UNORM:
            case PixelFormat::R8I:
            case PixelFormat::R8U:
            case PixelFormat::R16I:
            case PixelFormat::R16U:
            case PixelFormat::R32I:
            case PixelFormat::R32U:
            case PixelFormat::R16F:
            case PixelFormat::R32F:
            case PixelFormat::Depth16:
            case PixelFormat::Depth24:
            case PixelFormat::Depth32F: return 1;

            case PixelFormat::RG8_SNORM:
            case PixelFormat::RG8_UNORM:
            case PixelFormat::RG16_SNORM:
            case PixelFormat::RG16_UNORM:
            case PixelFormat::RG8I:
            case PixelFormat::RG8U:
            case PixelFormat::RG16I:
            case PixelFormat::RG16U:
            case PixelFormat::RG32I:
            case PixelFormat::RG32U:
            case PixelFormat::RG16F:
            case PixelFormat::RG32F:
            case PixelFormat::Depth16_Stencil8:
            case PixelFormat::Depth24_Stencil8:
            case PixelFormat::Depth32F_Stencil8: return 2;

            case PixelFormat::RGB8_SNORM:
            case PixelFormat::RGB8_UNORM:
            case PixelFormat::RGB16_SNORM:
            case PixelFormat::RGB16_UNORM:
            case PixelFormat::BGR8_UNORM:
            case PixelFormat::RGB8I:
            case PixelFormat::RGB8U:
            case PixelFormat::RGB16I:
            case PixelFormat::RGB16U:
            case PixelFormat::RGB32I:
            case PixelFormat::RGB32U:
            case PixelFormat::RGB16F:
            case PixelFormat::RGB32F:
            case PixelFormat::SRGB8:
            case PixelFormat::SBGR8:
            case PixelFormat::R5_G6_B5_UNorm_Pack16:
            case PixelFormat::BG11_R10F_Pack32: return 3;

            case PixelFormat::RGBA8_SNORM:
            case PixelFormat::RGBA8_UNORM:
            case PixelFormat::RGBA16_SNORM:
            case PixelFormat::RGBA16_UNORM:
            case PixelFormat::BGRA8_UNORM:
            case PixelFormat::RGBA8I:
            case PixelFormat::RGBA8U:
            case PixelFormat::RGBA16I:
            case PixelFormat::RGBA16U:
            case PixelFormat::RGBA32I:
            case PixelFormat::RGBA32U:
            case PixelFormat::RGBA16F:
            case PixelFormat::RGBA32F:
            case PixelFormat::SRGBA8:
            case PixelFormat::SBGRA8: return 4;

            default: break;
        }

        return 0u;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE constexpr auto getArraySizeByChannelFor(PixelFormat format) noexcept
        -> UInt8 {
        switch (format) {
            case PixelFormat::R8_SNORM:
            case PixelFormat::R8_UNORM:
            case PixelFormat::RG8_SNORM:
            case PixelFormat::RG8_UNORM:
            case PixelFormat::R8I:
            case PixelFormat::R8U:
            case PixelFormat::RG8I:
            case PixelFormat::RG8U:
            case PixelFormat::RGB8_SNORM:
            case PixelFormat::RGB8_UNORM:
            case PixelFormat::BGR8_UNORM:
            case PixelFormat::RGB8I:
            case PixelFormat::RGB8U:
            case PixelFormat::RGBA8_SNORM:
            case PixelFormat::RGBA8_UNORM:
            case PixelFormat::RGBA16_SNORM:
            case PixelFormat::BGRA8_UNORM:
            case PixelFormat::SRGB8:
            case PixelFormat::SBGR8:
            case PixelFormat::SRGBA8:
            case PixelFormat::SBGRA8: return 1u;

            case PixelFormat::R16_SNORM:
            case PixelFormat::R16_UNORM:
            case PixelFormat::R16I:
            case PixelFormat::R16U:
            case PixelFormat::RG16_SNORM:
            case PixelFormat::RG16_UNORM:
            case PixelFormat::RG16I:
            case PixelFormat::RG16U:
            case PixelFormat::RG16F:
            case PixelFormat::RGB16I:
            case PixelFormat::RGB16U:
            case PixelFormat::RGB16F:
            case PixelFormat::RGBA16I:
            case PixelFormat::RGBA16U:
            case PixelFormat::RGBA16F:
            case PixelFormat::R16F: return 2u;

            case PixelFormat::R32I:
            case PixelFormat::R32U:
            case PixelFormat::R32F:
            case PixelFormat::RG32I:
            case PixelFormat::RG32U:
            case PixelFormat::RG32F:
            case PixelFormat::RGB16_SNORM:
            case PixelFormat::RGB32I:
            case PixelFormat::RGB32U:
            case PixelFormat::RGB32F:
            case PixelFormat::RGBA8I:
            case PixelFormat::RGBA8U:
            case PixelFormat::RGBA32I:
            case PixelFormat::RGBA32U:
            case PixelFormat::RGBA32F: return 4u;

            default: break;
        }

        return 0u;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE constexpr Viewport::operator vk::Viewport() const noexcept {
        return vk::Viewport {}
            .setX(position.x)
            .setY(position.y)
            .setWidth(extent.width)
            .setHeight(extent.height)
            .setMinDepth(depth.x)
            .setMaxDepth(depth.y);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE constexpr Scissor::operator vk::Rect2D() const noexcept {
        return vk::Rect2D {}
            .setOffset(as<vk::Offset2D>(offset))
            .set_extent(as<vk::Extent2D>(extent));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto computeMipLevel(const math::ExtentU& extent) noexcept -> UInt32 {
        const auto as_float = math::ExtentF { extent };

        return as<UInt32>(math::floor(math::log2(math::max(as_float.width, as_float.height)))) + 1;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE constexpr auto
        computeUniformBufferOffsetAlignement(RangeExtent               size,
                                             const RenderCapabilities& capabilities) noexcept
        -> RangeExtent {
        const auto min_ubo_align = capabilities.limits.min_uniform_buffer_offset_alignment;

        if (min_ubo_align > 0) size = (size + min_ubo_align - 1) & ~(min_ubo_align - 1);

        return size;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto to_string(const PhysicalDeviceInfo& data) noexcept {
        return std::format("[PhysicalDeviceInfo:\n"
                           "   .device_id      = {:#06x},\n"
                           "   .device_name    = {},\n"
                           "   .vendor_id      = {:#06x},\n"
                           "   .vendor_name    = {},\n"
                           "   .api_version    = {}.{}.{},\n"
                           "   .driver_version = {}.{}.{},\n"
                           "   .type           = {}]",
                           data.device_id,
                           data.device_name,
                           data.vendor_id,
                           data.vendor_name,
                           data.api_major_version,
                           data.api_minor_version,
                           data.api_patch_version,
                           data.driver_major_version,
                           data.driver_minor_version,
                           data.driver_patch_version,
                           data.type);
    }
} // namespace stormkit::gpu

/////////////////////////////////////
/////////////////////////////////////
ASCASTER_STRICT_DEFINE(vk::Viewport, stormkit::gpu::Viewport) {
    return from.operator vk::Viewport();
}

/////////////////////////////////////
/////////////////////////////////////
ASCASTER_STRICT_DEFINE(vk::Rect2D, stormkit::gpu::Scissor) {
    return from.operator vk::Rect2D();
}
