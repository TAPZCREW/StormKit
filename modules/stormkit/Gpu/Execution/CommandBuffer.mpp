// Copyright (C) 2023 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

module;

#include <stormkit/Core/HashMacro.hpp>
#include <stormkit/Core/PlatformMacro.hpp>

export module stormkit.Gpu:Execution.CommandBuffer;

import std;

import frozen;

import stormkit.core;
import stormkit.Gpu.Vulkan;

import :Core;
import :Resource;
import :Execution.Descriptors;
import :Execution.RenderPass;
import :Execution.Pipeline;

export namespace stormkit::gpu {
    struct SubmitInfo {
        std::span<const Ref<const Semaphore>>     wait_semaphores   = {};
        std::span<const PipelineStageFlag>        wait_dst_stages   = {};
        std::span<const Ref<const CommandBuffer>> command_buffers   = {};
        std::span<const Ref<const Semaphore>>     signal_semaphores = {};
    };

    class STORMKIT_API Queue {
        struct Tag {};

      public:
        static constexpr auto DEBUG_TYPE = DebugObjectType::Queue;

        Queue(const Device& device, const Device::QueueEntry& entry, Tag);
        ~Queue();

        Queue(const Queue&)          = delete;
        auto operator=(const Queue&) = delete;

        Queue(Queue&&) noexcept;
        auto operator=(Queue&&) noexcept -> Queue&;

        [[nodiscard]] static auto create(const Device&             device,
                                         const Device::QueueEntry& entry) noexcept
            -> Expected<Queue>;
        [[nodiscard]] static auto allocate(const Device&             device,
                                           const Device::QueueEntry& entry) noexcept
            -> Expected<std::unique_ptr<Queue>>;

        auto waitIdle() const noexcept -> void;

        auto submit(std::span<const SubmitInfo> submit_infos,
                    OptionalRef<const Fence>    fence = std::nullopt) const noexcept -> void;

        auto submit(const SubmitInfo&        submit_info,
                    OptionalRef<const Fence> fence = std::nullopt) const noexcept -> void;

        [[nodiscard]] auto present(std::span<const Ref<const Swapchain>> swapchains,
                                   std::span<const Ref<const Semaphore>> wait_semaphores,
                                   std::span<const UInt32> image_indices) const noexcept
            -> Expected<gpu::Result>;

        [[nodiscard]] auto entry() const noexcept -> const Device::QueueEntry&;

        [[nodiscard]] auto vkHandle() const noexcept -> const vk::raii::Queue&;

      private:
        Device::QueueEntry m_entry;

        DeferInit<vk::raii::Queue> m_vk_queue;
    };

    class CommandPool;

    struct InheritanceInfo {
        const RenderPass*  render_pass = nullptr;
        UInt32             subpass     = 0;
        const FrameBuffer* framebuffer = nullptr;
    };

    template<typename T>
    concept IsImage = requires(T&& img) {
        img.extent();
        img.format();
        img.type();
        img.samples();
        img.layers();
        img.faces();
        img.mipLevels();
        img.usages();
        img.vkHandle();
    };

    class STORMKIT_API CommandBuffer {
        struct Tag {};

      public:
        enum class State {
            Initial,
            Recording,
            Executable
        };

        static constexpr auto DEBUG_TYPE = DebugObjectType::Command_Buffer;

        using Deleter = std::function<void(vk::raii::CommandBuffer&)>;
        CommandBuffer(CommandBufferLevel, vk::raii::CommandBuffer&&, Deleter, Tag);
        ~CommandBuffer();

        CommandBuffer(const CommandBuffer&)                    = delete;
        auto operator=(const CommandBuffer&) -> CommandBuffer& = delete;

        CommandBuffer(CommandBuffer&&) noexcept;
        auto operator=(CommandBuffer&&) noexcept -> CommandBuffer&;

        [[nodiscard]] static auto create(CommandBufferLevel,
                                         vk::raii::CommandBuffer&&,
                                         Deleter) noexcept -> CommandBuffer;
        [[nodiscard]] static auto allocate(CommandBufferLevel,
                                           vk::raii::CommandBuffer&&,
                                           Deleter) noexcept -> std::unique_ptr<CommandBuffer>;

        auto reset() noexcept -> void;
        auto submit(const Queue&                          queue,
                    std::span<const Ref<const Semaphore>> wait_semaphores   = {},
                    std::span<const PipelineStageFlag>    wait_dst_stages   = {},
                    std::span<const Ref<const Semaphore>> signal_semaphores = {},
                    OptionalRef<const Fence> fence = std::nullopt) const noexcept -> void;

        [[nodiscard]] auto state() const noexcept -> State;
        [[nodiscard]] auto level() const noexcept -> CommandBufferLevel;

        auto beginDebugRegion(std::string_view name,
                              const RGBColorF& color = RGBColorDef::WHITE<float>) -> void;
        auto insertDebugLabel(std::string_view name,
                              const RGBColorF& color = RGBColorDef::WHITE<float>) -> void;
        auto endDebugRegion() -> void;

        auto begin(bool                           one_time_submit  = false,
                   std::optional<InheritanceInfo> inheritance_info = std::nullopt) -> void;
        auto end() -> void;

        auto beginRenderPass(const RenderPass&           render_pass,
                             const FrameBuffer&          framebuffer,
                             std::span<const ClearValue> clear_values = std::array { ClearValue {
                                 ClearColor { .color = RGBColorDef::SILVER<float> } } },
                             bool                        secondary_commandbuffers = false) -> void;
        auto nextSubPass() -> void;
        auto endRenderPass() -> void;

        auto bindPipeline(const Pipeline& pipeline) -> void;
        auto setViewport(UInt32 first_viewport, std::span<const Viewport> viewports) -> void;
        auto setScissor(UInt32 first_scissor, std::span<const Scissor> scissors) -> void;
        auto setLineWidth(float width) -> void;
        auto setDepthBias(float constant_factor, float clamp, float slope_factor) -> void;
        auto setBlendConstants(std::span<const float> constants) -> void;
        auto setDepthBounds(float min, float max) -> void;
        auto setStencilCompareMask(StencilFaceFlag face, UInt32 mask) -> void;
        auto setStencilWriteMask(StencilFaceFlag face, UInt32 mask) -> void;
        auto setStencilReference(StencilFaceFlag face, UInt32 reference) -> void;

        auto dispatch(UInt32 group_count_x, UInt32 group_count_y, UInt32 group_count_z) -> void;

        auto draw(UInt32 vertex_count,
                  UInt32 instance_count = 1u,
                  UInt32 first_vertex   = 0,
                  UInt32 first_instance = 0) -> void;
        auto drawIndexed(UInt32 index_count,
                         UInt32 instance_count = 1u,
                         UInt32 first_index    = 0u,
                         Int32  vertex_offset  = 0,
                         UInt32 first_instance = 0u) -> void;
        auto
            drawIndirect(const Buffer& buffer, RangeExtent offset, UInt32 draw_count, UInt32 stride)
                -> void;
        auto drawIndexedIndirect(const Buffer& buffer,
                                 RangeExtent   offset,
                                 UInt32        draw_count,
                                 UInt32        stride) -> void;

        auto bindVertexBuffers(std::span<Ref<const Buffer>> buffers,
                               std::span<const UInt64>      offsets) -> void;
        auto bindIndexBuffer(const Buffer& buffer, UInt64 offset = 0, bool large_indices = false)
            -> void;
        auto bindDescriptorSets(const Pipeline&                     pipeline,
                                const PipelineLayout&               layout,
                                std::span<Ref<const DescriptorSet>> descriptor_sets,
                                std::span<const UInt32>             dynamic_offsets = {}) -> void;

        auto copyBuffer(const Buffer& src,
                        const Buffer& dst,
                        RangeExtent   size,
                        UInt64        src_offset = 0u,
                        UInt64        dst_offset = 0u) -> void;
        auto copyBufferToImage(const Buffer&                    src,
                               const IsImage auto&              dst,
                               std::span<const BufferImageCopy> buffer_image_copies = {}) -> void;
        auto copyImageToBuffer(const IsImage auto&              src,
                               const Buffer&                    dst,
                               std::span<const BufferImageCopy> buffer_image_copies = {}) -> void;
        auto copyImage(const IsImage auto&           src,
                       const IsImage auto&           dst,
                       ImageLayout                   src_layout,
                       ImageLayout                   dst_layout,
                       const ImageSubresourceLayers& src_subresource_layers,
                       const ImageSubresourceLayers& dst_subresource_layers,
                       const math::ExtentU&          extent) -> void;

        auto resolveImage(const IsImage auto&           src,
                          const IsImage auto&           dst,
                          ImageLayout                   src_layout,
                          ImageLayout                   dst_layout,
                          const ImageSubresourceLayers& src_subresource_layers = {},
                          const ImageSubresourceLayers& dst_subresource_layers = {}) -> void;

        auto blitImage(const IsImage auto&         src,
                       const IsImage auto&         dst,
                       ImageLayout                 src_layout,
                       ImageLayout                 dst_layout,
                       std::span<const BlitRegion> regions,
                       Filter                      filter) -> void;

        auto transitionImageLayout(const IsImage auto&          image,
                                   ImageLayout                  src_layout,
                                   ImageLayout                  dst_layout,
                                   const ImageSubresourceRange& subresource_range = {}) -> void;

        auto executeSubCommandBuffers(std::span<const Ref<const CommandBuffer>> commandbuffers)
            -> void;

        auto pipelineBarrier(PipelineStageFlag                    src_mask,
                             PipelineStageFlag                    dst_mask,
                             DependencyFlag                       dependency,
                             std::span<const MemoryBarrier>       memory_barriers,
                             std::span<const BufferMemoryBarrier> buffer_memory_barriers,
                             std::span<const ImageMemoryBarrier>  image_memory_barriers) -> void;

        auto pushConstants(const PipelineLayout& pipeline_layout,
                           ShaderStageFlag       stage,
                           std::span<const Byte> data,
                           UInt32                offset = 0u) -> void;

        [[nodiscard]] auto vkHandle() const noexcept -> const vk::raii::CommandBuffer&;

      private:
        CommandBufferLevel m_level = CommandBufferLevel::Primary;

        vk::raii::CommandBuffer m_vk_command_buffer;

        Deleter m_deleter;

        State m_state = State::Initial;
    };

    class STORMKIT_API CommandPool {
        struct Tag {};

      public:
        CommandPool(const Device& device, Tag);
        ~CommandPool();

        CommandPool(const CommandPool&)    = delete;
        auto operator=(const CommandPool&) = delete;

        CommandPool(CommandPool&&) noexcept;
        auto operator=(CommandPool&&) noexcept -> CommandPool&;

        [[nodiscard]] static auto create(const Device& device) noexcept -> Expected<CommandPool>;
        [[nodiscard]] static auto allocate(const Device& device) noexcept
            -> Expected<std::unique_ptr<CommandPool>>;

        [[nodiscard]] auto createCommandBuffer(const Device&      device,
                                               CommandBufferLevel level
                                               = CommandBufferLevel::Primary) const noexcept
            -> CommandBuffer;
        [[nodiscard]] auto createCommandBuffers(const Device&      device,
                                                RangeExtent        count,
                                                CommandBufferLevel level
                                                = CommandBufferLevel::Primary) const noexcept
            -> std::vector<CommandBuffer>;

        [[nodiscard]] auto allocateCommandBuffer(const Device&      device,
                                                 CommandBufferLevel level
                                                 = CommandBufferLevel::Primary) const noexcept
            -> std::unique_ptr<CommandBuffer>;
        [[nodiscard]] auto allocateCommandBuffers(const Device&      device,
                                                  RangeExtent        count,
                                                  CommandBufferLevel level
                                                  = CommandBufferLevel::Primary) const noexcept
            -> std::vector<std::unique_ptr<CommandBuffer>>;

        [[nodiscard]] auto vkHandle() const noexcept -> const vk::raii::CommandPool&;

      private:
        auto createVkCommandBuffers(const Device&      device,
                                    RangeExtent        count,
                                    CommandBufferLevel level) const noexcept
            -> std::vector<vk::raii::CommandBuffer>;
        auto deleteVkCommandBuffer(vk::raii::CommandBuffer& cmb) noexcept -> void;

        DeferInit<vk::raii::CommandPool> m_vk_command_pool;

        // std::mutex                           m_reuse_mutex;
        std::vector<vk::raii::CommandBuffer> m_reusable_command_buffers;
    };
} // namespace stormkit::gpu

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit::gpu {
    namespace {
        constexpr auto old_layout_access_map
            = frozen::make_unordered_map<vk::ImageLayout,
                                         std::pair<vk::AccessFlags, vk::PipelineStageFlags>>({
                { vk::ImageLayout::eUndefined,
                 { vk::AccessFlagBits {}, vk::PipelineStageFlagBits::eTopOfPipe }             },
                { vk::ImageLayout::ePreinitialized,
                 { vk::AccessFlagBits {}, vk::PipelineStageFlagBits::eTopOfPipe }             },
                { vk::ImageLayout::eGeneral,
                 { vk::AccessFlagBits::eColorAttachmentWrite
                        | vk::AccessFlagBits::eColorAttachmentRead,
                    vk::PipelineStageFlagBits::eColorAttachmentOutput }                       },
                { vk::ImageLayout::eColorAttachmentOptimal,
                 { vk::AccessFlagBits::eColorAttachmentWrite
                        | vk::AccessFlagBits::eColorAttachmentRead,
                    vk::PipelineStageFlagBits::eColorAttachmentOutput }                       },
                { vk::ImageLayout::eDepthStencilAttachmentOptimal,
                 { vk::AccessFlagBits::eDepthStencilAttachmentRead
                        | vk::AccessFlagBits::eDepthStencilAttachmentWrite,
                    vk::PipelineStageFlagBits::eLateFragmentTests }                           },
                { vk::ImageLayout::eDepthStencilReadOnlyOptimal,
                 { vk::AccessFlagBits::eDepthStencilAttachmentRead,
                    vk::PipelineStageFlagBits::eLateFragmentTests }                           },
                { vk::ImageLayout::eShaderReadOnlyOptimal,
                 { vk::AccessFlagBits::eInputAttachmentRead,
                    vk::PipelineStageFlagBits::eFragmentShader }                              },
                { vk::ImageLayout::eTransferSrcOptimal,
                 { vk::AccessFlagBits::eTransferRead, vk::PipelineStageFlagBits::eTransfer }  },
                { vk::ImageLayout::eTransferDstOptimal,
                 { vk::AccessFlagBits::eTransferWrite, vk::PipelineStageFlagBits::eTransfer } },
                { vk::ImageLayout::ePresentSrcKHR,
                 { vk::AccessFlagBits::eMemoryRead, vk::PipelineStageFlagBits::eTransfer }    }
        });

        constexpr auto new_layout_access_map
            = frozen::make_unordered_map<vk::ImageLayout,
                                         std::pair<vk::AccessFlags, vk::PipelineStageFlags>>({
                { vk::ImageLayout::eUndefined,                     { vk::AccessFlagBits {}, {} } },
                { vk::ImageLayout::ePreinitialized,                { vk::AccessFlagBits {}, {} } },
                { vk::ImageLayout::eGeneral,
                 { vk::AccessFlagBits::eShaderWrite | vk::AccessFlagBits::eShaderRead,
                    vk::PipelineStageFlagBits::eVertexShader }                                   },
                { vk::ImageLayout::eColorAttachmentOptimal,
                 { vk::AccessFlagBits::eColorAttachmentWrite
                        | vk::AccessFlagBits::eColorAttachmentRead,
                    vk::PipelineStageFlagBits::eColorAttachmentOutput }                          },
                { vk::ImageLayout::eDepthStencilAttachmentOptimal,
                 { vk::AccessFlagBits::eDepthStencilAttachmentWrite
                        | vk::AccessFlagBits::eDepthStencilAttachmentRead,
                    vk::PipelineStageFlagBits::eEarlyFragmentTests }                             },
                { vk::ImageLayout::eDepthStencilReadOnlyOptimal,
                 { vk::AccessFlagBits::eShaderRead, vk::PipelineStageFlagBits::eVertexInput }    },
                { vk::ImageLayout::eShaderReadOnlyOptimal,
                 { vk::AccessFlagBits::eShaderRead, vk::PipelineStageFlagBits::eFragmentShader } },
                { vk::ImageLayout::eTransferSrcOptimal,
                 { vk::AccessFlagBits::eTransferRead, vk::PipelineStageFlagBits::eTransfer }     },
                { vk::ImageLayout::eTransferDstOptimal,
                 { vk::AccessFlagBits::eTransferWrite, vk::PipelineStageFlagBits::eTransfer }    },
                { vk::ImageLayout::ePresentSrcKHR,
                 { vk::AccessFlagBits::eMemoryRead, vk::PipelineStageFlagBits::eTransfer }       }
        });
    } // namespace

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE Queue::Queue(const Device& device, const Device::QueueEntry& entry, Tag)
        : m_entry { entry } {
        toRaiiVkHandle(device)
            .getQueue(entry.id, 0)
            .transform(core:.monadic::set(m_vk_queue))
            .transform_error(core:.monadic::map(core:.monadic::narrow<Result>(),
                                                core:.monadic::throw_as_exception()));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE Queue::~Queue() = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE Queue::Queue(Queue&&) noexcept = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto Queue::operator=(Queue&&) noexcept -> Queue& = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto Queue::create(const Device&             device,
                                             const Device::QueueEntry& entry) noexcept
        -> Expected<Queue> try {
        return Queue { device, entry, Tag {} };
    } catch (const Result& result) { return std::unexpected(result); }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto Queue::allocate(const Device&             device,
                                               const Device::QueueEntry& entry) noexcept
        -> Expected<std::unique_ptr<Queue>> try {
        return std::make_unique<Queue>(device, entry, Tag {});
    } catch (const Result& result) { return std::unexpected(result); }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto Queue::waitIdle() const noexcept -> void {
        m_vk_queue->waitIdle();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto Queue::submit(std::span<const SubmitInfo> submit_infos,
                                             OptionalRef<const Fence>    fence) const noexcept
        -> void {
        struct Storage {
            std::vector<vk::Semaphore>          wait_semaphores   = {};
            std::vector<vk::PipelineStageFlags> wait_dst_stages   = {};
            std::vector<vk::CommandBuffer>      command_buffers   = {};
            std::vector<vk::Semaphore>          signal_semaphores = {};
        };

        auto storages = std::vector<Storage> {};
        storages.reserve(std::size(submit_infos));

        // clang-format off
        const auto vk_submit_infos = submit_infos
        | std::views::transform([&storages](auto &&submit_info) noexcept {
           core::expects(std::size(submit_info.wait_semaphores) == std::size(submit_info.wait_dst_stages));

           const auto &storage = storages.emplace_back(Storage {
             .wait_semaphores = submit_info.wait_semaphores 
                  | std::views::transform(monadic::toVkHandle())
                  | std::ranges::to<std::vector>(),
             .wait_dst_stages = submit_info.wait_dst_stages
                  | std::views::transform(monadic::toVkFlags<vk::PipelineStageFlagBits>())
                  | std::ranges::to<std::vector>(),
             .command_buffers = submit_info.command_buffers 
                  | std::views::transform(monadic::toVkHandle())
                  | std::ranges::to<std::vector>(),
             .signal_semaphores = submit_info.signal_semaphores 
                  | std::views::transform(monadic::toVkHandle())
                  | std::ranges::to<std::vector>()
           });

           return vk::SubmitInfo{}
               .setWaitSemaphores(storage.wait_semaphores)
               .setWaitDstStageMask(storage.wait_dst_stages)
               .setCommandBuffers(storage.command_buffers)
               .setSignalSemaphores(storage.signal_semaphores);
        })
        | std::ranges::to<std::vector>();
        // clang-format on

        const auto vk_fence
            = core::either(fence, monadic::toVkHandle(), core:.monadic::init<vk::Fence>(nullptr));

        vkHandle().submit(vk_submit_infos, vk_fence);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto Queue::submit(const SubmitInfo&        submit_info,
                                             OptionalRef<const Fence> fence) const noexcept
        -> void {
        submit({ &submit_info, 1 }, std::move(fence));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    auto Queue::present(std::span<const Ref<const Swapchain>> swapchains,
                        std::span<const Ref<const Semaphore>> wait_semaphores,
                        std::span<const UInt32>               image_indices) const noexcept
        -> Expected<gpu::Result> {
        expects(std::size(wait_semaphores) >= 1);
        expects(std::size(image_indices) >= 1);
        const auto vk_wait_semaphores = wait_semaphores
                                        | std::views::transform(monadic::toVkHandle())
                                        | std::ranges::to<std::vector>();
        const auto vk_swapchains = swapchains
                                   | std::views::transform(monadic::toVkHandle())
                                   | std::ranges::to<std::vector>();
        const auto present_info = vk::PresentInfoKHR {}
                                      .setWaitSemaphores(vk_wait_semaphores)
                                      .setSwapchains(vk_swapchains)
                                      .setImageIndices(image_indices);

        const auto result           = m_vk_queue->presentKHR(present_info);
        const auto possible_results = std::array { vk::Result::eSuccess,
                                                   vk::Result::eErrorOutOfDateKHR,
                                                   vk::Result::eSuboptimalKHR };

        if (not std::ranges::any_of(possible_results, core:.monadic::is(result))) [[likely]]
            return std::unexpected { narrow<Result>(result) };

        return narrow<Result>(result);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto Queue::entry() const noexcept -> const Device::QueueEntry& {
        return m_entry;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto Queue::vkHandle() const noexcept -> const vk::raii::Queue& {
        return m_vk_queue.get();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE CommandBuffer::CommandBuffer(CommandBufferLevel        level,
                                                       vk::raii::CommandBuffer&& command_buffer,
                                                       Deleter                   deleter,
                                                       Tag)
        : m_level { level }, m_vk_command_buffer { std::move(command_buffer) },
          m_deleter { std::move(deleter) } {
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::create(CommandBufferLevel        level,
                                                     vk::raii::CommandBuffer&& cmb,
                                                     Deleter deleter) noexcept -> CommandBuffer {
        return CommandBuffer { level, std::move(cmb), std::move(deleter), Tag {} };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::allocate(CommandBufferLevel        level,
                                                       vk::raii::CommandBuffer&& cmb,
                                                       Deleter                   deleter) noexcept
        -> std::unique_ptr<CommandBuffer> {
        return std::make_unique<CommandBuffer>(level, std::move(cmb), std::move(deleter), Tag {});
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE CommandBuffer::~CommandBuffer() = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE CommandBuffer::CommandBuffer(CommandBuffer&&) noexcept = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::operator=(CommandBuffer&&) noexcept
        -> CommandBuffer& = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::reset() noexcept -> void {
        vkHandle().reset(vk::CommandBufferRESETFlagBits {});
        m_state = State::Initial;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    auto CommandBuffer::submit(const Queue&                          queue,
                               std::span<const Ref<const Semaphore>> wait_semaphores,
                               std::span<const PipelineStageFlag>    wait_dst_stages,
                               std::span<const Ref<const Semaphore>> signal_semaphores,
                               OptionalRef<const Fence>              fence) const noexcept -> void {
        auto cmbs = as_refs<std::array>(*this);

        queue.submit(
            std::array {
                SubmitInfo { .wait_semaphores   = wait_semaphores,
                            .wait_dst_stages   = wait_dst_stages,
                            .command_buffers   = cmbs,
                            .signal_semaphores = signal_semaphores }
        },
            std::move(fence));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::state() const noexcept -> State {
        return m_state;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::level() const noexcept -> CommandBufferLevel {
        return m_level;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::beginDebugRegion(std::string_view name,
                                                               const RGBColorF& color) -> void {
        expects(m_state == State::Recording);

        const auto& dispatcher = m_vk_command_buffer.getDispatcher();
        if (not dispatcher->vkCmdBeginDebugUtilsLabelEXT) [[unlikely]]
            return;

        const auto payload
            = vk::DebugUtilsLabelEXT {}.setPLabelName(std::data(name)).setColor(color);

        m_vk_command_buffer.beginDebugUtilsLabelEXT(payload);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::insertDebugLabel(std::string_view name,
                                                               const RGBColorF& color) -> void {
        expects(m_state == State::Recording);

        const auto& dispatcher = m_vk_command_buffer.getDispatcher();
        if (not dispatcher->vkCmdInsertDebugUtilsLabelEXT) [[unlikely]]
            return;

        const auto payload
            = vk::DebugUtilsLabelEXT {}.setPLabelName(std::data(name)).setColor(color);

        m_vk_command_buffer.insertDebugUtilsLabelEXT(payload);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::endDebugRegion() -> void {
        expects(m_state == State::Recording);

        const auto& dispatcher = m_vk_command_buffer.getDispatcher();
        if (not dispatcher->vkCmdEndDebugUtilsLabelEXT) [[unlikely]]
            return;

        m_vk_command_buffer.endDebugUtilsLabelEXT();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::begin(bool                           one_time_submit,
                                                    std::optional<InheritanceInfo> inheritance_info)
        -> void {
        expects(m_state == State::Initial);

        const auto vk_inheritance_info = either(
            inheritance_info,
            [](auto&& inheritance_info) static noexcept {
                return vk::CommandBufferInheritanceInfo {}
                    .setRenderPass(toVkHandle(inheritance_info.render_pass))
                    .setSubpass(inheritance_info.subpass)
                    .setFramebuffer(toVkHandle(inheritance_info.framebuffer));
            },
            core:.monadic::init<vk::CommandBufferInheritanceInfo>());

        const auto flags = [this, one_time_submit]() {
            auto flags = vk::CommandBufferUsageFlagBits::eOneTimeSubmit;

            if (!one_time_submit) flags = vk::CommandBufferUsageFlagBits::eSimultaneousUse;
            if (m_level == CommandBufferLevel::Secondary)
                return vk::CommandBufferUsageFlagBits::eRenderPassContinue;

            return flags;
        }();

        const auto begin_info = vk::CommandBufferBeginInfo {}.setFlags(flags).setPInheritanceInfo(
            &vk_inheritance_info);

        m_vk_command_buffer.begin(begin_info);

        m_state = State::Recording;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::end() -> void {
        expects(m_state == State::Recording);

        m_vk_command_buffer.end();
        m_state = State::Executable;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        CommandBuffer::beginRenderPass(const RenderPass&           render_pass,
                                       const FrameBuffer&          framebuffer,
                                       std::span<const ClearValue> clear_values,
                                       bool secondary_commandbuffers) -> void {
        expects(m_state == State::Recording);

        const auto vk_clear_values
            = clear_values
              | std::views::transform(core:.monadic::either(
                  [](const ClearColor& color) noexcept -> decltype(auto) {
                      return vk::ClearValue { .color = vk::ClearColorValue {
                                                  .floating_point32
                                                  = color.color.operator std::array<float, 4>() } };
                  },
                  [](const ClearDepthStencil& depth_stencil) noexcept -> decltype(auto) {
                      return vk::ClearValue {
                          .depthStencil
                          = vk::ClearDepthStencilValue { .depth   = depth_stencil.depth,
                                                        .stencil = depth_stencil.stencil }
                      };
                  }))
              | std::ranges::to<std::vector>();

        const auto begin_info
            = vk::RenderPassBeginInfo {}
                  .setRenderPass(toVkHandle(render_pass))
                  .setFramebuffer(toVkHandle(framebuffer))
                  .setRenderArea(vk::Rect2D {}.setOffset({ 0, 0 }).setExtent(
                      { framebuffer.extent().width, framebuffer.extent().height }))
                  .setClearValues(vk_clear_values);

        const auto subpass_content = secondary_commandbuffers
                                         ? vk::SubpassContents::eSecondaryCommandBuffers
                                         : vk::SubpassContents::eInline;

        m_vk_command_buffer.beginRenderPass(begin_info, subpass_content);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::nextSubPass() -> void {
        expects(m_state == State::Recording);

        m_vk_command_buffer.nextSubpass(vk::SubpassContents::eInline);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::endRenderPass() -> void {
        expects(m_state == State::Recording);

        m_vk_command_buffer.endRenderPass();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::bindPipeline(const Pipeline& pipeline) -> void {
        expects(m_state == State::Recording);

        const auto bind_point = (pipeline.type() == Pipeline::Type::Raster)
                                    ? vk::PipelineBindPoint::eGraphics
                                    : vk::PipelineBindPoint::eCompute;

        m_vk_command_buffer.bindPipeline(bind_point, toVkHandle(pipeline));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::setViewport(UInt32                    first_viewport,
                                                          std::span<const Viewport> viewports)
        -> void {
        expects(m_state == State::Recording);

        const auto vk_viewports = viewports
                                  | std::views::transform(core:.monadic::narrow<vk::Viewport>())
                                  | std::ranges::to<std::vector>();

        m_vk_command_buffer.setViewport(first_viewport, vk_viewports);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::setScissor(UInt32                   first_scissor,
                                                         std::span<const Scissor> scissors)
        -> void {
        expects(m_state == State::Recording);

        const auto vk_scissors = scissors
                                 | std::views::transform(core:.monadic::narrow<vk::Rect2D>())
                                 | std::ranges::to<std::vector>();

        m_vk_command_buffer.setScissor(first_scissor, vk_scissors);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::setLineWidth(float width) -> void {
        expects(m_state == State::Recording);

        m_vk_command_buffer.setLineWidth(width);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::setDepthBias(float constant_factor,
                                                           float clamp,
                                                           float slope_factor) -> void {
        expects(m_state == State::Recording);

        m_vk_command_buffer.setDepthBias(constant_factor, clamp, slope_factor);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::setBlendConstants(std::span<const float> constants)
        -> void {
        expects(m_state == State::Recording);

        float data[] = { constants[0], constants[1], constants[2], constants[3] };

        m_vk_command_buffer.setBlendConstants(data);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::setDepthBounds(float min, float max) -> void {
        expects(m_state == State::Recording);

        m_vk_command_buffer.setDepthBounds(min, max);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::setStencilCompareMask(StencilFaceFlag face,
                                                                    UInt32          mask) -> void {
        expects(m_state == State::Recording);

        m_vk_command_buffer.setStencilCompareMask(narrow<vk::StencilFaceFlagBits>(face), mask);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::setStencilWriteMask(StencilFaceFlag face, UInt32 mask)
        -> void {
        expects(m_state == State::Recording);

        m_vk_command_buffer.setStencilWriteMask(narrow<vk::StencilFaceFlagBits>(face), mask);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::setStencilReference(StencilFaceFlag face,
                                                                  UInt32 reference) -> void {
        expects(m_state == State::Recording);

        m_vk_command_buffer.setStencilReference(narrow<vk::StencilFaceFlagBits>(face), reference);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::dispatch(UInt32 group_count_x,
                                                       UInt32 group_count_y,
                                                       UInt32 group_count_z) -> void {
        expects(m_state == State::Recording);

        m_vk_command_buffer.dispatch(group_count_x, group_count_y, group_count_z);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::draw(UInt32 vertex_count,
                                                   UInt32 instance_count,
                                                   UInt32 first_vertex,
                                                   UInt32 first_instance) -> void {
        expects(m_state == State::Recording);
        expects(vertex_count > 0);

        m_vk_command_buffer.draw(vertex_count, instance_count, first_vertex, first_instance);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::drawIndexed(UInt32 index_count,
                                                          UInt32 instance_count,
                                                          UInt32 first_index,
                                                          Int32  vertex_offset,
                                                          UInt32 first_instance) -> void {
        expects(m_state == State::Recording);
        expects(index_count > 0);

        m_vk_command_buffer.drawIndexed(index_count,
                                        instance_count,
                                        first_index,
                                        vertex_offset,
                                        first_instance);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::drawIndirect(const Buffer& buffer,
                                                           RangeExtent   offset,
                                                           UInt32        draw_count,
                                                           UInt32        stride) -> void {
        expects(m_state == State::Recording);
        expects(draw_count > 0);

        m_vk_command_buffer.drawIndirect(toVkHandle(buffer), offset, draw_count, stride);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::drawIndexedIndirect(const Buffer& buffer,
                                                                  RangeExtent   offset,
                                                                  UInt32        draw_count,
                                                                  UInt32        stride) -> void {
        expects(m_state == State::Recording);
        expects(draw_count > 0);

        m_vk_command_buffer.drawIndexedIndirect(toVkHandle(buffer), offset, draw_count, stride);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        CommandBuffer::bindVertexBuffers(std::span<Ref<const Buffer>> buffers,
                                         std::span<const UInt64>      offsets) -> void {
        expects(m_state == State::Recording);
        expects(not std::empty(buffers));
        expects(std::size(buffers) == std::size(offsets));

        const auto vk_buffers = buffers
                                | std::views::transform(monadic::toVkHandle())
                                | std::ranges::to<std::vector>();

        m_vk_command_buffer.bindVertexBuffers(0, vk_buffers, offsets);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::bindIndexBuffer(const Buffer& buffer,
                                                              UInt64        offset,
                                                              bool          large_indices) -> void {
        expects(m_state == State::Recording);

        m_vk_command_buffer.bindIndexBuffer(toVkHandle(buffer),
                                            offset,
                                            (large_indices) ? vk::IndexType::eUint16
                                                            : vk::IndexType::eUint32);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        CommandBuffer::bindDescriptorSets(const Pipeline&                     pipeline,
                                          const PipelineLayout&               layout,
                                          std::span<Ref<const DescriptorSet>> descriptor_sets,
                                          std::span<const UInt32> dynamic_offsets) -> void {
        expects(m_state == State::Recording);

        const auto bind_point = (pipeline.type() == Pipeline::Type::Raster)
                                    ? vk::PipelineBindPoint::eGraphics
                                    : vk::PipelineBindPoint::eCompute;

        const auto vk_descriptor_sets = descriptor_sets
                                        | std::views::transform(monadic::toVkHandle())
                                        | std::ranges::to<std::vector>();

        m_vk_command_buffer.bindDescriptorSets(bind_point,
                                               toVkHandle(layout),
                                               0,
                                               vk_descriptor_sets,
                                               dynamic_offsets);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::copyBuffer(const Buffer& src,
                                                         const Buffer& dst,
                                                         RangeExtent   size,
                                                         UInt64        src_offset,
                                                         UInt64        dst_offset) -> void {
        const auto vk_copy_buffers = std::array {
            vk::BufferCopy { .srcOffset = src_offset, .dstOffset = dst_offset, .size = size }
        };

        m_vk_command_buffer.copyBuffer(toVkHandle(src), toVkHandle(dst), vk_copy_buffers);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        CommandBuffer::copyBufferToImage(const Buffer&                    src,
                                         const IsImage auto&              dst,
                                         std::span<const BufferImageCopy> buffer_image_copies)
            -> void {
        expects(m_state == State::Recording);

        const auto DEFAULT_COPY = std::array {
            BufferImageCopy { 0, 0, 0, {}, { 0, 0, 0 }, dst.extent() }
        };

        if (std::empty(buffer_image_copies)) buffer_image_copies = DEFAULT_COPY;

        const auto vk_copy_regions
            = buffer_image_copies
              | std::views::transform([](auto&& buffer_image_copy) noexcept {
                    const auto image_subresource = vk::ImageSubresourceLayers {
                        .aspectMask = narrow<vk::ImageAspectFlagBits>(
                            buffer_image_copy.subresource_layers.aspect_mask),
                        .mipLevel       = buffer_image_copy.subresource_layers.mip_level,
                        .baseArrayLayer = buffer_image_copy.subresource_layers.base_array_layer,
                        .layerCount     = buffer_image_copy.subresource_layers.layer_count,
                    };

                    return vk::BufferImageCopy {
                        .bufferOffset      = buffer_image_copy.buffer_offset,
                        .bufferRowLength   = buffer_image_copy.buffer_row_length,
                        .bufferImageHeight = buffer_image_copy.buffer_image_height,
                        .imageSubresource  = image_subresource,
                        .imageOffset       = narrow<vk::Offset3D>(buffer_image_copy.offset),
                        .imageExtent       = as<vk::Extent3D>(buffer_image_copy.extent)
                    };
                })
              | std::ranges::to<std::vector>();

        m_vk_command_buffer.copyBufferToImage(toVkHandle(src),
                                              toVkHandle(dst),
                                              vk::ImageLayout::eTransferDstOptimal,
                                              vk_copy_regions);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        CommandBuffer::copyImageToBuffer(const IsImage auto&              src,
                                         const Buffer&                    dst,
                                         std::span<const BufferImageCopy> buffer_image_copies)
            -> void {
        expects(m_state == State::Recording);

        const auto DEFAULT_COPY = std::array {
            BufferImageCopy { 0, 0, 0, {}, { 0, 0, 0 }, src.extent() }
        };

        if (std::empty(buffer_image_copies)) buffer_image_copies = DEFAULT_COPY;

        const auto vk_copy_regions
            = buffer_image_copies
              | std::views::transform([](auto&& buffer_image_copy) noexcept {
                    const auto image_subresource = vk::ImageSubresourceLayers {
                        .aspectMask = narrow<vk::ImageAspectFlagBits>(
                            buffer_image_copy.subresource_layers.aspect_mask),
                        .mipLevel       = buffer_image_copy.subresource_layers.mip_level,
                        .baseArrayLayer = buffer_image_copy.subresource_layers.base_array_layer,
                        .layerCount     = buffer_image_copy.subresource_layers.layer_count,
                    };

                    return vk::BufferImageCopy {
                        .bufferOffset      = buffer_image_copy.buffer_offset,
                        .bufferRowLength   = buffer_image_copy.buffer_row_length,
                        .bufferImageHeight = buffer_image_copy.buffer_image_height,
                        .imageSubresource  = image_subresource,
                        .imageOffset       = narrow<vk::Offset3D>(buffer_image_copy.offset),
                        .imageExtent       = as<vk::Extent3D>(buffer_image_copy.extent)
                    };
                })
              | std::ranges::to<std::vector>();

        m_vk_command_buffer.copyImageToBuffer(toVkHandle(src),
                                              vk::ImageLayout::eTransferDstOptimal,
                                              toVkHandle(dst),
                                              vk_copy_regions);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        CommandBuffer::copyImage(const IsImage auto&           src,
                                 const IsImage auto&           dst,
                                 ImageLayout                   src_layout,
                                 ImageLayout                   dst_layout,
                                 const ImageSubresourceLayers& src_subresource_layers,
                                 const ImageSubresourceLayers& dst_subresource_layers,
                                 const math::ExtentU&          extent) -> void {
        expects(m_state == State::Recording);

        const auto vk_src_subresource_layers = vk::ImageSubresourceLayers {
            .aspectMask     = narrow<vk::ImageAspectFlagBits>(src_subresource_layers.aspect_mask),
            .mipLevel       = src_subresource_layers.mip_level,
            .baseArrayLayer = src_subresource_layers.base_array_layer,
            .layerCount     = src_subresource_layers.layer_count
        };

        const auto vk_dst_subresource_layers = vk::ImageSubresourceLayers {
            .aspectMask     = narrow<vk::ImageAspectFlagBits>(dst_subresource_layers.aspect_mask),
            .mipLevel       = dst_subresource_layers.mip_level,
            .baseArrayLayer = dst_subresource_layers.base_array_layer,
            .layerCount     = dst_subresource_layers.layer_count
        };

        const auto vk_regions = std::array {
            vk::ImageCopy { .srcSubresource = vk_src_subresource_layers,
                           .dstSubresource = vk_dst_subresource_layers,
                           .extent         = as<vk::Extent3D>(extent) }
        };

        m_vk_command_buffer.copyImage(toVkHandle(src),
                                      narrow<vk::ImageLayout>(src_layout),
                                      toVkHandle(dst),
                                      narrow<vk::ImageLayout>(dst_layout),
                                      vk_regions);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        CommandBuffer::resolveImage(const IsImage auto&           src,
                                    const IsImage auto&           dst,
                                    ImageLayout                   src_layout,
                                    ImageLayout                   dst_layout,
                                    const ImageSubresourceLayers& src_subresource_layers,
                                    const ImageSubresourceLayers& dst_subresource_layers) -> void {
        expects(m_state == State::Recording);

        const auto vk_extent = as<vk::Extent3D>(dst.extent());

        const auto vk_src_subresource_layers = vk::ImageSubresourceLayers {
            .aspectMask     = narrow<vk::ImageAspectFlagBits>(src_subresource_layers.aspect_mask),
            .mipLevel       = src_subresource_layers.mip_level,
            .baseArrayLayer = src_subresource_layers.base_array_layer,
            .layerCount     = src_subresource_layers.layer_count
        };

        const auto vk_dst_subresource_layers = vk::ImageSubresourceLayers {
            .aspectMask     = narrow<vk::ImageAspectFlagBits>(dst_subresource_layers.aspect_mask),
            .mipLevel       = dst_subresource_layers.mip_level,
            .baseArrayLayer = dst_subresource_layers.base_array_layer,
            .layerCount     = dst_subresource_layers.layer_count
        };

        const auto vk_regions = std::array {
            vk::ImageResolve { .srcSubresource = vk_src_subresource_layers,
                              .dstSubresource = vk_dst_subresource_layers,
                              .extent         = vk_extent }
        };

        m_vk_command_buffer.resolveImage(toVkHandle(src),
                                         narrow<vk::ImageLayout>(src_layout),
                                         toVkHandle(dst),
                                         narrow<vk::ImageLayout>(dst_layout),
                                         vk_regions);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::blitImage(const IsImage auto&         src,
                                                        const IsImage auto&         dst,
                                                        ImageLayout                 src_layout,
                                                        ImageLayout                 dst_layout,
                                                        std::span<const BlitRegion> regions,
                                                        Filter filter) -> void {
        expects(m_state == State::Recording);

        const auto vk_regions
            = regions
              | std::views::transform([](auto&& region) noexcept {
                    const auto vk_src_subresource_layers = vk::ImageSubresourceLayers {
                        .aspectMask     = narrow<vk::ImageAspectFlagBits>(region.src.aspect_mask),
                        .mipLevel       = region.src.mip_level,
                        .baseArrayLayer = region.src.base_array_layer,
                        .layerCount     = region.src.layer_count
                    };

                    const auto vk_dst_subresource_layers = vk::ImageSubresourceLayers {
                        .aspectMask     = narrow<vk::ImageAspectFlagBits>(region.dst.aspect_mask),
                        .mipLevel       = region.dst.mip_level,
                        .baseArrayLayer = region.dst.base_array_layer,
                        .layerCount     = region.dst.layer_count
                    };

                    return vk::ImageBlit {
                        .srcSubresource = vk_src_subresource_layers,
                        .srcOffsets     = std::array { narrow<vk::Offset3D>(region.src_offset[0]),
                                                      narrow<vk::Offset3D>(region.src_offset[1]) },
                        .dstSubresource = vk_dst_subresource_layers,
                        .dstOffsets     = std::array { narrow<vk::Offset3D>(region.dst_offset[0]),
                                                      narrow<vk::Offset3D>(region.dst_offset[1]) },
                    };
                })
              | std::ranges::to<std::vector>();

        m_vk_command_buffer.blitImage(toVkHandle(src),
                                      narrow<vk::ImageLayout>(src_layout),
                                      toVkHandle(dst),
                                      narrow<vk::ImageLayout>(dst_layout),
                                      vk_regions,
                                      narrow<vk::Filter>(filter));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        CommandBuffer::transitionImageLayout(const IsImage auto&          image,
                                             ImageLayout                  src_layout,
                                             ImageLayout                  dst_layout,
                                             const ImageSubresourceRange& subresource_range)
            -> void {
        expects(m_state == State::Recording);

        const auto vk_src_layout = narrow<vk::ImageLayout>(src_layout);
        const auto vk_dst_layout = narrow<vk::ImageLayout>(dst_layout);

        const auto& src_access = old_layout_access_map.find(vk_src_layout);
        const auto& dst_access = new_layout_access_map.find(vk_dst_layout);

        const auto src_stage = src_access->second.second;
        const auto dst_stage = dst_access->second.second;

        const auto vk_subresource_range = vk::ImageSubresourceRange {
            .aspectMask     = narrow<vk::ImageAspectFlagBits>(subresource_range.aspect_mask),
            .baseMipLevel   = subresource_range.base_mip_level,
            .levelCount     = subresource_range.level_count,
            .baseArrayLayer = subresource_range.base_array_layer,
            .layerCount     = subresource_range.layer_count,
        };

        const auto barriers = std::array {
            vk::ImageMemoryBarrier { .srcAccessMask       = src_access->second.first,
                                    .dstAccessMask       = dst_access->second.first,
                                    .oldLayout           = vk_src_layout,
                                    .newLayout           = vk_dst_layout,
                                    .srcQueueFamilyIndex = vk::QueueFamilyIgnored,
                                    .dstQueueFamilyIndex = vk::QueueFamilyIgnored,
                                    .image               = toVkHandle(image),
                                    .subresourceRange    = vk_subresource_range }
        };

        m_vk_command_buffer.pipelineBarrier(src_stage, dst_stage, {}, {}, {}, barriers);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        CommandBuffer::pipelineBarrier(PipelineStageFlag                    src_mask,
                                       PipelineStageFlag                    dst_mask,
                                       DependencyFlag                       dependency,
                                       std::span<const MemoryBarrier>       memory_barriers,
                                       std::span<const BufferMemoryBarrier> buffer_memory_barriers,
                                       std::span<const ImageMemoryBarrier>  image_memory_barriers)
            -> void {
        const auto vk_memory_barriers
            = memory_barriers
              | std::views::transform([](auto&& barrier) noexcept -> decltype(auto) {
                    return vk::MemoryBarrier {
                        .srcAccessMask = narrow<vk::AccessFlagBits>(barrier.src),
                        .dstAccessMask = narrow<vk::AccessFlagBits>(barrier.dst),
                    };
                })
              | std::ranges::to<std::vector>();

        const auto vk_buffer_memory_barriers
            = buffer_memory_barriers
              | std::views::transform([](auto&& barrier) noexcept -> decltype(auto) {
                    return vk::BufferMemoryBarrier {
                        .srcAccessMask       = narrow<vk::AccessFlagBits>(barrier.src),
                        .dstAccessMask       = narrow<vk::AccessFlagBits>(barrier.dst),
                        .srcQueueFamilyIndex = barrier.src_queue_family_index,
                        .dstQueueFamilyIndex = barrier.dst_queue_family_index,
                        .buffer              = toVkHandle(barrier.buffer),
                        .offset              = barrier.offset,
                        .size                = barrier.size
                    };
                })
              | std::ranges::to<std::vector>();

        const auto vk_image_memory_barriers
            = image_memory_barriers
              | std::views::transform([](auto&& barrier) noexcept -> decltype(auto) {
                    const auto vk_subresource_range = vk::ImageSubresourceRange {
                        .aspectMask   = narrow<vk::ImageAspectFlagBits>(barrier.range.aspect_mask),
                        .baseMipLevel = barrier.range.base_mip_level,
                        .levelCount   = barrier.range.level_count,
                        .baseArrayLayer = barrier.range.base_array_layer,
                        .layerCount     = barrier.range.layer_count
                    };

                    return vk::ImageMemoryBarrier {
                        .srcAccessMask       = narrow<vk::AccessFlagBits>(barrier.src),
                        .dstAccessMask       = narrow<vk::AccessFlagBits>(barrier.dst),
                        .oldLayout           = narrow<vk::ImageLayout>(barrier.old_layout),
                        .newLayout           = narrow<vk::ImageLayout>(barrier.new_layout),
                        .srcQueueFamilyIndex = barrier.src_queue_family_index,
                        .dstQueueFamilyIndex = barrier.dst_queue_family_index,
                        .image               = toVkHandle(barrier.image),
                        .subresourceRange    = vk_subresource_range
                    };
                })
              | std::ranges::to<std::vector>();

        m_vk_command_buffer.pipelineBarrier(narrow<vk::PipelineStageFlagBits>(src_mask),
                                            narrow<vk::PipelineStageFlagBits>(dst_mask),
                                            narrow<vk::DependencyFlagBits>(dependency),
                                            vk_memory_barriers,
                                            vk_buffer_memory_barriers,
                                            vk_image_memory_barriers);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::pushConstants(const PipelineLayout& pipeline_layout,
                                                            ShaderStageFlag       stage,
                                                            std::span<const Byte> data,
                                                            UInt32                offset) -> void {
        expects(m_state == State::Recording);
        expects(not std::empty(data));

        m_vk_command_buffer.pushConstants<const Byte>(toVkHandle(pipeline_layout),
                                                      narrow<vk::ShaderStageFlagBits>(stage),
                                                      offset,
                                                      data);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::executeSubCommandBuffers(
        std::span<const Ref<const CommandBuffer>> commandbuffers) -> void {
        expects(m_state == State::Recording);

        constexpr auto expectsSecondary = [](auto&& cmb) noexcept -> decltype(auto) {
            expects(cmb->level() == CommandBufferLevel::Secondary);
            return cmb;
        };

        const auto vk_command_buffers
            = commandbuffers
              | std::views::transform(core:.monadic::map(expectsSecondary, monadic::toVkHandle()))
              | std::ranges::to<std::vector>();

        m_vk_command_buffer.executeCommands(vk_command_buffers);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandBuffer::vkHandle() const noexcept
        -> const vk::raii::CommandBuffer& {
        return m_vk_command_buffer;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE CommandPool::CommandPool(const Device& device, Tag) {
        device.vkHandle()
            .createCommandPool(vk::CommandPoolCreateInfo {
                .flags = vk::CommandPoolCreateFlagBits::eTransient
                         | vk::CommandPoolCreateFlagBits::eRESETCommandBuffer })
            .transform(core:.monadic::set(m_vk_command_pool))
            .transform_error(core:.monadic::map(core:.monadic::narrow<Result>(),
                                                core:.monadic::throw_as_exception()));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE CommandPool::~CommandPool() = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE CommandPool::CommandPool(CommandPool&&) noexcept = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandPool::operator=(CommandPool&&) noexcept
        -> CommandPool& = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandPool::create(const Device& device) noexcept
        -> Expected<CommandPool> try {
        return CommandPool { device, Tag {} };
    } catch (const Result& result) { return std::unexpected(result); }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandPool::allocate(const Device& device) noexcept
        -> Expected<std::unique_ptr<CommandPool>> try {
        return allocate<CommandPool>(device, Tag {})
            .transform_error(core:.monadic::assert())
            .value();
    } catch (const Result& result) { return std::unexpected(result); }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        CommandPool::createCommandBuffer(const Device&      device,
                                         CommandBufferLevel level) const noexcept -> CommandBuffer {
        return std::move(createCommandBuffers(device, 1, level).front());
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        CommandPool::createCommandBuffers(const Device&      device,
                                          RangeExtent        count,
                                          CommandBufferLevel level) const noexcept
        -> std::vector<CommandBuffer> {
        return createVkCommandBuffers(device, count, level)
               | std::views::as_rvalue
               | std::views::transform(
                   [this, &level](vk::raii::CommandBuffer&& cmb) noexcept -> decltype(auto) {
                       return CommandBuffer::create(level,
                                                    std::move(cmb),
                                                    bindFront(&CommandPool::deleteVkCommandBuffer,
                                                              const_cast<CommandPool*>(this)));
                   })
               | std::ranges::to<std::vector>();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        CommandPool::allocateCommandBuffer(const Device&      device,
                                           CommandBufferLevel level) const noexcept
        -> std::unique_ptr<CommandBuffer> {
        return std::move(allocateCommandBuffers(device, 1, level).front());
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        CommandPool::allocateCommandBuffers(const Device&      device,
                                            RangeExtent        count,
                                            CommandBufferLevel level) const noexcept
        -> std::vector<std::unique_ptr<CommandBuffer>> {
        return createVkCommandBuffers(device, count, level)
               | std::views::as_rvalue
               | std::views::transform(
                   [this, &level](vk::raii::CommandBuffer&& cmb) noexcept -> decltype(auto) {
                       return CommandBuffer::allocate(level,
                                                      std::move(cmb),
                                                      bindFront(&CommandPool::deleteVkCommandBuffer,
                                                                const_cast<CommandPool*>(this)));
                   })
               | std::ranges::to<std::vector>();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto CommandPool::vkHandle() const noexcept
        -> const vk::raii::CommandPool& {
        return m_vk_command_pool;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        CommandPool::deleteVkCommandBuffer([[maybe_unused]] vk::raii::CommandBuffer& cmb) noexcept
        -> void {
        // auto lock = std::unique_lock { m_reuse_mutex };
        // m_reusable_command_buffers.emplace_back(std::move(cmb));
    }
} // namespace stormkit::gpu
