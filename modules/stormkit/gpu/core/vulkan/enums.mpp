/*
    AUTOGENERATED FILE, DO NOT MODIFY
*/

module;

#include <stormkit/core/flags_macro.hpp>
#include <stormkit/core/platform_macro.hpp>

#include <volk.h>

export module stormkit.gpu.core:vulkan.enums;

import std;
import stormkit.core;

import :vulkan.volk;

export {
    namespace stormkit::gpu {
        namespace details {
            template<meta::IsEnumeration>
            inline constexpr auto IS_VULKAN_ENUMERATION = false;
        }

        namespace meta {
            template<typename T>
            concept IsVulkanEnumeration = core::meta::IsEnumeration<T>
                                          and details::IS_VULKAN_ENUMERATION<T>;
        }

        inline constexpr auto QUEUE_FAMILY_IGNORED = std::numeric_limits<u32>::max();

        enum class AccessFlag : u32 {
            COLOR_ATTACHMENT_READ          = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT,
            COLOR_ATTACHMENT_WRITE         = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
            DEPTH_STENCIL_ATTACHMENT_READ  = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT,
            DEPTH_STENCIL_ATTACHMENT_WRITE = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,
            HOST_READ                      = VK_ACCESS_HOST_READ_BIT,
            HOST_WRITE                     = VK_ACCESS_HOST_WRITE_BIT,
            INDIRECT_COMMAND_READ          = VK_ACCESS_INDIRECT_COMMAND_READ_BIT,
            INPUT_ATTACHMENT_READ          = VK_ACCESS_INPUT_ATTACHMENT_READ_BIT,
            MEMORY_READ                    = VK_ACCESS_MEMORY_READ_BIT,
            MEMORY_WRITE                   = VK_ACCESS_MEMORY_WRITE_BIT,
            NONE                           = 0,
            SHADER_READ                    = VK_ACCESS_SHADER_READ_BIT,
            SHADER_WRITE                   = VK_ACCESS_SHADER_WRITE_BIT,
            TRANSFER_READ                  = VK_ACCESS_TRANSFER_READ_BIT,
            TRANSFER_WRITE                 = VK_ACCESS_TRANSFER_WRITE_BIT,
            UNIFORM_READ                   = VK_ACCESS_UNIFORM_READ_BIT,
            VERTEX_ATTRIBUTE_READ          = VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<AccessFlag> = true;

        enum class AttachmentLoadOperation : u8 {
            CLEAR     = VK_ATTACHMENT_LOAD_OP_CLEAR,
            DONT_CARE = VK_ATTACHMENT_LOAD_OP_DONT_CARE,
            LOAD      = VK_ATTACHMENT_LOAD_OP_LOAD,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<AttachmentLoadOperation> = true;

        enum class AttachmentStoreOperation : u8 {
            DONT_CARE = VK_ATTACHMENT_STORE_OP_DONT_CARE,
            STORE     = VK_ATTACHMENT_STORE_OP_STORE,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<AttachmentStoreOperation> = true;

        enum class BlendFactor : u8 {
            CONSTANT_ALPHA           = VK_BLEND_FACTOR_CONSTANT_ALPHA,
            CONSTANT_COLOR           = VK_BLEND_FACTOR_CONSTANT_COLOR,
            DST_ALPHA                = VK_BLEND_FACTOR_DST_ALPHA,
            DST_COLOR                = VK_BLEND_FACTOR_DST_COLOR,
            ONE                      = VK_BLEND_FACTOR_ONE,
            ONE_MINUS_CONSTANT_ALPHA = VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA,
            ONE_MINUS_CONSTANT_COLOR = VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR,
            ONE_MINUS_DST_ALPHA      = VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA,
            ONE_MINUS_DST_COLOR      = VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR,
            ONE_MINUS_SRC1_ALPHA     = VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA,
            ONE_MINUS_SRC1_COLOR     = VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR,
            ONE_MINUS_SRC_ALPHA      = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
            ONE_MINUS_SRC_COLOR      = VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR,
            SRC1_ALPHA               = VK_BLEND_FACTOR_SRC1_ALPHA,
            SRC1_COLOR               = VK_BLEND_FACTOR_SRC1_COLOR,
            SRC_ALPHA                = VK_BLEND_FACTOR_SRC_ALPHA,
            SRC_ALPHA_SATURATE       = VK_BLEND_FACTOR_SRC_ALPHA_SATURATE,
            SRC_COLOR                = VK_BLEND_FACTOR_SRC_COLOR,
            ZERO                     = VK_BLEND_FACTOR_ZERO,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<BlendFactor> = true;

        enum class BlendOperation : u8 {
            ADD              = VK_BLEND_OP_ADD,
            MAX              = VK_BLEND_OP_MAX,
            MIN              = VK_BLEND_OP_MIN,
            REVERSE_SUBTRACT = VK_BLEND_OP_REVERSE_SUBTRACT,
            SUBTRACT         = VK_BLEND_OP_SUBTRACT,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<BlendOperation> = true;

        enum class BorderColor : u8 {
            FLOAT_OPAQUE_BLACK      = VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK,
            FLOAT_OPAQUE_WHITE      = VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE,
            FLOAT_TRANSPARENT_BLACK = VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK,
            INT_OPAQUE_BLACK        = VK_BORDER_COLOR_INT_OPAQUE_BLACK,
            INT_OPAQUE_WHITE        = VK_BORDER_COLOR_INT_OPAQUE_WHITE,
            INT_TRANSPARENT_BLACK   = VK_BORDER_COLOR_INT_TRANSPARENT_BLACK,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<BorderColor> = true;

        enum class BufferUsageFlag : u16 {
            INDEX         = VK_BUFFER_USAGE_INDEX_BUFFER_BIT,
            INDIRECT      = VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT,
            STORAGE       = VK_BUFFER_USAGE_STORAGE_BUFFER_BIT,
            STORAGE_TEXEL = VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT,
            TRANSFER_DST  = VK_BUFFER_USAGE_TRANSFER_DST_BIT,
            TRANSFER_SRC  = VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
            UNIFORM       = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,
            UNIFORM_TEXEL = VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT,
            VERTEX        = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<BufferUsageFlag> = true;

        enum class ColorComponentFlag : u8 {
            A    = VK_COLOR_COMPONENT_A_BIT,
            B    = VK_COLOR_COMPONENT_B_BIT,
            G    = VK_COLOR_COMPONENT_G_BIT,
            NONE = 0,
            R    = VK_COLOR_COMPONENT_R_BIT,
            RG   = R | G,
            RGB  = RG | B,
            RGBA = RGB | A,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<ColorComponentFlag> = true;

        enum class ColorSpace : u32 {
            ADOBERGB_LINEAR         = VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT,
            ADOBERGB_NONLINEAR      = VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT,
            BT2020_LINEAR           = VK_COLOR_SPACE_BT2020_LINEAR_EXT,
            BT709_LINEAR            = VK_COLOR_SPACE_BT709_LINEAR_EXT,
            BT709_NONLINEAR         = VK_COLOR_SPACE_BT709_NONLINEAR_EXT,
            DCI_P3_NONLINEAR        = VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT,
            DISPLAY_NATIVE_AMD      = VK_COLOR_SPACE_DISPLAY_NATIVE_AMD,
            DISPLAY_P3_LINEAR       = VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT,
            DISPLAY_P3_NONLINEAR    = VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT,
            DOLBYVISION             = VK_COLOR_SPACE_DOLBYVISION_EXT,
            EXTENDED_SRGB_LINEAR    = VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT,
            EXTENDED_SRGB_NONLINEAR = VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT,
            HDR10_HLG               = VK_COLOR_SPACE_HDR10_HLG_EXT,
            HDR10_ST2084            = VK_COLOR_SPACE_HDR10_ST2084_EXT,
            PASS_THROUGH            = VK_COLOR_SPACE_PASS_THROUGH_EXT,
            SRGB_NONLINEAR          = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<ColorSpace> = true;

        enum class CommandBufferLevel : u8 {
            PRIMARY   = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
            SECONDARY = VK_COMMAND_BUFFER_LEVEL_SECONDARY,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<CommandBufferLevel> = true;

        enum class CompareOperation : u8 {
            ALWAYS           = VK_COMPARE_OP_ALWAYS,
            EQUAL            = VK_COMPARE_OP_EQUAL,
            GREATER          = VK_COMPARE_OP_GREATER,
            GREATER_OR_EQUAL = VK_COMPARE_OP_GREATER_OR_EQUAL,
            LESS             = VK_COMPARE_OP_LESS,
            LESS_OR_EQUAL    = VK_COMPARE_OP_LESS_OR_EQUAL,
            NEVER            = VK_COMPARE_OP_NEVER,
            NOT_EQUAL        = VK_COMPARE_OP_NOT_EQUAL,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<CompareOperation> = true;

        enum class CullModeFlag : u8 {
            BACK       = VK_CULL_MODE_BACK_BIT,
            FRONT      = VK_CULL_MODE_FRONT_BIT,
            FRONT_BACK = FRONT | BACK,
            NONE       = 0,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<CullModeFlag> = true;

        enum class DebugObjectType : u32 {
            BUFFER                = VK_OBJECT_TYPE_BUFFER,
            BUFFER_VIEW           = VK_OBJECT_TYPE_BUFFER_VIEW,
            COMMAND_BUFFER        = VK_OBJECT_TYPE_COMMAND_BUFFER,
            COMMAND_POOL          = VK_OBJECT_TYPE_COMMAND_POOL,
            DEBUG_REPORT_CALLBACK = VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT,
            DESCRIPTOR_POOL       = VK_OBJECT_TYPE_DESCRIPTOR_POOL,
            DESCRIPTOR_SET        = VK_OBJECT_TYPE_DESCRIPTOR_SET,
            DESCRIPTOR_SET_LAYOUT = VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT,
            DEVICE                = VK_OBJECT_TYPE_DEVICE,
            DEVICE_MEMORY         = VK_OBJECT_TYPE_DEVICE_MEMORY,
            DISPLAY               = VK_OBJECT_TYPE_DISPLAY_KHR,
            EVENT                 = VK_OBJECT_TYPE_EVENT,
            FENCE                 = VK_OBJECT_TYPE_FENCE,
            FRAMEBUFFER           = VK_OBJECT_TYPE_FRAMEBUFFER,
            IMAGE                 = VK_OBJECT_TYPE_IMAGE,
            IMAGE_VIEW            = VK_OBJECT_TYPE_IMAGE_VIEW,
            INSTANCE              = VK_OBJECT_TYPE_INSTANCE,
            PHYSICAL_DEVICE       = VK_OBJECT_TYPE_PHYSICAL_DEVICE,
            PIPELINE              = VK_OBJECT_TYPE_PIPELINE,
            PIPELINE_CACHE        = VK_OBJECT_TYPE_PIPELINE_CACHE,
            PIPELINE_LAYOUT       = VK_OBJECT_TYPE_PIPELINE_LAYOUT,
            QUERY_POOL            = VK_OBJECT_TYPE_QUERY_POOL,
            QUEUE                 = VK_OBJECT_TYPE_QUEUE,
            RENDER_PASS           = VK_OBJECT_TYPE_RENDER_PASS,
            SAMPLER               = VK_OBJECT_TYPE_SAMPLER,
            SEMAPHORE             = VK_OBJECT_TYPE_SEMAPHORE,
            SHADER_MODULE         = VK_OBJECT_TYPE_SHADER_MODULE,
            SURFACE               = VK_OBJECT_TYPE_SURFACE_KHR,
            SWAPCHAIN             = VK_OBJECT_TYPE_SWAPCHAIN_KHR,
            UNKNOWN               = VK_OBJECT_TYPE_UNKNOWN,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<DebugObjectType> = true;

        enum class DependencyFlag : u8 {
            BY_REGION    = VK_DEPENDENCY_BY_REGION_BIT,
            DEVICE_GROUP = VK_DEPENDENCY_DEVICE_GROUP_BIT,
            NONE         = 0,
            VIEW_LOCAL   = VK_DEPENDENCY_VIEW_LOCAL_BIT,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<DependencyFlag> = true;

        enum class DescriptorType : u8 {
            COMBINED_IMAGE_SAMPLER = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
            INPUT_ATTACHMENT       = VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,
            SAMPLED_IMAGE          = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
            SAMPLER                = VK_DESCRIPTOR_TYPE_SAMPLER,
            STORAGE_BUFFER         = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
            STORAGE_BUFFER_DYNAMIC = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC,
            STORAGE_IMAGE          = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
            STORAGE_TEXEL_BUFFER   = VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER,
            UNIFORM_BUFFER         = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
            UNIFORM_BUFFER_DYNAMIC = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
            UNIFORM_TEXEL_BUFFER   = VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<DescriptorType> = true;

        enum class DynamicState : u8 {
            BLEND_CONSTANTS      = VK_DYNAMIC_STATE_BLEND_CONSTANTS,
            DEPTH_BIAS           = VK_DYNAMIC_STATE_DEPTH_BIAS,
            DEPTH_BOUNDS         = VK_DYNAMIC_STATE_DEPTH_BOUNDS,
            LINE_WIDTH           = VK_DYNAMIC_STATE_LINE_WIDTH,
            SCISSOR              = VK_DYNAMIC_STATE_SCISSOR,
            STENCIL_COMPARE_MASK = VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK,
            STENCIL_REFERENCE    = VK_DYNAMIC_STATE_STENCIL_REFERENCE,
            STENCIL_WRITE_MASK   = VK_DYNAMIC_STATE_STENCIL_WRITE_MASK,
            VIEWPORT             = VK_DYNAMIC_STATE_VIEWPORT,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<DynamicState> = true;

        enum class Filter : u32 {
            CUBIC_IMG = VK_FILTER_CUBIC_IMG,
            LINEAR    = VK_FILTER_LINEAR,
            NEAREST   = VK_FILTER_NEAREST,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<Filter> = true;

        enum class FormatFeatureFlag : u32 {
            BLIT_DST                    = VK_FORMAT_FEATURE_BLIT_DST_BIT,
            BLIT_SRC                    = VK_FORMAT_FEATURE_BLIT_SRC_BIT,
            COLOR_ATTACHMENT            = VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT,
            COLOR_ATTACHMENT_BLEND      = VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT,
            COSITED_CHROMA_SAMPLES      = VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
            DEPTH_STENCIL_ATTACHMENT    = VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT,
            DISJOINT                    = VK_FORMAT_FEATURE_DISJOINT_BIT,
            MIDPOINT_CHROMA_SAMPLES     = VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT,
            SAMPLED_IMAGE               = VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
            SAMPLED_IMAGE_FILTER_LINEAR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT,
            SAMPLED_IMAGE_FILTER_MINMAX = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT,
            SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT
              = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT,
            SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE
              = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT,
            SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER
              = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT,
            SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER
              = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT,
            STORAGE_IMAGE               = VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT,
            STORAGE_IMAGE_ATOMIC        = VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT,
            STORAGE_TEXEL_BUFFER        = VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT,
            STORAGE_TEXEL_BUFFER_ATOMIC = VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT,
            TRANSFER_DST                = VK_FORMAT_FEATURE_TRANSFER_DST_BIT,
            TRANSFER_SRC                = VK_FORMAT_FEATURE_TRANSFER_SRC_BIT,
            UNIFORM_TEXEL_BUFFER        = VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT,
            VERTEX_BUFFER               = VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<FormatFeatureFlag> = true;

        enum class FrontFace : u8 {
            CLOCKWISE         = VK_FRONT_FACE_CLOCKWISE,
            COUNTER_CLOCKWISE = VK_FRONT_FACE_COUNTER_CLOCKWISE,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<FrontFace> = true;

        enum class GeometryFlag : u8 {
            NO_DUPLICATE_ANY_HIT_INVOCATION = VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR,
            OPAQUE                          = VK_GEOMETRY_OPAQUE_BIT_KHR,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<GeometryFlag> = true;

        enum class GeometryType : u8 {
            AABBS     = VK_GEOMETRY_TYPE_AABBS_KHR,
            INSTANCES = VK_GEOMETRY_TYPE_INSTANCES_KHR,
            TRIANGLES = VK_GEOMETRY_TYPE_TRIANGLES_KHR,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<GeometryType> = true;

        enum class ImageAspectFlag : u8 {
            COLOR   = VK_IMAGE_ASPECT_COLOR_BIT,
            DEPTH   = VK_IMAGE_ASPECT_DEPTH_BIT,
            NONE    = VK_IMAGE_ASPECT_NONE_KHR,
            STENCIL = VK_IMAGE_ASPECT_STENCIL_BIT,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<ImageAspectFlag> = true;

        enum class ImageCreateFlag : u16 {
            ALIAS                       = VK_IMAGE_CREATE_ALIAS_BIT,
            ARRAY_2D_COMPATIBLE         = VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT,
            BLOCK_TEXEL_VIEW_COMPATIBLE = VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT,
            CUBE_COMPATIBLE             = VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT,
            DISJOINT                    = VK_IMAGE_CREATE_DISJOINT_BIT,
            EXTENDED_USAGE              = VK_IMAGE_CREATE_EXTENDED_USAGE_BIT,
            MUTABLE_FORMAT              = VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT,
            NONE                        = 0,
            PROTECTED                   = VK_IMAGE_CREATE_PROTECTED_BIT,
            SPARSE_ALIASED              = VK_IMAGE_CREATE_SPARSE_ALIASED_BIT,
            SPARSE_BINDING              = VK_IMAGE_CREATE_SPARSE_BINDING_BIT,
            SPARSE_RESIDENCY            = VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT,
            SPLIT_INSTANCE_BIND_REGIONS = VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<ImageCreateFlag> = true;

        enum class ImageLayout : u32 {
            COLOR_ATTACHMENT_OPTIMAL = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
            DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL
              = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL,
            DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL
              = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL,
            DEPTH_STENCIL_ATTACHMENT_OPTIMAL = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
            DEPTH_STENCIL_READ_ONLY_OPTIMAL  = VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL,
            GENERAL                          = VK_IMAGE_LAYOUT_GENERAL,
            PREINITIALIZED                   = VK_IMAGE_LAYOUT_PREINITIALIZED,
            PRESENT_SRC                      = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,
            SHADER_READ_ONLY_OPTIMAL         = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
            SHARED_PRESENT                   = VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR,
            TRANSFER_DST_OPTIMAL             = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
            TRANSFER_SRC_OPTIMAL             = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
            UNDEFINED                        = VK_IMAGE_LAYOUT_UNDEFINED,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<ImageLayout> = true;

        enum class ImageTiling : u8 {
            LINEAR  = VK_IMAGE_TILING_LINEAR,
            OPTIMAL = VK_IMAGE_TILING_OPTIMAL,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<ImageTiling> = true;

        enum class ImageType : u8 {
            T1D = VK_IMAGE_TYPE_1D,
            T2D = VK_IMAGE_TYPE_2D,
            T3D = VK_IMAGE_TYPE_3D,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<ImageType> = true;

        enum class ImageUsageFlag : u16 {
            COLOR_ATTACHMENT         = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
            DEPTH_STENCIL_ATTACHMENT = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,
            INPUT_ATTACHMENT         = VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT,
            SAMPLED                  = VK_IMAGE_USAGE_SAMPLED_BIT,
            STORAGE                  = VK_IMAGE_USAGE_STORAGE_BIT,
            TRANSFER_DST             = VK_IMAGE_USAGE_TRANSFER_DST_BIT,
            TRANSFER_SRC             = VK_IMAGE_USAGE_TRANSFER_SRC_BIT,
            TRANSIENT_ATTACHMENT     = VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<ImageUsageFlag> = true;

        enum class ImageViewType : u8 {
            CUBE       = VK_IMAGE_VIEW_TYPE_CUBE,
            CUBE_ARRAY = VK_IMAGE_VIEW_TYPE_CUBE_ARRAY,
            T1D        = VK_IMAGE_VIEW_TYPE_1D,
            T1D_ARRAY  = VK_IMAGE_VIEW_TYPE_1D_ARRAY,
            T2D        = VK_IMAGE_VIEW_TYPE_2D,
            T2D_ARRAY  = VK_IMAGE_VIEW_TYPE_2D_ARRAY,
            T3D        = VK_IMAGE_VIEW_TYPE_3D,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<ImageViewType> = true;

        enum class LogicOperation : u8 {
            AND           = VK_LOGIC_OP_AND,
            AND_INVERTED  = VK_LOGIC_OP_AND_INVERTED,
            AND_REVERSE   = VK_LOGIC_OP_AND_REVERSE,
            CLEAR         = VK_LOGIC_OP_CLEAR,
            COPY          = VK_LOGIC_OP_COPY,
            COPY_INVERTED = VK_LOGIC_OP_COPY_INVERTED,
            EQUIVALENT    = VK_LOGIC_OP_EQUIVALENT,
            INVERT        = VK_LOGIC_OP_INVERT,
            NAND          = VK_LOGIC_OP_NAND,
            NO_OP         = VK_LOGIC_OP_NO_OP,
            NOR           = VK_LOGIC_OP_NOR,
            OR            = VK_LOGIC_OP_OR,
            OR_INVERTED   = VK_LOGIC_OP_OR_INVERTED,
            OR_REVERSE    = VK_LOGIC_OP_OR_REVERSE,
            SET           = VK_LOGIC_OP_SET,
            XOR           = VK_LOGIC_OP_XOR,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<LogicOperation> = true;

        enum class MemoryPropertyFlag : u8 {
            DEVICE_LOCAL  = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
            HOST_CACHED   = VK_MEMORY_PROPERTY_HOST_CACHED_BIT,
            HOST_COHERENT = VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
            HOST_VISIBLE  = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<MemoryPropertyFlag> = true;

        enum class PhysicalDeviceType : u8 {
            CPU            = VK_PHYSICAL_DEVICE_TYPE_CPU,
            DISCRETE_GPU   = VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU,
            INTEGRATED_GPU = VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU,
            OTHER          = VK_PHYSICAL_DEVICE_TYPE_OTHER,
            VIRTUAL_GPU    = VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<PhysicalDeviceType> = true;

        enum class PipelineBindPoint : u8 {
            COMPUTE  = VK_PIPELINE_BIND_POINT_COMPUTE,
            GRAPHICS = VK_PIPELINE_BIND_POINT_GRAPHICS,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<PipelineBindPoint> = true;

        enum class PipelineStageFlag : u32 {
            ALL_COMMANDS                   = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,
            ALL_GRAPHICS                   = VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT,
            BOTTOM_OF_PIPE                 = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
            COLOR_ATTACHMENT_OUTPUT        = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
            COMPUTE_SHADER                 = VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
            DRAW_INDIRECT                  = VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
            EARLY_FRAGMENT_TESTS           = VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
            FRAGMENT_SHADER                = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
            GEOMETRY_SHADER                = VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT,
            HOST                           = VK_PIPELINE_STAGE_HOST_BIT,
            LATE_FRAGMENT_TESTS            = VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT,
            TESSELLATION_CONTROL_SHADER    = VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT,
            TESSELLATION_EVALUATION_SHADER = VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT,
            TOP_OF_PIPE                    = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
            TRANSFER                       = VK_PIPELINE_STAGE_TRANSFER_BIT,
            VERTEX_INPUT                   = VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,
            VERTEX_SHADER                  = VK_PIPELINE_STAGE_VERTEX_SHADER_BIT,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<PipelineStageFlag> = true;

        enum class PixelFormat : u32 {
            A1_RGB5_UNORM_PACK16    = VK_FORMAT_A1R5G5B5_UNORM_PACK16,
            A2_RGB10I_PACK32        = VK_FORMAT_A2R10G10B10_SINT_PACK32,
            A2_RGB10_SNORM_PACK32   = VK_FORMAT_A2R10G10B10_SNORM_PACK32,
            A2_RGB10_UNORM_PACK32   = VK_FORMAT_A2R10G10B10_UNORM_PACK32,
            A2_RGB10U_PACK32        = VK_FORMAT_A2R10G10B10_UINT_PACK32,
            B10_GR11UF_PACK32       = VK_FORMAT_B10G11R11_UFLOAT_PACK32,
            BGR8_UNORM              = VK_FORMAT_B8G8R8_UNORM,
            BGRA8_UNORM             = VK_FORMAT_B8G8R8A8_UNORM,
            DEPTH16_UNORM           = VK_FORMAT_D16_UNORM,
            DEPTH16_UNORM_STENCIL8U = VK_FORMAT_D16_UNORM_S8_UINT,
            DEPTH24_UNORM_PACK32    = VK_FORMAT_X8_D24_UNORM_PACK32,
            DEPTH24_UNORM_STENCIL8U = VK_FORMAT_D24_UNORM_S8_UINT,
            DEPTH32F                = VK_FORMAT_D32_SFLOAT,
            DEPTH32F_STENCIL8U      = VK_FORMAT_D32_SFLOAT_S8_UINT,
            R16F                    = VK_FORMAT_R16_SFLOAT,
            R16I                    = VK_FORMAT_R16_SINT,
            R16_SNORM               = VK_FORMAT_R16_SNORM,
            R16U                    = VK_FORMAT_R16_UINT,
            R16_UNORM               = VK_FORMAT_R16_UNORM,
            R32F                    = VK_FORMAT_R32_SFLOAT,
            R32I                    = VK_FORMAT_R32_SINT,
            R32U                    = VK_FORMAT_R32_UINT,
            R5_G6_B5_UNORM_PACK16   = VK_FORMAT_R5G6B5_UNORM_PACK16,
            R8I                     = VK_FORMAT_R8_SINT,
            R8_SNORM                = VK_FORMAT_R8_SNORM,
            R8U                     = VK_FORMAT_R8_UINT,
            R8_UNORM                = VK_FORMAT_R8_UNORM,
            RG16F                   = VK_FORMAT_R16G16_SFLOAT,
            RG16I                   = VK_FORMAT_R16G16_SINT,
            RG16_SNORM              = VK_FORMAT_R16G16_SNORM,
            RG16U                   = VK_FORMAT_R16G16_UINT,
            RG16_UNORM              = VK_FORMAT_R16G16_UNORM,
            RG32F                   = VK_FORMAT_R32G32_SFLOAT,
            RG32I                   = VK_FORMAT_R32G32_SINT,
            RG32U                   = VK_FORMAT_R32G32_UINT,
            RG8I                    = VK_FORMAT_R8G8_SINT,
            RG8_SNORM               = VK_FORMAT_R8G8_SNORM,
            RG8U                    = VK_FORMAT_R8G8_UINT,
            RG8_UNORM               = VK_FORMAT_R8G8_UNORM,
            RGB16F                  = VK_FORMAT_R16G16B16_SFLOAT,
            RGB16I                  = VK_FORMAT_R16G16B16_SINT,
            RGB16_SNORM             = VK_FORMAT_R16G16B16_SNORM,
            RGB16U                  = VK_FORMAT_R16G16B16_UINT,
            RGB16_UNORM             = VK_FORMAT_R16G16B16_UNORM,
            RGB32F                  = VK_FORMAT_R32G32B32_SFLOAT,
            RGB32I                  = VK_FORMAT_R32G32B32_SINT,
            RGB32U                  = VK_FORMAT_R32G32B32_UINT,
            RGB8I                   = VK_FORMAT_R8G8B8_SINT,
            RGB8_SNORM              = VK_FORMAT_R8G8B8_SNORM,
            RGB8U                   = VK_FORMAT_R8G8B8_UINT,
            RGB8_UNORM              = VK_FORMAT_R8G8B8_UNORM,
            RGBA16F                 = VK_FORMAT_R16G16B16A16_SFLOAT,
            RGBA16I                 = VK_FORMAT_R16G16B16A16_SINT,
            RGBA16_SNORM            = VK_FORMAT_R16G16B16A16_SNORM,
            RGBA16U                 = VK_FORMAT_R16G16B16A16_UINT,
            RGBA16_UNORM            = VK_FORMAT_R16G16B16A16_UNORM,
            RGBA32F                 = VK_FORMAT_R32G32B32A32_SFLOAT,
            RGBA32I                 = VK_FORMAT_R32G32B32A32_SINT,
            RGBA32U                 = VK_FORMAT_R32G32B32A32_UINT,
            RGBA4_UNORM_PACK16      = VK_FORMAT_R4G4B4A4_UNORM_PACK16,
            RGBA8I                  = VK_FORMAT_R8G8B8A8_SINT,
            RGBA8_SNORM             = VK_FORMAT_R8G8B8A8_SNORM,
            RGBA8U                  = VK_FORMAT_R8G8B8A8_UINT,
            RGBA8_UNORM             = VK_FORMAT_R8G8B8A8_UNORM,
            SBGR8                   = VK_FORMAT_B8G8R8_SRGB,
            SBGRA8                  = VK_FORMAT_B8G8R8A8_SRGB,
            SR8                     = VK_FORMAT_R8_SRGB,
            SRG8                    = VK_FORMAT_R8G8_SRGB,
            SRGB8                   = VK_FORMAT_R8G8B8_SRGB,
            SRGBA8                  = VK_FORMAT_R8G8B8A8_SRGB,
            UNDEFINED               = VK_FORMAT_UNDEFINED,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<PixelFormat> = true;

        enum class PolygonMode : u8 {
            FILL  = VK_POLYGON_MODE_FILL,
            LINE  = VK_POLYGON_MODE_LINE,
            POINT = VK_POLYGON_MODE_POINT,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<PolygonMode> = true;

        enum class PresentMode : u32 {
            FIFO                      = VK_PRESENT_MODE_FIFO_KHR,
            FIFO_RELAXED              = VK_PRESENT_MODE_FIFO_RELAXED_KHR,
            IMMEDIATE                 = VK_PRESENT_MODE_IMMEDIATE_KHR,
            MAILBOX                   = VK_PRESENT_MODE_MAILBOX_KHR,
            SHARED_CONTINUOUS_REFRESH = VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR,
            SHARED_DEMAND_REFRESH     = VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<PresentMode> = true;

        enum class PrimitiveTopology : u8 {
            LINE_LIST      = VK_PRIMITIVE_TOPOLOGY_LINE_LIST,
            LINE_STRIP     = VK_PRIMITIVE_TOPOLOGY_LINE_STRIP,
            POINT_LIST     = VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
            TRIANGLE_FAN   = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN,
            TRIANGLE_LIST  = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
            TRIANGLE_STRIP = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<PrimitiveTopology> = true;

        enum class QueueFlag : u8 {
            COMPUTE        = VK_QUEUE_COMPUTE_BIT,
            GRAPHICS       = VK_QUEUE_GRAPHICS_BIT,
            NONE           = 0,
            PROTECTED      = VK_QUEUE_PROTECTED_BIT,
            SPARSE_BINDING = VK_QUEUE_SPARSE_BINDING_BIT,
            TRANSFER       = VK_QUEUE_TRANSFER_BIT,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<QueueFlag> = true;

        enum class Result : i32 {
            ERROR_DEVICE_LOST                    = VK_ERROR_DEVICE_LOST,
            ERROR_EXTENSION_NOT_PRESENT          = VK_ERROR_EXTENSION_NOT_PRESENT,
            ERROR_FEATURE_NOT_PRESENT            = VK_ERROR_FEATURE_NOT_PRESENT,
            ERROR_FORMAT_NOT_SUPPORTED           = VK_ERROR_FORMAT_NOT_SUPPORTED,
            ERROR_FRAGMENTATION                  = VK_ERROR_FRAGMENTATION,
            ERROR_FRAGMENTED_POOL                = VK_ERROR_FRAGMENTED_POOL,
            ERROR_FULLSCREEN_EXCLUSIVE_MODE_LOST = VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,
            ERROR_INCOMPATIBLE_DISPLAY           = VK_ERROR_INCOMPATIBLE_DISPLAY_KHR,
            ERROR_INCOMPATIBLE_DRIVER            = VK_ERROR_INCOMPATIBLE_DRIVER,
            ERROR_INITIALIZATION_FAILED          = VK_ERROR_INITIALIZATION_FAILED,
            ERROR_INVALID_EXTERNAL_HANDLE        = VK_ERROR_INVALID_EXTERNAL_HANDLE,
            ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS = VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS,
            ERROR_LAYER_NOT_PRESENT              = VK_ERROR_LAYER_NOT_PRESENT,
            ERROR_MEMORY_MAP_FAILED              = VK_ERROR_MEMORY_MAP_FAILED,
            ERROR_NATIVE_WINDOW_IN_USE           = VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,
            ERROR_NOT_PERMITTED                  = VK_ERROR_NOT_PERMITTED,
            ERROR_OUT_OF_DATE                    = VK_ERROR_OUT_OF_DATE_KHR,
            ERROR_OUT_OF_DEVICE_MEMORY           = VK_ERROR_OUT_OF_DEVICE_MEMORY,
            ERROR_OUT_OF_HOST_MEMORY             = VK_ERROR_OUT_OF_HOST_MEMORY,
            ERROR_OUT_OF_POOL_MEMORY             = VK_ERROR_OUT_OF_POOL_MEMORY,
            ERROR_SURFACE_LOST                   = VK_ERROR_SURFACE_LOST_KHR,
            ERROR_TOO_MANY_OBJECTS               = VK_ERROR_TOO_MANY_OBJECTS,
            ERROR_UNKNOWN                        = VK_ERROR_UNKNOWN,
            ERROR_VALIDATION_FAILED              = VK_ERROR_VALIDATION_FAILED_EXT,
            EVENT_RESET                          = VK_EVENT_RESET,
            EVENT_SET                            = VK_EVENT_SET,
            INCOMPLETE                           = VK_INCOMPLETE,
            NOT_READY                            = VK_NOT_READY,
            OPERATION_DEFERRED                   = VK_OPERATION_DEFERRED_KHR,
            OPERATION_NOT_DEFERRED               = VK_OPERATION_NOT_DEFERRED_KHR,
            PIPELINE_COMPILE_REQUIRED            = VK_PIPELINE_COMPILE_REQUIRED,
            SUBOPTIMAL                           = VK_SUBOPTIMAL_KHR,
            SUCCESS                              = VK_SUCCESS,
            THREAD_DONE                          = VK_THREAD_DONE_KHR,
            THREAD_IDLE                          = VK_THREAD_IDLE_KHR,
            TIMEOUT                              = VK_TIMEOUT,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<Result> = true;

        enum class SampleCountFlag : u8 {
            C1  = VK_SAMPLE_COUNT_1_BIT,
            C16 = VK_SAMPLE_COUNT_16_BIT,
            C2  = VK_SAMPLE_COUNT_2_BIT,
            C32 = VK_SAMPLE_COUNT_32_BIT,
            C4  = VK_SAMPLE_COUNT_4_BIT,
            C64 = VK_SAMPLE_COUNT_64_BIT,
            C8  = VK_SAMPLE_COUNT_8_BIT,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<SampleCountFlag> = true;

        enum class SamplerAddressMode : u8 {
            CLAMP_TO_BORDER      = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,
            CLAMP_TO_EDGE        = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,
            MIRROR_CLAMP_TO_EDGE = VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE,
            MIRRORED_REPEAT      = VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT,
            REPEAT               = VK_SAMPLER_ADDRESS_MODE_REPEAT,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<SamplerAddressMode> = true;

        enum class SamplerMipmapMode : u8 {
            LINEAR  = VK_SAMPLER_MIPMAP_MODE_LINEAR,
            NEAREST = VK_SAMPLER_MIPMAP_MODE_NEAREST,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<SamplerMipmapMode> = true;

        enum class ShaderStageFlag : u8 {
            COMPUTE  = VK_SHADER_STAGE_COMPUTE_BIT,
            FRAGMENT = VK_SHADER_STAGE_FRAGMENT_BIT,
            GEOMETRY = VK_SHADER_STAGE_GEOMETRY_BIT,
            NONE     = 0,
            VERTEX   = VK_SHADER_STAGE_VERTEX_BIT,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<ShaderStageFlag> = true;

        enum class StencilFaceFlag : u8 {
            BACK           = VK_STENCIL_FACE_BACK_BIT,
            FRONT          = VK_STENCIL_FACE_FRONT_BIT,
            FRONT_AND_BACK = FRONT | BACK,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<StencilFaceFlag> = true;

        enum class VertexInputRate : u8 {
            INSTANCE = VK_VERTEX_INPUT_RATE_INSTANCE,
            VERTEX   = VK_VERTEX_INPUT_RATE_VERTEX,
        };

        template<>
        inline constexpr auto details::IS_VULKAN_ENUMERATION<VertexInputRate> = true;

        template<typename T = VkFlags, meta::IsVulkanEnumeration U>
            requires(core::meta::IsPlainEnumeration<T> or core::meta::Is<T, VkFlags>)
        [[nodiscard]]
        constexpr auto to_vk(U value) noexcept -> T;

        template<meta::IsVulkanEnumeration T, typename U>
            requires(core::meta::IsPlainEnumeration<U> or core::meta::Is<U, VkFlags>)
        [[nodiscard]]
        constexpr auto from_vk(U value) noexcept -> T;

        [[nodiscard]]
        constexpr auto is_depth_only_format(PixelFormat format) noexcept -> bool;
        [[nodiscard]]
        constexpr auto is_depth_stencil_format(PixelFormat format) noexcept -> bool;
        [[nodiscard]]
        constexpr auto is_depth_format(PixelFormat format) noexcept -> bool;

        [[nodiscard]]
        constexpr auto get_format_channel_count(PixelFormat format) noexcept -> u8;
        [[nodiscard]]
        constexpr auto get_format_element_count(PixelFormat format) noexcept -> u8;
    } // namespace stormkit::gpu
    FLAG_ENUM(stormkit::gpu::AccessFlag)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::AccessFlag>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::AccessFlag::COLOR_ATTACHMENT_READ,
            stormkit::gpu::AccessFlag::COLOR_ATTACHMENT_WRITE,
            stormkit::gpu::AccessFlag::DEPTH_STENCIL_ATTACHMENT_READ,
            stormkit::gpu::AccessFlag::DEPTH_STENCIL_ATTACHMENT_WRITE,
            stormkit::gpu::AccessFlag::HOST_READ,
            stormkit::gpu::AccessFlag::HOST_WRITE,
            stormkit::gpu::AccessFlag::INDIRECT_COMMAND_READ,
            stormkit::gpu::AccessFlag::INPUT_ATTACHMENT_READ,
            stormkit::gpu::AccessFlag::MEMORY_READ,
            stormkit::gpu::AccessFlag::MEMORY_WRITE,
            stormkit::gpu::AccessFlag::NONE,
            stormkit::gpu::AccessFlag::SHADER_READ,
            stormkit::gpu::AccessFlag::SHADER_WRITE,
            stormkit::gpu::AccessFlag::TRANSFER_READ,
            stormkit::gpu::AccessFlag::TRANSFER_WRITE,
            stormkit::gpu::AccessFlag::UNIFORM_READ,
            stormkit::gpu::AccessFlag::VERTEX_ATTRIBUTE_READ,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<stormkit::gpu::AccessFlag>(stormkit::gpu::AccessFlag
                                                                          value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::AccessFlag::COLOR_ATTACHMENT_READ:
                return "AccessFlag::COLOR_ATTACHMENT_READ";
            case stormkit::gpu::AccessFlag::COLOR_ATTACHMENT_WRITE:
                return "AccessFlag::COLOR_ATTACHMENT_WRITE";
            case stormkit::gpu::AccessFlag::DEPTH_STENCIL_ATTACHMENT_READ:
                return "AccessFlag::DEPTH_STENCIL_ATTACHMENT_READ";
            case stormkit::gpu::AccessFlag::DEPTH_STENCIL_ATTACHMENT_WRITE:
                return "AccessFlag::DEPTH_STENCIL_ATTACHMENT_WRITE";
            case stormkit::gpu::AccessFlag::HOST_READ: return "AccessFlag::HOST_READ";
            case stormkit::gpu::AccessFlag::HOST_WRITE: return "AccessFlag::HOST_WRITE";
            case stormkit::gpu::AccessFlag::INDIRECT_COMMAND_READ:
                return "AccessFlag::INDIRECT_COMMAND_READ";
            case stormkit::gpu::AccessFlag::INPUT_ATTACHMENT_READ:
                return "AccessFlag::INPUT_ATTACHMENT_READ";
            case stormkit::gpu::AccessFlag::MEMORY_READ: return "AccessFlag::MEMORY_READ";
            case stormkit::gpu::AccessFlag::MEMORY_WRITE: return "AccessFlag::MEMORY_WRITE";
            case stormkit::gpu::AccessFlag::NONE: return "AccessFlag::NONE";
            case stormkit::gpu::AccessFlag::SHADER_READ: return "AccessFlag::SHADER_READ";
            case stormkit::gpu::AccessFlag::SHADER_WRITE: return "AccessFlag::SHADER_WRITE";
            case stormkit::gpu::AccessFlag::TRANSFER_READ: return "AccessFlag::TRANSFER_READ";
            case stormkit::gpu::AccessFlag::TRANSFER_WRITE: return "AccessFlag::TRANSFER_WRITE";
            case stormkit::gpu::AccessFlag::UNIFORM_READ: return "AccessFlag::UNIFORM_READ";
            case stormkit::gpu::AccessFlag::VERTEX_ATTRIBUTE_READ:
                return "AccessFlag::VERTEX_ATTRIBUTE_READ";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<stormkit::gpu::AccessFlag>(stormkit::gpu::AccessFlag
                                                                          value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::AccessFlag::COLOR_ATTACHMENT_READ:
                return "AccessFlag::COLOR_ATTACHMENT_READ";
            case stormkit::gpu::AccessFlag::COLOR_ATTACHMENT_WRITE:
                return "AccessFlag::COLOR_ATTACHMENT_WRITE";
            case stormkit::gpu::AccessFlag::DEPTH_STENCIL_ATTACHMENT_READ:
                return "AccessFlag::DEPTH_STENCIL_ATTACHMENT_READ";
            case stormkit::gpu::AccessFlag::DEPTH_STENCIL_ATTACHMENT_WRITE:
                return "AccessFlag::DEPTH_STENCIL_ATTACHMENT_WRITE";
            case stormkit::gpu::AccessFlag::HOST_READ: return "AccessFlag::HOST_READ";
            case stormkit::gpu::AccessFlag::HOST_WRITE: return "AccessFlag::HOST_WRITE";
            case stormkit::gpu::AccessFlag::INDIRECT_COMMAND_READ:
                return "AccessFlag::INDIRECT_COMMAND_READ";
            case stormkit::gpu::AccessFlag::INPUT_ATTACHMENT_READ:
                return "AccessFlag::INPUT_ATTACHMENT_READ";
            case stormkit::gpu::AccessFlag::MEMORY_READ: return "AccessFlag::MEMORY_READ";
            case stormkit::gpu::AccessFlag::MEMORY_WRITE: return "AccessFlag::MEMORY_WRITE";
            case stormkit::gpu::AccessFlag::NONE: return "AccessFlag::NONE";
            case stormkit::gpu::AccessFlag::SHADER_READ: return "AccessFlag::SHADER_READ";
            case stormkit::gpu::AccessFlag::SHADER_WRITE: return "AccessFlag::SHADER_WRITE";
            case stormkit::gpu::AccessFlag::TRANSFER_READ: return "AccessFlag::TRANSFER_READ";
            case stormkit::gpu::AccessFlag::TRANSFER_WRITE: return "AccessFlag::TRANSFER_WRITE";
            case stormkit::gpu::AccessFlag::UNIFORM_READ: return "AccessFlag::UNIFORM_READ";
            case stormkit::gpu::AccessFlag::VERTEX_ATTRIBUTE_READ:
                return "AccessFlag::VERTEX_ATTRIBUTE_READ";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::AttachmentLoadOperation)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<
      stormkit::gpu::AttachmentLoadOperation>() noexcept -> decltype(auto) {
        return std::array {
            stormkit::gpu::AttachmentLoadOperation::CLEAR,
            stormkit::gpu::AttachmentLoadOperation::DONT_CARE,
            stormkit::gpu::AttachmentLoadOperation::LOAD,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<
      stormkit::gpu::AttachmentLoadOperation>(stormkit::gpu::AttachmentLoadOperation value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::AttachmentLoadOperation::CLEAR:
                return "AttachmentLoadOperation::CLEAR";
            case stormkit::gpu::AttachmentLoadOperation::DONT_CARE:
                return "AttachmentLoadOperation::DONT_CARE";
            case stormkit::gpu::AttachmentLoadOperation::LOAD:
                return "AttachmentLoadOperation::LOAD";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<
      stormkit::gpu::AttachmentLoadOperation>(stormkit::gpu::AttachmentLoadOperation value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::AttachmentLoadOperation::CLEAR:
                return "AttachmentLoadOperation::CLEAR";
            case stormkit::gpu::AttachmentLoadOperation::DONT_CARE:
                return "AttachmentLoadOperation::DONT_CARE";
            case stormkit::gpu::AttachmentLoadOperation::LOAD:
                return "AttachmentLoadOperation::LOAD";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::AttachmentStoreOperation)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<
      stormkit::gpu::AttachmentStoreOperation>() noexcept -> decltype(auto) {
        return std::array {
            stormkit::gpu::AttachmentStoreOperation::DONT_CARE,
            stormkit::gpu::AttachmentStoreOperation::STORE,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<
      stormkit::gpu::AttachmentStoreOperation>(stormkit::gpu::AttachmentStoreOperation
                                                 value) noexcept -> std::string_view {
        switch (value) {
            case stormkit::gpu::AttachmentStoreOperation::DONT_CARE:
                return "AttachmentStoreOperation::DONT_CARE";
            case stormkit::gpu::AttachmentStoreOperation::STORE:
                return "AttachmentStoreOperation::STORE";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<
      stormkit::gpu::AttachmentStoreOperation>(stormkit::gpu::AttachmentStoreOperation
                                                 value) noexcept -> std::string {
        switch (value) {
            case stormkit::gpu::AttachmentStoreOperation::DONT_CARE:
                return "AttachmentStoreOperation::DONT_CARE";
            case stormkit::gpu::AttachmentStoreOperation::STORE:
                return "AttachmentStoreOperation::STORE";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::BlendFactor)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::BlendFactor>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::BlendFactor::CONSTANT_ALPHA,
            stormkit::gpu::BlendFactor::CONSTANT_COLOR,
            stormkit::gpu::BlendFactor::DST_ALPHA,
            stormkit::gpu::BlendFactor::DST_COLOR,
            stormkit::gpu::BlendFactor::ONE,
            stormkit::gpu::BlendFactor::ONE_MINUS_CONSTANT_ALPHA,
            stormkit::gpu::BlendFactor::ONE_MINUS_CONSTANT_COLOR,
            stormkit::gpu::BlendFactor::ONE_MINUS_DST_ALPHA,
            stormkit::gpu::BlendFactor::ONE_MINUS_DST_COLOR,
            stormkit::gpu::BlendFactor::ONE_MINUS_SRC1_ALPHA,
            stormkit::gpu::BlendFactor::ONE_MINUS_SRC1_COLOR,
            stormkit::gpu::BlendFactor::ONE_MINUS_SRC_ALPHA,
            stormkit::gpu::BlendFactor::ONE_MINUS_SRC_COLOR,
            stormkit::gpu::BlendFactor::SRC1_ALPHA,
            stormkit::gpu::BlendFactor::SRC1_COLOR,
            stormkit::gpu::BlendFactor::SRC_ALPHA,
            stormkit::gpu::BlendFactor::SRC_ALPHA_SATURATE,
            stormkit::gpu::BlendFactor::SRC_COLOR,
            stormkit::gpu::BlendFactor::ZERO,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<stormkit::gpu::BlendFactor>(stormkit::gpu::BlendFactor
                                                                           value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::BlendFactor::CONSTANT_ALPHA: return "BlendFactor::CONSTANT_ALPHA";
            case stormkit::gpu::BlendFactor::CONSTANT_COLOR: return "BlendFactor::CONSTANT_COLOR";
            case stormkit::gpu::BlendFactor::DST_ALPHA: return "BlendFactor::DST_ALPHA";
            case stormkit::gpu::BlendFactor::DST_COLOR: return "BlendFactor::DST_COLOR";
            case stormkit::gpu::BlendFactor::ONE: return "BlendFactor::ONE";
            case stormkit::gpu::BlendFactor::ONE_MINUS_CONSTANT_ALPHA:
                return "BlendFactor::ONE_MINUS_CONSTANT_ALPHA";
            case stormkit::gpu::BlendFactor::ONE_MINUS_CONSTANT_COLOR:
                return "BlendFactor::ONE_MINUS_CONSTANT_COLOR";
            case stormkit::gpu::BlendFactor::ONE_MINUS_DST_ALPHA:
                return "BlendFactor::ONE_MINUS_DST_ALPHA";
            case stormkit::gpu::BlendFactor::ONE_MINUS_DST_COLOR:
                return "BlendFactor::ONE_MINUS_DST_COLOR";
            case stormkit::gpu::BlendFactor::ONE_MINUS_SRC1_ALPHA:
                return "BlendFactor::ONE_MINUS_SRC1_ALPHA";
            case stormkit::gpu::BlendFactor::ONE_MINUS_SRC1_COLOR:
                return "BlendFactor::ONE_MINUS_SRC1_COLOR";
            case stormkit::gpu::BlendFactor::ONE_MINUS_SRC_ALPHA:
                return "BlendFactor::ONE_MINUS_SRC_ALPHA";
            case stormkit::gpu::BlendFactor::ONE_MINUS_SRC_COLOR:
                return "BlendFactor::ONE_MINUS_SRC_COLOR";
            case stormkit::gpu::BlendFactor::SRC1_ALPHA: return "BlendFactor::SRC1_ALPHA";
            case stormkit::gpu::BlendFactor::SRC1_COLOR: return "BlendFactor::SRC1_COLOR";
            case stormkit::gpu::BlendFactor::SRC_ALPHA: return "BlendFactor::SRC_ALPHA";
            case stormkit::gpu::BlendFactor::SRC_ALPHA_SATURATE:
                return "BlendFactor::SRC_ALPHA_SATURATE";
            case stormkit::gpu::BlendFactor::SRC_COLOR: return "BlendFactor::SRC_COLOR";
            case stormkit::gpu::BlendFactor::ZERO: return "BlendFactor::ZERO";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<stormkit::gpu::BlendFactor>(stormkit::gpu::BlendFactor
                                                                           value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::BlendFactor::CONSTANT_ALPHA: return "BlendFactor::CONSTANT_ALPHA";
            case stormkit::gpu::BlendFactor::CONSTANT_COLOR: return "BlendFactor::CONSTANT_COLOR";
            case stormkit::gpu::BlendFactor::DST_ALPHA: return "BlendFactor::DST_ALPHA";
            case stormkit::gpu::BlendFactor::DST_COLOR: return "BlendFactor::DST_COLOR";
            case stormkit::gpu::BlendFactor::ONE: return "BlendFactor::ONE";
            case stormkit::gpu::BlendFactor::ONE_MINUS_CONSTANT_ALPHA:
                return "BlendFactor::ONE_MINUS_CONSTANT_ALPHA";
            case stormkit::gpu::BlendFactor::ONE_MINUS_CONSTANT_COLOR:
                return "BlendFactor::ONE_MINUS_CONSTANT_COLOR";
            case stormkit::gpu::BlendFactor::ONE_MINUS_DST_ALPHA:
                return "BlendFactor::ONE_MINUS_DST_ALPHA";
            case stormkit::gpu::BlendFactor::ONE_MINUS_DST_COLOR:
                return "BlendFactor::ONE_MINUS_DST_COLOR";
            case stormkit::gpu::BlendFactor::ONE_MINUS_SRC1_ALPHA:
                return "BlendFactor::ONE_MINUS_SRC1_ALPHA";
            case stormkit::gpu::BlendFactor::ONE_MINUS_SRC1_COLOR:
                return "BlendFactor::ONE_MINUS_SRC1_COLOR";
            case stormkit::gpu::BlendFactor::ONE_MINUS_SRC_ALPHA:
                return "BlendFactor::ONE_MINUS_SRC_ALPHA";
            case stormkit::gpu::BlendFactor::ONE_MINUS_SRC_COLOR:
                return "BlendFactor::ONE_MINUS_SRC_COLOR";
            case stormkit::gpu::BlendFactor::SRC1_ALPHA: return "BlendFactor::SRC1_ALPHA";
            case stormkit::gpu::BlendFactor::SRC1_COLOR: return "BlendFactor::SRC1_COLOR";
            case stormkit::gpu::BlendFactor::SRC_ALPHA: return "BlendFactor::SRC_ALPHA";
            case stormkit::gpu::BlendFactor::SRC_ALPHA_SATURATE:
                return "BlendFactor::SRC_ALPHA_SATURATE";
            case stormkit::gpu::BlendFactor::SRC_COLOR: return "BlendFactor::SRC_COLOR";
            case stormkit::gpu::BlendFactor::ZERO: return "BlendFactor::ZERO";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::BlendOperation)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::BlendOperation>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::BlendOperation::ADD,
            stormkit::gpu::BlendOperation::MAX,
            stormkit::gpu::BlendOperation::MIN,
            stormkit::gpu::BlendOperation::REVERSE_SUBTRACT,
            stormkit::gpu::BlendOperation::SUBTRACT,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<
      stormkit::gpu::BlendOperation>(stormkit::gpu::BlendOperation value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::BlendOperation::ADD: return "BlendOperation::ADD";
            case stormkit::gpu::BlendOperation::MAX: return "BlendOperation::MAX";
            case stormkit::gpu::BlendOperation::MIN: return "BlendOperation::MIN";
            case stormkit::gpu::BlendOperation::REVERSE_SUBTRACT:
                return "BlendOperation::REVERSE_SUBTRACT";
            case stormkit::gpu::BlendOperation::SUBTRACT: return "BlendOperation::SUBTRACT";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<
      stormkit::gpu::BlendOperation>(stormkit::gpu::BlendOperation value) noexcept -> std::string {
        switch (value) {
            case stormkit::gpu::BlendOperation::ADD: return "BlendOperation::ADD";
            case stormkit::gpu::BlendOperation::MAX: return "BlendOperation::MAX";
            case stormkit::gpu::BlendOperation::MIN: return "BlendOperation::MIN";
            case stormkit::gpu::BlendOperation::REVERSE_SUBTRACT:
                return "BlendOperation::REVERSE_SUBTRACT";
            case stormkit::gpu::BlendOperation::SUBTRACT: return "BlendOperation::SUBTRACT";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::BorderColor)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::BorderColor>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::BorderColor::FLOAT_OPAQUE_BLACK,
            stormkit::gpu::BorderColor::FLOAT_OPAQUE_WHITE,
            stormkit::gpu::BorderColor::FLOAT_TRANSPARENT_BLACK,
            stormkit::gpu::BorderColor::INT_OPAQUE_BLACK,
            stormkit::gpu::BorderColor::INT_OPAQUE_WHITE,
            stormkit::gpu::BorderColor::INT_TRANSPARENT_BLACK,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<stormkit::gpu::BorderColor>(stormkit::gpu::BorderColor
                                                                           value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::BorderColor::FLOAT_OPAQUE_BLACK:
                return "BorderColor::FLOAT_OPAQUE_BLACK";
            case stormkit::gpu::BorderColor::FLOAT_OPAQUE_WHITE:
                return "BorderColor::FLOAT_OPAQUE_WHITE";
            case stormkit::gpu::BorderColor::FLOAT_TRANSPARENT_BLACK:
                return "BorderColor::FLOAT_TRANSPARENT_BLACK";
            case stormkit::gpu::BorderColor::INT_OPAQUE_BLACK:
                return "BorderColor::INT_OPAQUE_BLACK";
            case stormkit::gpu::BorderColor::INT_OPAQUE_WHITE:
                return "BorderColor::INT_OPAQUE_WHITE";
            case stormkit::gpu::BorderColor::INT_TRANSPARENT_BLACK:
                return "BorderColor::INT_TRANSPARENT_BLACK";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<stormkit::gpu::BorderColor>(stormkit::gpu::BorderColor
                                                                           value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::BorderColor::FLOAT_OPAQUE_BLACK:
                return "BorderColor::FLOAT_OPAQUE_BLACK";
            case stormkit::gpu::BorderColor::FLOAT_OPAQUE_WHITE:
                return "BorderColor::FLOAT_OPAQUE_WHITE";
            case stormkit::gpu::BorderColor::FLOAT_TRANSPARENT_BLACK:
                return "BorderColor::FLOAT_TRANSPARENT_BLACK";
            case stormkit::gpu::BorderColor::INT_OPAQUE_BLACK:
                return "BorderColor::INT_OPAQUE_BLACK";
            case stormkit::gpu::BorderColor::INT_OPAQUE_WHITE:
                return "BorderColor::INT_OPAQUE_WHITE";
            case stormkit::gpu::BorderColor::INT_TRANSPARENT_BLACK:
                return "BorderColor::INT_TRANSPARENT_BLACK";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::BufferUsageFlag)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::BufferUsageFlag>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::BufferUsageFlag::INDEX,
            stormkit::gpu::BufferUsageFlag::INDIRECT,
            stormkit::gpu::BufferUsageFlag::STORAGE,
            stormkit::gpu::BufferUsageFlag::STORAGE_TEXEL,
            stormkit::gpu::BufferUsageFlag::TRANSFER_DST,
            stormkit::gpu::BufferUsageFlag::TRANSFER_SRC,
            stormkit::gpu::BufferUsageFlag::UNIFORM,
            stormkit::gpu::BufferUsageFlag::UNIFORM_TEXEL,
            stormkit::gpu::BufferUsageFlag::VERTEX,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<
      stormkit::gpu::BufferUsageFlag>(stormkit::gpu::BufferUsageFlag value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::BufferUsageFlag::INDEX: return "BufferUsageFlag::INDEX";
            case stormkit::gpu::BufferUsageFlag::INDIRECT: return "BufferUsageFlag::INDIRECT";
            case stormkit::gpu::BufferUsageFlag::STORAGE: return "BufferUsageFlag::STORAGE";
            case stormkit::gpu::BufferUsageFlag::STORAGE_TEXEL:
                return "BufferUsageFlag::STORAGE_TEXEL";
            case stormkit::gpu::BufferUsageFlag::TRANSFER_DST:
                return "BufferUsageFlag::TRANSFER_DST";
            case stormkit::gpu::BufferUsageFlag::TRANSFER_SRC:
                return "BufferUsageFlag::TRANSFER_SRC";
            case stormkit::gpu::BufferUsageFlag::UNIFORM: return "BufferUsageFlag::UNIFORM";
            case stormkit::gpu::BufferUsageFlag::UNIFORM_TEXEL:
                return "BufferUsageFlag::UNIFORM_TEXEL";
            case stormkit::gpu::BufferUsageFlag::VERTEX: return "BufferUsageFlag::VERTEX";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<
      stormkit::gpu::BufferUsageFlag>(stormkit::gpu::BufferUsageFlag value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::BufferUsageFlag::INDEX: return "BufferUsageFlag::INDEX";
            case stormkit::gpu::BufferUsageFlag::INDIRECT: return "BufferUsageFlag::INDIRECT";
            case stormkit::gpu::BufferUsageFlag::STORAGE: return "BufferUsageFlag::STORAGE";
            case stormkit::gpu::BufferUsageFlag::STORAGE_TEXEL:
                return "BufferUsageFlag::STORAGE_TEXEL";
            case stormkit::gpu::BufferUsageFlag::TRANSFER_DST:
                return "BufferUsageFlag::TRANSFER_DST";
            case stormkit::gpu::BufferUsageFlag::TRANSFER_SRC:
                return "BufferUsageFlag::TRANSFER_SRC";
            case stormkit::gpu::BufferUsageFlag::UNIFORM: return "BufferUsageFlag::UNIFORM";
            case stormkit::gpu::BufferUsageFlag::UNIFORM_TEXEL:
                return "BufferUsageFlag::UNIFORM_TEXEL";
            case stormkit::gpu::BufferUsageFlag::VERTEX: return "BufferUsageFlag::VERTEX";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::ColorComponentFlag)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::ColorComponentFlag>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::ColorComponentFlag::A,   stormkit::gpu::ColorComponentFlag::B,
            stormkit::gpu::ColorComponentFlag::G,   stormkit::gpu::ColorComponentFlag::NONE,
            stormkit::gpu::ColorComponentFlag::R,   stormkit::gpu::ColorComponentFlag::RG,
            stormkit::gpu::ColorComponentFlag::RGB, stormkit::gpu::ColorComponentFlag::RGBA,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<
      stormkit::gpu::ColorComponentFlag>(stormkit::gpu::ColorComponentFlag value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::ColorComponentFlag::A: return "ColorComponentFlag::A";
            case stormkit::gpu::ColorComponentFlag::B: return "ColorComponentFlag::B";
            case stormkit::gpu::ColorComponentFlag::G: return "ColorComponentFlag::G";
            case stormkit::gpu::ColorComponentFlag::NONE: return "ColorComponentFlag::NONE";
            case stormkit::gpu::ColorComponentFlag::R: return "ColorComponentFlag::R";
            case stormkit::gpu::ColorComponentFlag::RG: return "ColorComponentFlag::RG";
            case stormkit::gpu::ColorComponentFlag::RGB: return "ColorComponentFlag::RGB";
            case stormkit::gpu::ColorComponentFlag::RGBA: return "ColorComponentFlag::RGBA";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<
      stormkit::gpu::ColorComponentFlag>(stormkit::gpu::ColorComponentFlag value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::ColorComponentFlag::A: return "ColorComponentFlag::A";
            case stormkit::gpu::ColorComponentFlag::B: return "ColorComponentFlag::B";
            case stormkit::gpu::ColorComponentFlag::G: return "ColorComponentFlag::G";
            case stormkit::gpu::ColorComponentFlag::NONE: return "ColorComponentFlag::NONE";
            case stormkit::gpu::ColorComponentFlag::R: return "ColorComponentFlag::R";
            case stormkit::gpu::ColorComponentFlag::RG: return "ColorComponentFlag::RG";
            case stormkit::gpu::ColorComponentFlag::RGB: return "ColorComponentFlag::RGB";
            case stormkit::gpu::ColorComponentFlag::RGBA: return "ColorComponentFlag::RGBA";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::ColorSpace)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::ColorSpace>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::ColorSpace::ADOBERGB_LINEAR,
            stormkit::gpu::ColorSpace::ADOBERGB_NONLINEAR,
            stormkit::gpu::ColorSpace::BT2020_LINEAR,
            stormkit::gpu::ColorSpace::BT709_LINEAR,
            stormkit::gpu::ColorSpace::BT709_NONLINEAR,
            stormkit::gpu::ColorSpace::DCI_P3_NONLINEAR,
            stormkit::gpu::ColorSpace::DISPLAY_NATIVE_AMD,
            stormkit::gpu::ColorSpace::DISPLAY_P3_LINEAR,
            stormkit::gpu::ColorSpace::DISPLAY_P3_NONLINEAR,
            stormkit::gpu::ColorSpace::DOLBYVISION,
            stormkit::gpu::ColorSpace::EXTENDED_SRGB_LINEAR,
            stormkit::gpu::ColorSpace::EXTENDED_SRGB_NONLINEAR,
            stormkit::gpu::ColorSpace::HDR10_HLG,
            stormkit::gpu::ColorSpace::HDR10_ST2084,
            stormkit::gpu::ColorSpace::PASS_THROUGH,
            stormkit::gpu::ColorSpace::SRGB_NONLINEAR,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<stormkit::gpu::ColorSpace>(stormkit::gpu::ColorSpace
                                                                          value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::ColorSpace::ADOBERGB_LINEAR: return "ColorSpace::ADOBERGB_LINEAR";
            case stormkit::gpu::ColorSpace::ADOBERGB_NONLINEAR:
                return "ColorSpace::ADOBERGB_NONLINEAR";
            case stormkit::gpu::ColorSpace::BT2020_LINEAR: return "ColorSpace::BT2020_LINEAR";
            case stormkit::gpu::ColorSpace::BT709_LINEAR: return "ColorSpace::BT709_LINEAR";
            case stormkit::gpu::ColorSpace::BT709_NONLINEAR: return "ColorSpace::BT709_NONLINEAR";
            case stormkit::gpu::ColorSpace::DCI_P3_NONLINEAR: return "ColorSpace::DCI_P3_NONLINEAR";
            case stormkit::gpu::ColorSpace::DISPLAY_NATIVE_AMD:
                return "ColorSpace::DISPLAY_NATIVE_AMD";
            case stormkit::gpu::ColorSpace::DISPLAY_P3_LINEAR:
                return "ColorSpace::DISPLAY_P3_LINEAR";
            case stormkit::gpu::ColorSpace::DISPLAY_P3_NONLINEAR:
                return "ColorSpace::DISPLAY_P3_NONLINEAR";
            case stormkit::gpu::ColorSpace::DOLBYVISION: return "ColorSpace::DOLBYVISION";
            case stormkit::gpu::ColorSpace::EXTENDED_SRGB_LINEAR:
                return "ColorSpace::EXTENDED_SRGB_LINEAR";
            case stormkit::gpu::ColorSpace::EXTENDED_SRGB_NONLINEAR:
                return "ColorSpace::EXTENDED_SRGB_NONLINEAR";
            case stormkit::gpu::ColorSpace::HDR10_HLG: return "ColorSpace::HDR10_HLG";
            case stormkit::gpu::ColorSpace::HDR10_ST2084: return "ColorSpace::HDR10_ST2084";
            case stormkit::gpu::ColorSpace::PASS_THROUGH: return "ColorSpace::PASS_THROUGH";
            case stormkit::gpu::ColorSpace::SRGB_NONLINEAR: return "ColorSpace::SRGB_NONLINEAR";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<stormkit::gpu::ColorSpace>(stormkit::gpu::ColorSpace
                                                                          value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::ColorSpace::ADOBERGB_LINEAR: return "ColorSpace::ADOBERGB_LINEAR";
            case stormkit::gpu::ColorSpace::ADOBERGB_NONLINEAR:
                return "ColorSpace::ADOBERGB_NONLINEAR";
            case stormkit::gpu::ColorSpace::BT2020_LINEAR: return "ColorSpace::BT2020_LINEAR";
            case stormkit::gpu::ColorSpace::BT709_LINEAR: return "ColorSpace::BT709_LINEAR";
            case stormkit::gpu::ColorSpace::BT709_NONLINEAR: return "ColorSpace::BT709_NONLINEAR";
            case stormkit::gpu::ColorSpace::DCI_P3_NONLINEAR: return "ColorSpace::DCI_P3_NONLINEAR";
            case stormkit::gpu::ColorSpace::DISPLAY_NATIVE_AMD:
                return "ColorSpace::DISPLAY_NATIVE_AMD";
            case stormkit::gpu::ColorSpace::DISPLAY_P3_LINEAR:
                return "ColorSpace::DISPLAY_P3_LINEAR";
            case stormkit::gpu::ColorSpace::DISPLAY_P3_NONLINEAR:
                return "ColorSpace::DISPLAY_P3_NONLINEAR";
            case stormkit::gpu::ColorSpace::DOLBYVISION: return "ColorSpace::DOLBYVISION";
            case stormkit::gpu::ColorSpace::EXTENDED_SRGB_LINEAR:
                return "ColorSpace::EXTENDED_SRGB_LINEAR";
            case stormkit::gpu::ColorSpace::EXTENDED_SRGB_NONLINEAR:
                return "ColorSpace::EXTENDED_SRGB_NONLINEAR";
            case stormkit::gpu::ColorSpace::HDR10_HLG: return "ColorSpace::HDR10_HLG";
            case stormkit::gpu::ColorSpace::HDR10_ST2084: return "ColorSpace::HDR10_ST2084";
            case stormkit::gpu::ColorSpace::PASS_THROUGH: return "ColorSpace::PASS_THROUGH";
            case stormkit::gpu::ColorSpace::SRGB_NONLINEAR: return "ColorSpace::SRGB_NONLINEAR";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::CommandBufferLevel)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::CommandBufferLevel>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::CommandBufferLevel::PRIMARY,
            stormkit::gpu::CommandBufferLevel::SECONDARY,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<
      stormkit::gpu::CommandBufferLevel>(stormkit::gpu::CommandBufferLevel value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::CommandBufferLevel::PRIMARY: return "CommandBufferLevel::PRIMARY";
            case stormkit::gpu::CommandBufferLevel::SECONDARY:
                return "CommandBufferLevel::SECONDARY";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<
      stormkit::gpu::CommandBufferLevel>(stormkit::gpu::CommandBufferLevel value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::CommandBufferLevel::PRIMARY: return "CommandBufferLevel::PRIMARY";
            case stormkit::gpu::CommandBufferLevel::SECONDARY:
                return "CommandBufferLevel::SECONDARY";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::CompareOperation)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::CompareOperation>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::CompareOperation::ALWAYS,
            stormkit::gpu::CompareOperation::EQUAL,
            stormkit::gpu::CompareOperation::GREATER,
            stormkit::gpu::CompareOperation::GREATER_OR_EQUAL,
            stormkit::gpu::CompareOperation::LESS,
            stormkit::gpu::CompareOperation::LESS_OR_EQUAL,
            stormkit::gpu::CompareOperation::NEVER,
            stormkit::gpu::CompareOperation::NOT_EQUAL,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<
      stormkit::gpu::CompareOperation>(stormkit::gpu::CompareOperation value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::CompareOperation::ALWAYS: return "CompareOperation::ALWAYS";
            case stormkit::gpu::CompareOperation::EQUAL: return "CompareOperation::EQUAL";
            case stormkit::gpu::CompareOperation::GREATER: return "CompareOperation::GREATER";
            case stormkit::gpu::CompareOperation::GREATER_OR_EQUAL:
                return "CompareOperation::GREATER_OR_EQUAL";
            case stormkit::gpu::CompareOperation::LESS: return "CompareOperation::LESS";
            case stormkit::gpu::CompareOperation::LESS_OR_EQUAL:
                return "CompareOperation::LESS_OR_EQUAL";
            case stormkit::gpu::CompareOperation::NEVER: return "CompareOperation::NEVER";
            case stormkit::gpu::CompareOperation::NOT_EQUAL: return "CompareOperation::NOT_EQUAL";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<
      stormkit::gpu::CompareOperation>(stormkit::gpu::CompareOperation value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::CompareOperation::ALWAYS: return "CompareOperation::ALWAYS";
            case stormkit::gpu::CompareOperation::EQUAL: return "CompareOperation::EQUAL";
            case stormkit::gpu::CompareOperation::GREATER: return "CompareOperation::GREATER";
            case stormkit::gpu::CompareOperation::GREATER_OR_EQUAL:
                return "CompareOperation::GREATER_OR_EQUAL";
            case stormkit::gpu::CompareOperation::LESS: return "CompareOperation::LESS";
            case stormkit::gpu::CompareOperation::LESS_OR_EQUAL:
                return "CompareOperation::LESS_OR_EQUAL";
            case stormkit::gpu::CompareOperation::NEVER: return "CompareOperation::NEVER";
            case stormkit::gpu::CompareOperation::NOT_EQUAL: return "CompareOperation::NOT_EQUAL";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::CullModeFlag)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::CullModeFlag>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::CullModeFlag::BACK,
            stormkit::gpu::CullModeFlag::FRONT,
            stormkit::gpu::CullModeFlag::FRONT_BACK,
            stormkit::gpu::CullModeFlag::NONE,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<
      stormkit::gpu::CullModeFlag>(stormkit::gpu::CullModeFlag value) noexcept -> std::string_view {
        switch (value) {
            case stormkit::gpu::CullModeFlag::BACK: return "CullModeFlag::BACK";
            case stormkit::gpu::CullModeFlag::FRONT: return "CullModeFlag::FRONT";
            case stormkit::gpu::CullModeFlag::FRONT_BACK: return "CullModeFlag::FRONT_BACK";
            case stormkit::gpu::CullModeFlag::NONE: return "CullModeFlag::NONE";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<
      stormkit::gpu::CullModeFlag>(stormkit::gpu::CullModeFlag value) noexcept -> std::string {
        switch (value) {
            case stormkit::gpu::CullModeFlag::BACK: return "CullModeFlag::BACK";
            case stormkit::gpu::CullModeFlag::FRONT: return "CullModeFlag::FRONT";
            case stormkit::gpu::CullModeFlag::FRONT_BACK: return "CullModeFlag::FRONT_BACK";
            case stormkit::gpu::CullModeFlag::NONE: return "CullModeFlag::NONE";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::DebugObjectType)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::DebugObjectType>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::DebugObjectType::BUFFER,
            stormkit::gpu::DebugObjectType::BUFFER_VIEW,
            stormkit::gpu::DebugObjectType::COMMAND_BUFFER,
            stormkit::gpu::DebugObjectType::COMMAND_POOL,
            stormkit::gpu::DebugObjectType::DEBUG_REPORT_CALLBACK,
            stormkit::gpu::DebugObjectType::DESCRIPTOR_POOL,
            stormkit::gpu::DebugObjectType::DESCRIPTOR_SET,
            stormkit::gpu::DebugObjectType::DESCRIPTOR_SET_LAYOUT,
            stormkit::gpu::DebugObjectType::DEVICE,
            stormkit::gpu::DebugObjectType::DEVICE_MEMORY,
            stormkit::gpu::DebugObjectType::DISPLAY,
            stormkit::gpu::DebugObjectType::EVENT,
            stormkit::gpu::DebugObjectType::FENCE,
            stormkit::gpu::DebugObjectType::FRAMEBUFFER,
            stormkit::gpu::DebugObjectType::IMAGE,
            stormkit::gpu::DebugObjectType::IMAGE_VIEW,
            stormkit::gpu::DebugObjectType::INSTANCE,
            stormkit::gpu::DebugObjectType::PHYSICAL_DEVICE,
            stormkit::gpu::DebugObjectType::PIPELINE,
            stormkit::gpu::DebugObjectType::PIPELINE_CACHE,
            stormkit::gpu::DebugObjectType::PIPELINE_LAYOUT,
            stormkit::gpu::DebugObjectType::QUERY_POOL,
            stormkit::gpu::DebugObjectType::QUEUE,
            stormkit::gpu::DebugObjectType::RENDER_PASS,
            stormkit::gpu::DebugObjectType::SAMPLER,
            stormkit::gpu::DebugObjectType::SEMAPHORE,
            stormkit::gpu::DebugObjectType::SHADER_MODULE,
            stormkit::gpu::DebugObjectType::SURFACE,
            stormkit::gpu::DebugObjectType::SWAPCHAIN,
            stormkit::gpu::DebugObjectType::UNKNOWN,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<
      stormkit::gpu::DebugObjectType>(stormkit::gpu::DebugObjectType value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::DebugObjectType::BUFFER: return "DebugObjectType::BUFFER";
            case stormkit::gpu::DebugObjectType::BUFFER_VIEW: return "DebugObjectType::BUFFER_VIEW";
            case stormkit::gpu::DebugObjectType::COMMAND_BUFFER:
                return "DebugObjectType::COMMAND_BUFFER";
            case stormkit::gpu::DebugObjectType::COMMAND_POOL:
                return "DebugObjectType::COMMAND_POOL";
            case stormkit::gpu::DebugObjectType::DEBUG_REPORT_CALLBACK:
                return "DebugObjectType::DEBUG_REPORT_CALLBACK";
            case stormkit::gpu::DebugObjectType::DESCRIPTOR_POOL:
                return "DebugObjectType::DESCRIPTOR_POOL";
            case stormkit::gpu::DebugObjectType::DESCRIPTOR_SET:
                return "DebugObjectType::DESCRIPTOR_SET";
            case stormkit::gpu::DebugObjectType::DESCRIPTOR_SET_LAYOUT:
                return "DebugObjectType::DESCRIPTOR_SET_LAYOUT";
            case stormkit::gpu::DebugObjectType::DEVICE: return "DebugObjectType::DEVICE";
            case stormkit::gpu::DebugObjectType::DEVICE_MEMORY:
                return "DebugObjectType::DEVICE_MEMORY";
            case stormkit::gpu::DebugObjectType::DISPLAY: return "DebugObjectType::DISPLAY";
            case stormkit::gpu::DebugObjectType::EVENT: return "DebugObjectType::EVENT";
            case stormkit::gpu::DebugObjectType::FENCE: return "DebugObjectType::FENCE";
            case stormkit::gpu::DebugObjectType::FRAMEBUFFER: return "DebugObjectType::FRAMEBUFFER";
            case stormkit::gpu::DebugObjectType::IMAGE: return "DebugObjectType::IMAGE";
            case stormkit::gpu::DebugObjectType::IMAGE_VIEW: return "DebugObjectType::IMAGE_VIEW";
            case stormkit::gpu::DebugObjectType::INSTANCE: return "DebugObjectType::INSTANCE";
            case stormkit::gpu::DebugObjectType::PHYSICAL_DEVICE:
                return "DebugObjectType::PHYSICAL_DEVICE";
            case stormkit::gpu::DebugObjectType::PIPELINE: return "DebugObjectType::PIPELINE";
            case stormkit::gpu::DebugObjectType::PIPELINE_CACHE:
                return "DebugObjectType::PIPELINE_CACHE";
            case stormkit::gpu::DebugObjectType::PIPELINE_LAYOUT:
                return "DebugObjectType::PIPELINE_LAYOUT";
            case stormkit::gpu::DebugObjectType::QUERY_POOL: return "DebugObjectType::QUERY_POOL";
            case stormkit::gpu::DebugObjectType::QUEUE: return "DebugObjectType::QUEUE";
            case stormkit::gpu::DebugObjectType::RENDER_PASS: return "DebugObjectType::RENDER_PASS";
            case stormkit::gpu::DebugObjectType::SAMPLER: return "DebugObjectType::SAMPLER";
            case stormkit::gpu::DebugObjectType::SEMAPHORE: return "DebugObjectType::SEMAPHORE";
            case stormkit::gpu::DebugObjectType::SHADER_MODULE:
                return "DebugObjectType::SHADER_MODULE";
            case stormkit::gpu::DebugObjectType::SURFACE: return "DebugObjectType::SURFACE";
            case stormkit::gpu::DebugObjectType::SWAPCHAIN: return "DebugObjectType::SWAPCHAIN";
            case stormkit::gpu::DebugObjectType::UNKNOWN: return "DebugObjectType::UNKNOWN";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<
      stormkit::gpu::DebugObjectType>(stormkit::gpu::DebugObjectType value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::DebugObjectType::BUFFER: return "DebugObjectType::BUFFER";
            case stormkit::gpu::DebugObjectType::BUFFER_VIEW: return "DebugObjectType::BUFFER_VIEW";
            case stormkit::gpu::DebugObjectType::COMMAND_BUFFER:
                return "DebugObjectType::COMMAND_BUFFER";
            case stormkit::gpu::DebugObjectType::COMMAND_POOL:
                return "DebugObjectType::COMMAND_POOL";
            case stormkit::gpu::DebugObjectType::DEBUG_REPORT_CALLBACK:
                return "DebugObjectType::DEBUG_REPORT_CALLBACK";
            case stormkit::gpu::DebugObjectType::DESCRIPTOR_POOL:
                return "DebugObjectType::DESCRIPTOR_POOL";
            case stormkit::gpu::DebugObjectType::DESCRIPTOR_SET:
                return "DebugObjectType::DESCRIPTOR_SET";
            case stormkit::gpu::DebugObjectType::DESCRIPTOR_SET_LAYOUT:
                return "DebugObjectType::DESCRIPTOR_SET_LAYOUT";
            case stormkit::gpu::DebugObjectType::DEVICE: return "DebugObjectType::DEVICE";
            case stormkit::gpu::DebugObjectType::DEVICE_MEMORY:
                return "DebugObjectType::DEVICE_MEMORY";
            case stormkit::gpu::DebugObjectType::DISPLAY: return "DebugObjectType::DISPLAY";
            case stormkit::gpu::DebugObjectType::EVENT: return "DebugObjectType::EVENT";
            case stormkit::gpu::DebugObjectType::FENCE: return "DebugObjectType::FENCE";
            case stormkit::gpu::DebugObjectType::FRAMEBUFFER: return "DebugObjectType::FRAMEBUFFER";
            case stormkit::gpu::DebugObjectType::IMAGE: return "DebugObjectType::IMAGE";
            case stormkit::gpu::DebugObjectType::IMAGE_VIEW: return "DebugObjectType::IMAGE_VIEW";
            case stormkit::gpu::DebugObjectType::INSTANCE: return "DebugObjectType::INSTANCE";
            case stormkit::gpu::DebugObjectType::PHYSICAL_DEVICE:
                return "DebugObjectType::PHYSICAL_DEVICE";
            case stormkit::gpu::DebugObjectType::PIPELINE: return "DebugObjectType::PIPELINE";
            case stormkit::gpu::DebugObjectType::PIPELINE_CACHE:
                return "DebugObjectType::PIPELINE_CACHE";
            case stormkit::gpu::DebugObjectType::PIPELINE_LAYOUT:
                return "DebugObjectType::PIPELINE_LAYOUT";
            case stormkit::gpu::DebugObjectType::QUERY_POOL: return "DebugObjectType::QUERY_POOL";
            case stormkit::gpu::DebugObjectType::QUEUE: return "DebugObjectType::QUEUE";
            case stormkit::gpu::DebugObjectType::RENDER_PASS: return "DebugObjectType::RENDER_PASS";
            case stormkit::gpu::DebugObjectType::SAMPLER: return "DebugObjectType::SAMPLER";
            case stormkit::gpu::DebugObjectType::SEMAPHORE: return "DebugObjectType::SEMAPHORE";
            case stormkit::gpu::DebugObjectType::SHADER_MODULE:
                return "DebugObjectType::SHADER_MODULE";
            case stormkit::gpu::DebugObjectType::SURFACE: return "DebugObjectType::SURFACE";
            case stormkit::gpu::DebugObjectType::SWAPCHAIN: return "DebugObjectType::SWAPCHAIN";
            case stormkit::gpu::DebugObjectType::UNKNOWN: return "DebugObjectType::UNKNOWN";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::DependencyFlag)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::DependencyFlag>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::DependencyFlag::BY_REGION,
            stormkit::gpu::DependencyFlag::DEVICE_GROUP,
            stormkit::gpu::DependencyFlag::NONE,
            stormkit::gpu::DependencyFlag::VIEW_LOCAL,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<
      stormkit::gpu::DependencyFlag>(stormkit::gpu::DependencyFlag value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::DependencyFlag::BY_REGION: return "DependencyFlag::BY_REGION";
            case stormkit::gpu::DependencyFlag::DEVICE_GROUP: return "DependencyFlag::DEVICE_GROUP";
            case stormkit::gpu::DependencyFlag::NONE: return "DependencyFlag::NONE";
            case stormkit::gpu::DependencyFlag::VIEW_LOCAL: return "DependencyFlag::VIEW_LOCAL";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<
      stormkit::gpu::DependencyFlag>(stormkit::gpu::DependencyFlag value) noexcept -> std::string {
        switch (value) {
            case stormkit::gpu::DependencyFlag::BY_REGION: return "DependencyFlag::BY_REGION";
            case stormkit::gpu::DependencyFlag::DEVICE_GROUP: return "DependencyFlag::DEVICE_GROUP";
            case stormkit::gpu::DependencyFlag::NONE: return "DependencyFlag::NONE";
            case stormkit::gpu::DependencyFlag::VIEW_LOCAL: return "DependencyFlag::VIEW_LOCAL";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::DescriptorType)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::DescriptorType>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::DescriptorType::COMBINED_IMAGE_SAMPLER,
            stormkit::gpu::DescriptorType::INPUT_ATTACHMENT,
            stormkit::gpu::DescriptorType::SAMPLED_IMAGE,
            stormkit::gpu::DescriptorType::SAMPLER,
            stormkit::gpu::DescriptorType::STORAGE_BUFFER,
            stormkit::gpu::DescriptorType::STORAGE_BUFFER_DYNAMIC,
            stormkit::gpu::DescriptorType::STORAGE_IMAGE,
            stormkit::gpu::DescriptorType::STORAGE_TEXEL_BUFFER,
            stormkit::gpu::DescriptorType::UNIFORM_BUFFER,
            stormkit::gpu::DescriptorType::UNIFORM_BUFFER_DYNAMIC,
            stormkit::gpu::DescriptorType::UNIFORM_TEXEL_BUFFER,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<
      stormkit::gpu::DescriptorType>(stormkit::gpu::DescriptorType value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::DescriptorType::COMBINED_IMAGE_SAMPLER:
                return "DescriptorType::COMBINED_IMAGE_SAMPLER";
            case stormkit::gpu::DescriptorType::INPUT_ATTACHMENT:
                return "DescriptorType::INPUT_ATTACHMENT";
            case stormkit::gpu::DescriptorType::SAMPLED_IMAGE:
                return "DescriptorType::SAMPLED_IMAGE";
            case stormkit::gpu::DescriptorType::SAMPLER: return "DescriptorType::SAMPLER";
            case stormkit::gpu::DescriptorType::STORAGE_BUFFER:
                return "DescriptorType::STORAGE_BUFFER";
            case stormkit::gpu::DescriptorType::STORAGE_BUFFER_DYNAMIC:
                return "DescriptorType::STORAGE_BUFFER_DYNAMIC";
            case stormkit::gpu::DescriptorType::STORAGE_IMAGE:
                return "DescriptorType::STORAGE_IMAGE";
            case stormkit::gpu::DescriptorType::STORAGE_TEXEL_BUFFER:
                return "DescriptorType::STORAGE_TEXEL_BUFFER";
            case stormkit::gpu::DescriptorType::UNIFORM_BUFFER:
                return "DescriptorType::UNIFORM_BUFFER";
            case stormkit::gpu::DescriptorType::UNIFORM_BUFFER_DYNAMIC:
                return "DescriptorType::UNIFORM_BUFFER_DYNAMIC";
            case stormkit::gpu::DescriptorType::UNIFORM_TEXEL_BUFFER:
                return "DescriptorType::UNIFORM_TEXEL_BUFFER";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<
      stormkit::gpu::DescriptorType>(stormkit::gpu::DescriptorType value) noexcept -> std::string {
        switch (value) {
            case stormkit::gpu::DescriptorType::COMBINED_IMAGE_SAMPLER:
                return "DescriptorType::COMBINED_IMAGE_SAMPLER";
            case stormkit::gpu::DescriptorType::INPUT_ATTACHMENT:
                return "DescriptorType::INPUT_ATTACHMENT";
            case stormkit::gpu::DescriptorType::SAMPLED_IMAGE:
                return "DescriptorType::SAMPLED_IMAGE";
            case stormkit::gpu::DescriptorType::SAMPLER: return "DescriptorType::SAMPLER";
            case stormkit::gpu::DescriptorType::STORAGE_BUFFER:
                return "DescriptorType::STORAGE_BUFFER";
            case stormkit::gpu::DescriptorType::STORAGE_BUFFER_DYNAMIC:
                return "DescriptorType::STORAGE_BUFFER_DYNAMIC";
            case stormkit::gpu::DescriptorType::STORAGE_IMAGE:
                return "DescriptorType::STORAGE_IMAGE";
            case stormkit::gpu::DescriptorType::STORAGE_TEXEL_BUFFER:
                return "DescriptorType::STORAGE_TEXEL_BUFFER";
            case stormkit::gpu::DescriptorType::UNIFORM_BUFFER:
                return "DescriptorType::UNIFORM_BUFFER";
            case stormkit::gpu::DescriptorType::UNIFORM_BUFFER_DYNAMIC:
                return "DescriptorType::UNIFORM_BUFFER_DYNAMIC";
            case stormkit::gpu::DescriptorType::UNIFORM_TEXEL_BUFFER:
                return "DescriptorType::UNIFORM_TEXEL_BUFFER";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::DynamicState)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::DynamicState>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::DynamicState::BLEND_CONSTANTS,
            stormkit::gpu::DynamicState::DEPTH_BIAS,
            stormkit::gpu::DynamicState::DEPTH_BOUNDS,
            stormkit::gpu::DynamicState::LINE_WIDTH,
            stormkit::gpu::DynamicState::SCISSOR,
            stormkit::gpu::DynamicState::STENCIL_COMPARE_MASK,
            stormkit::gpu::DynamicState::STENCIL_REFERENCE,
            stormkit::gpu::DynamicState::STENCIL_WRITE_MASK,
            stormkit::gpu::DynamicState::VIEWPORT,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<
      stormkit::gpu::DynamicState>(stormkit::gpu::DynamicState value) noexcept -> std::string_view {
        switch (value) {
            case stormkit::gpu::DynamicState::BLEND_CONSTANTS:
                return "DynamicState::BLEND_CONSTANTS";
            case stormkit::gpu::DynamicState::DEPTH_BIAS: return "DynamicState::DEPTH_BIAS";
            case stormkit::gpu::DynamicState::DEPTH_BOUNDS: return "DynamicState::DEPTH_BOUNDS";
            case stormkit::gpu::DynamicState::LINE_WIDTH: return "DynamicState::LINE_WIDTH";
            case stormkit::gpu::DynamicState::SCISSOR: return "DynamicState::SCISSOR";
            case stormkit::gpu::DynamicState::STENCIL_COMPARE_MASK:
                return "DynamicState::STENCIL_COMPARE_MASK";
            case stormkit::gpu::DynamicState::STENCIL_REFERENCE:
                return "DynamicState::STENCIL_REFERENCE";
            case stormkit::gpu::DynamicState::STENCIL_WRITE_MASK:
                return "DynamicState::STENCIL_WRITE_MASK";
            case stormkit::gpu::DynamicState::VIEWPORT: return "DynamicState::VIEWPORT";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<
      stormkit::gpu::DynamicState>(stormkit::gpu::DynamicState value) noexcept -> std::string {
        switch (value) {
            case stormkit::gpu::DynamicState::BLEND_CONSTANTS:
                return "DynamicState::BLEND_CONSTANTS";
            case stormkit::gpu::DynamicState::DEPTH_BIAS: return "DynamicState::DEPTH_BIAS";
            case stormkit::gpu::DynamicState::DEPTH_BOUNDS: return "DynamicState::DEPTH_BOUNDS";
            case stormkit::gpu::DynamicState::LINE_WIDTH: return "DynamicState::LINE_WIDTH";
            case stormkit::gpu::DynamicState::SCISSOR: return "DynamicState::SCISSOR";
            case stormkit::gpu::DynamicState::STENCIL_COMPARE_MASK:
                return "DynamicState::STENCIL_COMPARE_MASK";
            case stormkit::gpu::DynamicState::STENCIL_REFERENCE:
                return "DynamicState::STENCIL_REFERENCE";
            case stormkit::gpu::DynamicState::STENCIL_WRITE_MASK:
                return "DynamicState::STENCIL_WRITE_MASK";
            case stormkit::gpu::DynamicState::VIEWPORT: return "DynamicState::VIEWPORT";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::Filter)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::Filter>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::Filter::CUBIC_IMG,
            stormkit::gpu::Filter::LINEAR,
            stormkit::gpu::Filter::NEAREST,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<stormkit::gpu::Filter>(stormkit::gpu::Filter
                                                                      value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::Filter::CUBIC_IMG: return "Filter::CUBIC_IMG";
            case stormkit::gpu::Filter::LINEAR: return "Filter::LINEAR";
            case stormkit::gpu::Filter::NEAREST: return "Filter::NEAREST";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<stormkit::gpu::Filter>(stormkit::gpu::Filter
                                                                      value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::Filter::CUBIC_IMG: return "Filter::CUBIC_IMG";
            case stormkit::gpu::Filter::LINEAR: return "Filter::LINEAR";
            case stormkit::gpu::Filter::NEAREST: return "Filter::NEAREST";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::FormatFeatureFlag)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::FormatFeatureFlag>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::FormatFeatureFlag::BLIT_DST,
            stormkit::gpu::FormatFeatureFlag::BLIT_SRC,
            stormkit::gpu::FormatFeatureFlag::COLOR_ATTACHMENT,
            stormkit::gpu::FormatFeatureFlag::COLOR_ATTACHMENT_BLEND,
            stormkit::gpu::FormatFeatureFlag::COSITED_CHROMA_SAMPLES,
            stormkit::gpu::FormatFeatureFlag::DEPTH_STENCIL_ATTACHMENT,
            stormkit::gpu::FormatFeatureFlag::DISJOINT,
            stormkit::gpu::FormatFeatureFlag::MIDPOINT_CHROMA_SAMPLES,
            stormkit::gpu::FormatFeatureFlag::SAMPLED_IMAGE,
            stormkit::gpu::FormatFeatureFlag::SAMPLED_IMAGE_FILTER_LINEAR,
            stormkit::gpu::FormatFeatureFlag::SAMPLED_IMAGE_FILTER_MINMAX,
            stormkit::gpu::FormatFeatureFlag::
              SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT,
            stormkit::gpu::FormatFeatureFlag::
              SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE,
            stormkit::gpu::FormatFeatureFlag::SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER,
            stormkit::gpu::FormatFeatureFlag::
              SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER,
            stormkit::gpu::FormatFeatureFlag::STORAGE_IMAGE,
            stormkit::gpu::FormatFeatureFlag::STORAGE_IMAGE_ATOMIC,
            stormkit::gpu::FormatFeatureFlag::STORAGE_TEXEL_BUFFER,
            stormkit::gpu::FormatFeatureFlag::STORAGE_TEXEL_BUFFER_ATOMIC,
            stormkit::gpu::FormatFeatureFlag::TRANSFER_DST,
            stormkit::gpu::FormatFeatureFlag::TRANSFER_SRC,
            stormkit::gpu::FormatFeatureFlag::UNIFORM_TEXEL_BUFFER,
            stormkit::gpu::FormatFeatureFlag::VERTEX_BUFFER,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<
      stormkit::gpu::FormatFeatureFlag>(stormkit::gpu::FormatFeatureFlag value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::FormatFeatureFlag::BLIT_DST: return "FormatFeatureFlag::BLIT_DST";
            case stormkit::gpu::FormatFeatureFlag::BLIT_SRC: return "FormatFeatureFlag::BLIT_SRC";
            case stormkit::gpu::FormatFeatureFlag::COLOR_ATTACHMENT:
                return "FormatFeatureFlag::COLOR_ATTACHMENT";
            case stormkit::gpu::FormatFeatureFlag::COLOR_ATTACHMENT_BLEND:
                return "FormatFeatureFlag::COLOR_ATTACHMENT_BLEND";
            case stormkit::gpu::FormatFeatureFlag::COSITED_CHROMA_SAMPLES:
                return "FormatFeatureFlag::COSITED_CHROMA_SAMPLES";
            case stormkit::gpu::FormatFeatureFlag::DEPTH_STENCIL_ATTACHMENT:
                return "FormatFeatureFlag::DEPTH_STENCIL_ATTACHMENT";
            case stormkit::gpu::FormatFeatureFlag::DISJOINT: return "FormatFeatureFlag::DISJOINT";
            case stormkit::gpu::FormatFeatureFlag::MIDPOINT_CHROMA_SAMPLES:
                return "FormatFeatureFlag::MIDPOINT_CHROMA_SAMPLES";
            case stormkit::gpu::FormatFeatureFlag::SAMPLED_IMAGE:
                return "FormatFeatureFlag::SAMPLED_IMAGE";
            case stormkit::gpu::FormatFeatureFlag::SAMPLED_IMAGE_FILTER_LINEAR:
                return "FormatFeatureFlag::SAMPLED_IMAGE_FILTER_LINEAR";
            case stormkit::gpu::FormatFeatureFlag::SAMPLED_IMAGE_FILTER_MINMAX:
                return "FormatFeatureFlag::SAMPLED_IMAGE_FILTER_MINMAX";
            case stormkit::gpu::FormatFeatureFlag::
              SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT:
                return "FormatFeatureFlag::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_"
                       "EXPLICIT";
            case stormkit::gpu::FormatFeatureFlag::
              SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE:
                return "FormatFeatureFlag::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_"
                       "EXPLICIT_FORCEABLE";
            case stormkit::gpu::FormatFeatureFlag::SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER:
                return "FormatFeatureFlag::SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER";
            case stormkit::gpu::FormatFeatureFlag::
              SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER:
                return "FormatFeatureFlag::SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_"
                       "FILTER";
            case stormkit::gpu::FormatFeatureFlag::STORAGE_IMAGE:
                return "FormatFeatureFlag::STORAGE_IMAGE";
            case stormkit::gpu::FormatFeatureFlag::STORAGE_IMAGE_ATOMIC:
                return "FormatFeatureFlag::STORAGE_IMAGE_ATOMIC";
            case stormkit::gpu::FormatFeatureFlag::STORAGE_TEXEL_BUFFER:
                return "FormatFeatureFlag::STORAGE_TEXEL_BUFFER";
            case stormkit::gpu::FormatFeatureFlag::STORAGE_TEXEL_BUFFER_ATOMIC:
                return "FormatFeatureFlag::STORAGE_TEXEL_BUFFER_ATOMIC";
            case stormkit::gpu::FormatFeatureFlag::TRANSFER_DST:
                return "FormatFeatureFlag::TRANSFER_DST";
            case stormkit::gpu::FormatFeatureFlag::TRANSFER_SRC:
                return "FormatFeatureFlag::TRANSFER_SRC";
            case stormkit::gpu::FormatFeatureFlag::UNIFORM_TEXEL_BUFFER:
                return "FormatFeatureFlag::UNIFORM_TEXEL_BUFFER";
            case stormkit::gpu::FormatFeatureFlag::VERTEX_BUFFER:
                return "FormatFeatureFlag::VERTEX_BUFFER";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<
      stormkit::gpu::FormatFeatureFlag>(stormkit::gpu::FormatFeatureFlag value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::FormatFeatureFlag::BLIT_DST: return "FormatFeatureFlag::BLIT_DST";
            case stormkit::gpu::FormatFeatureFlag::BLIT_SRC: return "FormatFeatureFlag::BLIT_SRC";
            case stormkit::gpu::FormatFeatureFlag::COLOR_ATTACHMENT:
                return "FormatFeatureFlag::COLOR_ATTACHMENT";
            case stormkit::gpu::FormatFeatureFlag::COLOR_ATTACHMENT_BLEND:
                return "FormatFeatureFlag::COLOR_ATTACHMENT_BLEND";
            case stormkit::gpu::FormatFeatureFlag::COSITED_CHROMA_SAMPLES:
                return "FormatFeatureFlag::COSITED_CHROMA_SAMPLES";
            case stormkit::gpu::FormatFeatureFlag::DEPTH_STENCIL_ATTACHMENT:
                return "FormatFeatureFlag::DEPTH_STENCIL_ATTACHMENT";
            case stormkit::gpu::FormatFeatureFlag::DISJOINT: return "FormatFeatureFlag::DISJOINT";
            case stormkit::gpu::FormatFeatureFlag::MIDPOINT_CHROMA_SAMPLES:
                return "FormatFeatureFlag::MIDPOINT_CHROMA_SAMPLES";
            case stormkit::gpu::FormatFeatureFlag::SAMPLED_IMAGE:
                return "FormatFeatureFlag::SAMPLED_IMAGE";
            case stormkit::gpu::FormatFeatureFlag::SAMPLED_IMAGE_FILTER_LINEAR:
                return "FormatFeatureFlag::SAMPLED_IMAGE_FILTER_LINEAR";
            case stormkit::gpu::FormatFeatureFlag::SAMPLED_IMAGE_FILTER_MINMAX:
                return "FormatFeatureFlag::SAMPLED_IMAGE_FILTER_MINMAX";
            case stormkit::gpu::FormatFeatureFlag::
              SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT:
                return "FormatFeatureFlag::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_"
                       "EXPLICIT";
            case stormkit::gpu::FormatFeatureFlag::
              SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE:
                return "FormatFeatureFlag::SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_"
                       "EXPLICIT_FORCEABLE";
            case stormkit::gpu::FormatFeatureFlag::SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER:
                return "FormatFeatureFlag::SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER";
            case stormkit::gpu::FormatFeatureFlag::
              SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER:
                return "FormatFeatureFlag::SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_"
                       "FILTER";
            case stormkit::gpu::FormatFeatureFlag::STORAGE_IMAGE:
                return "FormatFeatureFlag::STORAGE_IMAGE";
            case stormkit::gpu::FormatFeatureFlag::STORAGE_IMAGE_ATOMIC:
                return "FormatFeatureFlag::STORAGE_IMAGE_ATOMIC";
            case stormkit::gpu::FormatFeatureFlag::STORAGE_TEXEL_BUFFER:
                return "FormatFeatureFlag::STORAGE_TEXEL_BUFFER";
            case stormkit::gpu::FormatFeatureFlag::STORAGE_TEXEL_BUFFER_ATOMIC:
                return "FormatFeatureFlag::STORAGE_TEXEL_BUFFER_ATOMIC";
            case stormkit::gpu::FormatFeatureFlag::TRANSFER_DST:
                return "FormatFeatureFlag::TRANSFER_DST";
            case stormkit::gpu::FormatFeatureFlag::TRANSFER_SRC:
                return "FormatFeatureFlag::TRANSFER_SRC";
            case stormkit::gpu::FormatFeatureFlag::UNIFORM_TEXEL_BUFFER:
                return "FormatFeatureFlag::UNIFORM_TEXEL_BUFFER";
            case stormkit::gpu::FormatFeatureFlag::VERTEX_BUFFER:
                return "FormatFeatureFlag::VERTEX_BUFFER";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::FrontFace)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::FrontFace>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::FrontFace::CLOCKWISE,
            stormkit::gpu::FrontFace::COUNTER_CLOCKWISE,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<stormkit::gpu::FrontFace>(stormkit::gpu::FrontFace
                                                                         value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::FrontFace::CLOCKWISE: return "FrontFace::CLOCKWISE";
            case stormkit::gpu::FrontFace::COUNTER_CLOCKWISE: return "FrontFace::COUNTER_CLOCKWISE";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<stormkit::gpu::FrontFace>(stormkit::gpu::FrontFace
                                                                         value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::FrontFace::CLOCKWISE: return "FrontFace::CLOCKWISE";
            case stormkit::gpu::FrontFace::COUNTER_CLOCKWISE: return "FrontFace::COUNTER_CLOCKWISE";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::GeometryFlag)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::GeometryFlag>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::GeometryFlag::NO_DUPLICATE_ANY_HIT_INVOCATION,
            stormkit::gpu::GeometryFlag::OPAQUE,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<
      stormkit::gpu::GeometryFlag>(stormkit::gpu::GeometryFlag value) noexcept -> std::string_view {
        switch (value) {
            case stormkit::gpu::GeometryFlag::NO_DUPLICATE_ANY_HIT_INVOCATION:
                return "GeometryFlag::NO_DUPLICATE_ANY_HIT_INVOCATION";
            case stormkit::gpu::GeometryFlag::OPAQUE: return "GeometryFlag::OPAQUE";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<
      stormkit::gpu::GeometryFlag>(stormkit::gpu::GeometryFlag value) noexcept -> std::string {
        switch (value) {
            case stormkit::gpu::GeometryFlag::NO_DUPLICATE_ANY_HIT_INVOCATION:
                return "GeometryFlag::NO_DUPLICATE_ANY_HIT_INVOCATION";
            case stormkit::gpu::GeometryFlag::OPAQUE: return "GeometryFlag::OPAQUE";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::GeometryType)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::GeometryType>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::GeometryType::AABBS,
            stormkit::gpu::GeometryType::INSTANCES,
            stormkit::gpu::GeometryType::TRIANGLES,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<
      stormkit::gpu::GeometryType>(stormkit::gpu::GeometryType value) noexcept -> std::string_view {
        switch (value) {
            case stormkit::gpu::GeometryType::AABBS: return "GeometryType::AABBS";
            case stormkit::gpu::GeometryType::INSTANCES: return "GeometryType::INSTANCES";
            case stormkit::gpu::GeometryType::TRIANGLES: return "GeometryType::TRIANGLES";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<
      stormkit::gpu::GeometryType>(stormkit::gpu::GeometryType value) noexcept -> std::string {
        switch (value) {
            case stormkit::gpu::GeometryType::AABBS: return "GeometryType::AABBS";
            case stormkit::gpu::GeometryType::INSTANCES: return "GeometryType::INSTANCES";
            case stormkit::gpu::GeometryType::TRIANGLES: return "GeometryType::TRIANGLES";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::ImageAspectFlag)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::ImageAspectFlag>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::ImageAspectFlag::COLOR,
            stormkit::gpu::ImageAspectFlag::DEPTH,
            stormkit::gpu::ImageAspectFlag::NONE,
            stormkit::gpu::ImageAspectFlag::STENCIL,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<
      stormkit::gpu::ImageAspectFlag>(stormkit::gpu::ImageAspectFlag value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::ImageAspectFlag::COLOR: return "ImageAspectFlag::COLOR";
            case stormkit::gpu::ImageAspectFlag::DEPTH: return "ImageAspectFlag::DEPTH";
            case stormkit::gpu::ImageAspectFlag::NONE: return "ImageAspectFlag::NONE";
            case stormkit::gpu::ImageAspectFlag::STENCIL: return "ImageAspectFlag::STENCIL";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<
      stormkit::gpu::ImageAspectFlag>(stormkit::gpu::ImageAspectFlag value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::ImageAspectFlag::COLOR: return "ImageAspectFlag::COLOR";
            case stormkit::gpu::ImageAspectFlag::DEPTH: return "ImageAspectFlag::DEPTH";
            case stormkit::gpu::ImageAspectFlag::NONE: return "ImageAspectFlag::NONE";
            case stormkit::gpu::ImageAspectFlag::STENCIL: return "ImageAspectFlag::STENCIL";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::ImageCreateFlag)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::ImageCreateFlag>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::ImageCreateFlag::ALIAS,
            stormkit::gpu::ImageCreateFlag::ARRAY_2D_COMPATIBLE,
            stormkit::gpu::ImageCreateFlag::BLOCK_TEXEL_VIEW_COMPATIBLE,
            stormkit::gpu::ImageCreateFlag::CUBE_COMPATIBLE,
            stormkit::gpu::ImageCreateFlag::DISJOINT,
            stormkit::gpu::ImageCreateFlag::EXTENDED_USAGE,
            stormkit::gpu::ImageCreateFlag::MUTABLE_FORMAT,
            stormkit::gpu::ImageCreateFlag::NONE,
            stormkit::gpu::ImageCreateFlag::PROTECTED,
            stormkit::gpu::ImageCreateFlag::SPARSE_ALIASED,
            stormkit::gpu::ImageCreateFlag::SPARSE_BINDING,
            stormkit::gpu::ImageCreateFlag::SPARSE_RESIDENCY,
            stormkit::gpu::ImageCreateFlag::SPLIT_INSTANCE_BIND_REGIONS,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<
      stormkit::gpu::ImageCreateFlag>(stormkit::gpu::ImageCreateFlag value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::ImageCreateFlag::ALIAS: return "ImageCreateFlag::ALIAS";
            case stormkit::gpu::ImageCreateFlag::ARRAY_2D_COMPATIBLE:
                return "ImageCreateFlag::ARRAY_2D_COMPATIBLE";
            case stormkit::gpu::ImageCreateFlag::BLOCK_TEXEL_VIEW_COMPATIBLE:
                return "ImageCreateFlag::BLOCK_TEXEL_VIEW_COMPATIBLE";
            case stormkit::gpu::ImageCreateFlag::CUBE_COMPATIBLE:
                return "ImageCreateFlag::CUBE_COMPATIBLE";
            case stormkit::gpu::ImageCreateFlag::DISJOINT: return "ImageCreateFlag::DISJOINT";
            case stormkit::gpu::ImageCreateFlag::EXTENDED_USAGE:
                return "ImageCreateFlag::EXTENDED_USAGE";
            case stormkit::gpu::ImageCreateFlag::MUTABLE_FORMAT:
                return "ImageCreateFlag::MUTABLE_FORMAT";
            case stormkit::gpu::ImageCreateFlag::NONE: return "ImageCreateFlag::NONE";
            case stormkit::gpu::ImageCreateFlag::PROTECTED: return "ImageCreateFlag::PROTECTED";
            case stormkit::gpu::ImageCreateFlag::SPARSE_ALIASED:
                return "ImageCreateFlag::SPARSE_ALIASED";
            case stormkit::gpu::ImageCreateFlag::SPARSE_BINDING:
                return "ImageCreateFlag::SPARSE_BINDING";
            case stormkit::gpu::ImageCreateFlag::SPARSE_RESIDENCY:
                return "ImageCreateFlag::SPARSE_RESIDENCY";
            case stormkit::gpu::ImageCreateFlag::SPLIT_INSTANCE_BIND_REGIONS:
                return "ImageCreateFlag::SPLIT_INSTANCE_BIND_REGIONS";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<
      stormkit::gpu::ImageCreateFlag>(stormkit::gpu::ImageCreateFlag value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::ImageCreateFlag::ALIAS: return "ImageCreateFlag::ALIAS";
            case stormkit::gpu::ImageCreateFlag::ARRAY_2D_COMPATIBLE:
                return "ImageCreateFlag::ARRAY_2D_COMPATIBLE";
            case stormkit::gpu::ImageCreateFlag::BLOCK_TEXEL_VIEW_COMPATIBLE:
                return "ImageCreateFlag::BLOCK_TEXEL_VIEW_COMPATIBLE";
            case stormkit::gpu::ImageCreateFlag::CUBE_COMPATIBLE:
                return "ImageCreateFlag::CUBE_COMPATIBLE";
            case stormkit::gpu::ImageCreateFlag::DISJOINT: return "ImageCreateFlag::DISJOINT";
            case stormkit::gpu::ImageCreateFlag::EXTENDED_USAGE:
                return "ImageCreateFlag::EXTENDED_USAGE";
            case stormkit::gpu::ImageCreateFlag::MUTABLE_FORMAT:
                return "ImageCreateFlag::MUTABLE_FORMAT";
            case stormkit::gpu::ImageCreateFlag::NONE: return "ImageCreateFlag::NONE";
            case stormkit::gpu::ImageCreateFlag::PROTECTED: return "ImageCreateFlag::PROTECTED";
            case stormkit::gpu::ImageCreateFlag::SPARSE_ALIASED:
                return "ImageCreateFlag::SPARSE_ALIASED";
            case stormkit::gpu::ImageCreateFlag::SPARSE_BINDING:
                return "ImageCreateFlag::SPARSE_BINDING";
            case stormkit::gpu::ImageCreateFlag::SPARSE_RESIDENCY:
                return "ImageCreateFlag::SPARSE_RESIDENCY";
            case stormkit::gpu::ImageCreateFlag::SPLIT_INSTANCE_BIND_REGIONS:
                return "ImageCreateFlag::SPLIT_INSTANCE_BIND_REGIONS";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::ImageLayout)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::ImageLayout>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::ImageLayout::COLOR_ATTACHMENT_OPTIMAL,
            stormkit::gpu::ImageLayout::DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL,
            stormkit::gpu::ImageLayout::DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL,
            stormkit::gpu::ImageLayout::DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
            stormkit::gpu::ImageLayout::DEPTH_STENCIL_READ_ONLY_OPTIMAL,
            stormkit::gpu::ImageLayout::GENERAL,
            stormkit::gpu::ImageLayout::PREINITIALIZED,
            stormkit::gpu::ImageLayout::PRESENT_SRC,
            stormkit::gpu::ImageLayout::SHADER_READ_ONLY_OPTIMAL,
            stormkit::gpu::ImageLayout::SHARED_PRESENT,
            stormkit::gpu::ImageLayout::TRANSFER_DST_OPTIMAL,
            stormkit::gpu::ImageLayout::TRANSFER_SRC_OPTIMAL,
            stormkit::gpu::ImageLayout::UNDEFINED,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<stormkit::gpu::ImageLayout>(stormkit::gpu::ImageLayout
                                                                           value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::ImageLayout::COLOR_ATTACHMENT_OPTIMAL:
                return "ImageLayout::COLOR_ATTACHMENT_OPTIMAL";
            case stormkit::gpu::ImageLayout::DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL:
                return "ImageLayout::DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL";
            case stormkit::gpu::ImageLayout::DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL:
                return "ImageLayout::DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL";
            case stormkit::gpu::ImageLayout::DEPTH_STENCIL_ATTACHMENT_OPTIMAL:
                return "ImageLayout::DEPTH_STENCIL_ATTACHMENT_OPTIMAL";
            case stormkit::gpu::ImageLayout::DEPTH_STENCIL_READ_ONLY_OPTIMAL:
                return "ImageLayout::DEPTH_STENCIL_READ_ONLY_OPTIMAL";
            case stormkit::gpu::ImageLayout::GENERAL: return "ImageLayout::GENERAL";
            case stormkit::gpu::ImageLayout::PREINITIALIZED: return "ImageLayout::PREINITIALIZED";
            case stormkit::gpu::ImageLayout::PRESENT_SRC: return "ImageLayout::PRESENT_SRC";
            case stormkit::gpu::ImageLayout::SHADER_READ_ONLY_OPTIMAL:
                return "ImageLayout::SHADER_READ_ONLY_OPTIMAL";
            case stormkit::gpu::ImageLayout::SHARED_PRESENT: return "ImageLayout::SHARED_PRESENT";
            case stormkit::gpu::ImageLayout::TRANSFER_DST_OPTIMAL:
                return "ImageLayout::TRANSFER_DST_OPTIMAL";
            case stormkit::gpu::ImageLayout::TRANSFER_SRC_OPTIMAL:
                return "ImageLayout::TRANSFER_SRC_OPTIMAL";
            case stormkit::gpu::ImageLayout::UNDEFINED: return "ImageLayout::UNDEFINED";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<stormkit::gpu::ImageLayout>(stormkit::gpu::ImageLayout
                                                                           value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::ImageLayout::COLOR_ATTACHMENT_OPTIMAL:
                return "ImageLayout::COLOR_ATTACHMENT_OPTIMAL";
            case stormkit::gpu::ImageLayout::DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL:
                return "ImageLayout::DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL";
            case stormkit::gpu::ImageLayout::DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL:
                return "ImageLayout::DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL";
            case stormkit::gpu::ImageLayout::DEPTH_STENCIL_ATTACHMENT_OPTIMAL:
                return "ImageLayout::DEPTH_STENCIL_ATTACHMENT_OPTIMAL";
            case stormkit::gpu::ImageLayout::DEPTH_STENCIL_READ_ONLY_OPTIMAL:
                return "ImageLayout::DEPTH_STENCIL_READ_ONLY_OPTIMAL";
            case stormkit::gpu::ImageLayout::GENERAL: return "ImageLayout::GENERAL";
            case stormkit::gpu::ImageLayout::PREINITIALIZED: return "ImageLayout::PREINITIALIZED";
            case stormkit::gpu::ImageLayout::PRESENT_SRC: return "ImageLayout::PRESENT_SRC";
            case stormkit::gpu::ImageLayout::SHADER_READ_ONLY_OPTIMAL:
                return "ImageLayout::SHADER_READ_ONLY_OPTIMAL";
            case stormkit::gpu::ImageLayout::SHARED_PRESENT: return "ImageLayout::SHARED_PRESENT";
            case stormkit::gpu::ImageLayout::TRANSFER_DST_OPTIMAL:
                return "ImageLayout::TRANSFER_DST_OPTIMAL";
            case stormkit::gpu::ImageLayout::TRANSFER_SRC_OPTIMAL:
                return "ImageLayout::TRANSFER_SRC_OPTIMAL";
            case stormkit::gpu::ImageLayout::UNDEFINED: return "ImageLayout::UNDEFINED";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::ImageTiling)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::ImageTiling>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::ImageTiling::LINEAR,
            stormkit::gpu::ImageTiling::OPTIMAL,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<stormkit::gpu::ImageTiling>(stormkit::gpu::ImageTiling
                                                                           value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::ImageTiling::LINEAR: return "ImageTiling::LINEAR";
            case stormkit::gpu::ImageTiling::OPTIMAL: return "ImageTiling::OPTIMAL";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<stormkit::gpu::ImageTiling>(stormkit::gpu::ImageTiling
                                                                           value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::ImageTiling::LINEAR: return "ImageTiling::LINEAR";
            case stormkit::gpu::ImageTiling::OPTIMAL: return "ImageTiling::OPTIMAL";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::ImageType)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::ImageType>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::ImageType::T1D,
            stormkit::gpu::ImageType::T2D,
            stormkit::gpu::ImageType::T3D,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<stormkit::gpu::ImageType>(stormkit::gpu::ImageType
                                                                         value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::ImageType::T1D: return "ImageType::T1D";
            case stormkit::gpu::ImageType::T2D: return "ImageType::T2D";
            case stormkit::gpu::ImageType::T3D: return "ImageType::T3D";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<stormkit::gpu::ImageType>(stormkit::gpu::ImageType
                                                                         value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::ImageType::T1D: return "ImageType::T1D";
            case stormkit::gpu::ImageType::T2D: return "ImageType::T2D";
            case stormkit::gpu::ImageType::T3D: return "ImageType::T3D";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::ImageUsageFlag)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::ImageUsageFlag>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::ImageUsageFlag::COLOR_ATTACHMENT,
            stormkit::gpu::ImageUsageFlag::DEPTH_STENCIL_ATTACHMENT,
            stormkit::gpu::ImageUsageFlag::INPUT_ATTACHMENT,
            stormkit::gpu::ImageUsageFlag::SAMPLED,
            stormkit::gpu::ImageUsageFlag::STORAGE,
            stormkit::gpu::ImageUsageFlag::TRANSFER_DST,
            stormkit::gpu::ImageUsageFlag::TRANSFER_SRC,
            stormkit::gpu::ImageUsageFlag::TRANSIENT_ATTACHMENT,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<
      stormkit::gpu::ImageUsageFlag>(stormkit::gpu::ImageUsageFlag value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::ImageUsageFlag::COLOR_ATTACHMENT:
                return "ImageUsageFlag::COLOR_ATTACHMENT";
            case stormkit::gpu::ImageUsageFlag::DEPTH_STENCIL_ATTACHMENT:
                return "ImageUsageFlag::DEPTH_STENCIL_ATTACHMENT";
            case stormkit::gpu::ImageUsageFlag::INPUT_ATTACHMENT:
                return "ImageUsageFlag::INPUT_ATTACHMENT";
            case stormkit::gpu::ImageUsageFlag::SAMPLED: return "ImageUsageFlag::SAMPLED";
            case stormkit::gpu::ImageUsageFlag::STORAGE: return "ImageUsageFlag::STORAGE";
            case stormkit::gpu::ImageUsageFlag::TRANSFER_DST: return "ImageUsageFlag::TRANSFER_DST";
            case stormkit::gpu::ImageUsageFlag::TRANSFER_SRC: return "ImageUsageFlag::TRANSFER_SRC";
            case stormkit::gpu::ImageUsageFlag::TRANSIENT_ATTACHMENT:
                return "ImageUsageFlag::TRANSIENT_ATTACHMENT";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<
      stormkit::gpu::ImageUsageFlag>(stormkit::gpu::ImageUsageFlag value) noexcept -> std::string {
        switch (value) {
            case stormkit::gpu::ImageUsageFlag::COLOR_ATTACHMENT:
                return "ImageUsageFlag::COLOR_ATTACHMENT";
            case stormkit::gpu::ImageUsageFlag::DEPTH_STENCIL_ATTACHMENT:
                return "ImageUsageFlag::DEPTH_STENCIL_ATTACHMENT";
            case stormkit::gpu::ImageUsageFlag::INPUT_ATTACHMENT:
                return "ImageUsageFlag::INPUT_ATTACHMENT";
            case stormkit::gpu::ImageUsageFlag::SAMPLED: return "ImageUsageFlag::SAMPLED";
            case stormkit::gpu::ImageUsageFlag::STORAGE: return "ImageUsageFlag::STORAGE";
            case stormkit::gpu::ImageUsageFlag::TRANSFER_DST: return "ImageUsageFlag::TRANSFER_DST";
            case stormkit::gpu::ImageUsageFlag::TRANSFER_SRC: return "ImageUsageFlag::TRANSFER_SRC";
            case stormkit::gpu::ImageUsageFlag::TRANSIENT_ATTACHMENT:
                return "ImageUsageFlag::TRANSIENT_ATTACHMENT";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::ImageViewType)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::ImageViewType>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::ImageViewType::CUBE, stormkit::gpu::ImageViewType::CUBE_ARRAY,
            stormkit::gpu::ImageViewType::T1D,  stormkit::gpu::ImageViewType::T1D_ARRAY,
            stormkit::gpu::ImageViewType::T2D,  stormkit::gpu::ImageViewType::T2D_ARRAY,
            stormkit::gpu::ImageViewType::T3D,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<
      stormkit::gpu::ImageViewType>(stormkit::gpu::ImageViewType value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::ImageViewType::CUBE: return "ImageViewType::CUBE";
            case stormkit::gpu::ImageViewType::CUBE_ARRAY: return "ImageViewType::CUBE_ARRAY";
            case stormkit::gpu::ImageViewType::T1D: return "ImageViewType::T1D";
            case stormkit::gpu::ImageViewType::T1D_ARRAY: return "ImageViewType::T1D_ARRAY";
            case stormkit::gpu::ImageViewType::T2D: return "ImageViewType::T2D";
            case stormkit::gpu::ImageViewType::T2D_ARRAY: return "ImageViewType::T2D_ARRAY";
            case stormkit::gpu::ImageViewType::T3D: return "ImageViewType::T3D";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<
      stormkit::gpu::ImageViewType>(stormkit::gpu::ImageViewType value) noexcept -> std::string {
        switch (value) {
            case stormkit::gpu::ImageViewType::CUBE: return "ImageViewType::CUBE";
            case stormkit::gpu::ImageViewType::CUBE_ARRAY: return "ImageViewType::CUBE_ARRAY";
            case stormkit::gpu::ImageViewType::T1D: return "ImageViewType::T1D";
            case stormkit::gpu::ImageViewType::T1D_ARRAY: return "ImageViewType::T1D_ARRAY";
            case stormkit::gpu::ImageViewType::T2D: return "ImageViewType::T2D";
            case stormkit::gpu::ImageViewType::T2D_ARRAY: return "ImageViewType::T2D_ARRAY";
            case stormkit::gpu::ImageViewType::T3D: return "ImageViewType::T3D";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::LogicOperation)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::LogicOperation>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::LogicOperation::AND,
            stormkit::gpu::LogicOperation::AND_INVERTED,
            stormkit::gpu::LogicOperation::AND_REVERSE,
            stormkit::gpu::LogicOperation::CLEAR,
            stormkit::gpu::LogicOperation::COPY,
            stormkit::gpu::LogicOperation::COPY_INVERTED,
            stormkit::gpu::LogicOperation::EQUIVALENT,
            stormkit::gpu::LogicOperation::INVERT,
            stormkit::gpu::LogicOperation::NAND,
            stormkit::gpu::LogicOperation::NO_OP,
            stormkit::gpu::LogicOperation::NOR,
            stormkit::gpu::LogicOperation::OR,
            stormkit::gpu::LogicOperation::OR_INVERTED,
            stormkit::gpu::LogicOperation::OR_REVERSE,
            stormkit::gpu::LogicOperation::SET,
            stormkit::gpu::LogicOperation::XOR,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<
      stormkit::gpu::LogicOperation>(stormkit::gpu::LogicOperation value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::LogicOperation::AND: return "LogicOperation::AND";
            case stormkit::gpu::LogicOperation::AND_INVERTED: return "LogicOperation::AND_INVERTED";
            case stormkit::gpu::LogicOperation::AND_REVERSE: return "LogicOperation::AND_REVERSE";
            case stormkit::gpu::LogicOperation::CLEAR: return "LogicOperation::CLEAR";
            case stormkit::gpu::LogicOperation::COPY: return "LogicOperation::COPY";
            case stormkit::gpu::LogicOperation::COPY_INVERTED:
                return "LogicOperation::COPY_INVERTED";
            case stormkit::gpu::LogicOperation::EQUIVALENT: return "LogicOperation::EQUIVALENT";
            case stormkit::gpu::LogicOperation::INVERT: return "LogicOperation::INVERT";
            case stormkit::gpu::LogicOperation::NAND: return "LogicOperation::NAND";
            case stormkit::gpu::LogicOperation::NO_OP: return "LogicOperation::NO_OP";
            case stormkit::gpu::LogicOperation::NOR: return "LogicOperation::NOR";
            case stormkit::gpu::LogicOperation::OR: return "LogicOperation::OR";
            case stormkit::gpu::LogicOperation::OR_INVERTED: return "LogicOperation::OR_INVERTED";
            case stormkit::gpu::LogicOperation::OR_REVERSE: return "LogicOperation::OR_REVERSE";
            case stormkit::gpu::LogicOperation::SET: return "LogicOperation::SET";
            case stormkit::gpu::LogicOperation::XOR: return "LogicOperation::XOR";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<
      stormkit::gpu::LogicOperation>(stormkit::gpu::LogicOperation value) noexcept -> std::string {
        switch (value) {
            case stormkit::gpu::LogicOperation::AND: return "LogicOperation::AND";
            case stormkit::gpu::LogicOperation::AND_INVERTED: return "LogicOperation::AND_INVERTED";
            case stormkit::gpu::LogicOperation::AND_REVERSE: return "LogicOperation::AND_REVERSE";
            case stormkit::gpu::LogicOperation::CLEAR: return "LogicOperation::CLEAR";
            case stormkit::gpu::LogicOperation::COPY: return "LogicOperation::COPY";
            case stormkit::gpu::LogicOperation::COPY_INVERTED:
                return "LogicOperation::COPY_INVERTED";
            case stormkit::gpu::LogicOperation::EQUIVALENT: return "LogicOperation::EQUIVALENT";
            case stormkit::gpu::LogicOperation::INVERT: return "LogicOperation::INVERT";
            case stormkit::gpu::LogicOperation::NAND: return "LogicOperation::NAND";
            case stormkit::gpu::LogicOperation::NO_OP: return "LogicOperation::NO_OP";
            case stormkit::gpu::LogicOperation::NOR: return "LogicOperation::NOR";
            case stormkit::gpu::LogicOperation::OR: return "LogicOperation::OR";
            case stormkit::gpu::LogicOperation::OR_INVERTED: return "LogicOperation::OR_INVERTED";
            case stormkit::gpu::LogicOperation::OR_REVERSE: return "LogicOperation::OR_REVERSE";
            case stormkit::gpu::LogicOperation::SET: return "LogicOperation::SET";
            case stormkit::gpu::LogicOperation::XOR: return "LogicOperation::XOR";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::MemoryPropertyFlag)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::MemoryPropertyFlag>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::MemoryPropertyFlag::DEVICE_LOCAL,
            stormkit::gpu::MemoryPropertyFlag::HOST_CACHED,
            stormkit::gpu::MemoryPropertyFlag::HOST_COHERENT,
            stormkit::gpu::MemoryPropertyFlag::HOST_VISIBLE,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<
      stormkit::gpu::MemoryPropertyFlag>(stormkit::gpu::MemoryPropertyFlag value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::MemoryPropertyFlag::DEVICE_LOCAL:
                return "MemoryPropertyFlag::DEVICE_LOCAL";
            case stormkit::gpu::MemoryPropertyFlag::HOST_CACHED:
                return "MemoryPropertyFlag::HOST_CACHED";
            case stormkit::gpu::MemoryPropertyFlag::HOST_COHERENT:
                return "MemoryPropertyFlag::HOST_COHERENT";
            case stormkit::gpu::MemoryPropertyFlag::HOST_VISIBLE:
                return "MemoryPropertyFlag::HOST_VISIBLE";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<
      stormkit::gpu::MemoryPropertyFlag>(stormkit::gpu::MemoryPropertyFlag value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::MemoryPropertyFlag::DEVICE_LOCAL:
                return "MemoryPropertyFlag::DEVICE_LOCAL";
            case stormkit::gpu::MemoryPropertyFlag::HOST_CACHED:
                return "MemoryPropertyFlag::HOST_CACHED";
            case stormkit::gpu::MemoryPropertyFlag::HOST_COHERENT:
                return "MemoryPropertyFlag::HOST_COHERENT";
            case stormkit::gpu::MemoryPropertyFlag::HOST_VISIBLE:
                return "MemoryPropertyFlag::HOST_VISIBLE";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::PhysicalDeviceType)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::PhysicalDeviceType>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::PhysicalDeviceType::CPU,
            stormkit::gpu::PhysicalDeviceType::DISCRETE_GPU,
            stormkit::gpu::PhysicalDeviceType::INTEGRATED_GPU,
            stormkit::gpu::PhysicalDeviceType::OTHER,
            stormkit::gpu::PhysicalDeviceType::VIRTUAL_GPU,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<
      stormkit::gpu::PhysicalDeviceType>(stormkit::gpu::PhysicalDeviceType value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::PhysicalDeviceType::CPU: return "PhysicalDeviceType::CPU";
            case stormkit::gpu::PhysicalDeviceType::DISCRETE_GPU:
                return "PhysicalDeviceType::DISCRETE_GPU";
            case stormkit::gpu::PhysicalDeviceType::INTEGRATED_GPU:
                return "PhysicalDeviceType::INTEGRATED_GPU";
            case stormkit::gpu::PhysicalDeviceType::OTHER: return "PhysicalDeviceType::OTHER";
            case stormkit::gpu::PhysicalDeviceType::VIRTUAL_GPU:
                return "PhysicalDeviceType::VIRTUAL_GPU";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<
      stormkit::gpu::PhysicalDeviceType>(stormkit::gpu::PhysicalDeviceType value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::PhysicalDeviceType::CPU: return "PhysicalDeviceType::CPU";
            case stormkit::gpu::PhysicalDeviceType::DISCRETE_GPU:
                return "PhysicalDeviceType::DISCRETE_GPU";
            case stormkit::gpu::PhysicalDeviceType::INTEGRATED_GPU:
                return "PhysicalDeviceType::INTEGRATED_GPU";
            case stormkit::gpu::PhysicalDeviceType::OTHER: return "PhysicalDeviceType::OTHER";
            case stormkit::gpu::PhysicalDeviceType::VIRTUAL_GPU:
                return "PhysicalDeviceType::VIRTUAL_GPU";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::PipelineBindPoint)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::PipelineBindPoint>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::PipelineBindPoint::COMPUTE,
            stormkit::gpu::PipelineBindPoint::GRAPHICS,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<
      stormkit::gpu::PipelineBindPoint>(stormkit::gpu::PipelineBindPoint value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::PipelineBindPoint::COMPUTE: return "PipelineBindPoint::COMPUTE";
            case stormkit::gpu::PipelineBindPoint::GRAPHICS: return "PipelineBindPoint::GRAPHICS";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<
      stormkit::gpu::PipelineBindPoint>(stormkit::gpu::PipelineBindPoint value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::PipelineBindPoint::COMPUTE: return "PipelineBindPoint::COMPUTE";
            case stormkit::gpu::PipelineBindPoint::GRAPHICS: return "PipelineBindPoint::GRAPHICS";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::PipelineStageFlag)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::PipelineStageFlag>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::PipelineStageFlag::ALL_COMMANDS,
            stormkit::gpu::PipelineStageFlag::ALL_GRAPHICS,
            stormkit::gpu::PipelineStageFlag::BOTTOM_OF_PIPE,
            stormkit::gpu::PipelineStageFlag::COLOR_ATTACHMENT_OUTPUT,
            stormkit::gpu::PipelineStageFlag::COMPUTE_SHADER,
            stormkit::gpu::PipelineStageFlag::DRAW_INDIRECT,
            stormkit::gpu::PipelineStageFlag::EARLY_FRAGMENT_TESTS,
            stormkit::gpu::PipelineStageFlag::FRAGMENT_SHADER,
            stormkit::gpu::PipelineStageFlag::GEOMETRY_SHADER,
            stormkit::gpu::PipelineStageFlag::HOST,
            stormkit::gpu::PipelineStageFlag::LATE_FRAGMENT_TESTS,
            stormkit::gpu::PipelineStageFlag::TESSELLATION_CONTROL_SHADER,
            stormkit::gpu::PipelineStageFlag::TESSELLATION_EVALUATION_SHADER,
            stormkit::gpu::PipelineStageFlag::TOP_OF_PIPE,
            stormkit::gpu::PipelineStageFlag::TRANSFER,
            stormkit::gpu::PipelineStageFlag::VERTEX_INPUT,
            stormkit::gpu::PipelineStageFlag::VERTEX_SHADER,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<
      stormkit::gpu::PipelineStageFlag>(stormkit::gpu::PipelineStageFlag value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::PipelineStageFlag::ALL_COMMANDS:
                return "PipelineStageFlag::ALL_COMMANDS";
            case stormkit::gpu::PipelineStageFlag::ALL_GRAPHICS:
                return "PipelineStageFlag::ALL_GRAPHICS";
            case stormkit::gpu::PipelineStageFlag::BOTTOM_OF_PIPE:
                return "PipelineStageFlag::BOTTOM_OF_PIPE";
            case stormkit::gpu::PipelineStageFlag::COLOR_ATTACHMENT_OUTPUT:
                return "PipelineStageFlag::COLOR_ATTACHMENT_OUTPUT";
            case stormkit::gpu::PipelineStageFlag::COMPUTE_SHADER:
                return "PipelineStageFlag::COMPUTE_SHADER";
            case stormkit::gpu::PipelineStageFlag::DRAW_INDIRECT:
                return "PipelineStageFlag::DRAW_INDIRECT";
            case stormkit::gpu::PipelineStageFlag::EARLY_FRAGMENT_TESTS:
                return "PipelineStageFlag::EARLY_FRAGMENT_TESTS";
            case stormkit::gpu::PipelineStageFlag::FRAGMENT_SHADER:
                return "PipelineStageFlag::FRAGMENT_SHADER";
            case stormkit::gpu::PipelineStageFlag::GEOMETRY_SHADER:
                return "PipelineStageFlag::GEOMETRY_SHADER";
            case stormkit::gpu::PipelineStageFlag::HOST: return "PipelineStageFlag::HOST";
            case stormkit::gpu::PipelineStageFlag::LATE_FRAGMENT_TESTS:
                return "PipelineStageFlag::LATE_FRAGMENT_TESTS";
            case stormkit::gpu::PipelineStageFlag::TESSELLATION_CONTROL_SHADER:
                return "PipelineStageFlag::TESSELLATION_CONTROL_SHADER";
            case stormkit::gpu::PipelineStageFlag::TESSELLATION_EVALUATION_SHADER:
                return "PipelineStageFlag::TESSELLATION_EVALUATION_SHADER";
            case stormkit::gpu::PipelineStageFlag::TOP_OF_PIPE:
                return "PipelineStageFlag::TOP_OF_PIPE";
            case stormkit::gpu::PipelineStageFlag::TRANSFER: return "PipelineStageFlag::TRANSFER";
            case stormkit::gpu::PipelineStageFlag::VERTEX_INPUT:
                return "PipelineStageFlag::VERTEX_INPUT";
            case stormkit::gpu::PipelineStageFlag::VERTEX_SHADER:
                return "PipelineStageFlag::VERTEX_SHADER";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<
      stormkit::gpu::PipelineStageFlag>(stormkit::gpu::PipelineStageFlag value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::PipelineStageFlag::ALL_COMMANDS:
                return "PipelineStageFlag::ALL_COMMANDS";
            case stormkit::gpu::PipelineStageFlag::ALL_GRAPHICS:
                return "PipelineStageFlag::ALL_GRAPHICS";
            case stormkit::gpu::PipelineStageFlag::BOTTOM_OF_PIPE:
                return "PipelineStageFlag::BOTTOM_OF_PIPE";
            case stormkit::gpu::PipelineStageFlag::COLOR_ATTACHMENT_OUTPUT:
                return "PipelineStageFlag::COLOR_ATTACHMENT_OUTPUT";
            case stormkit::gpu::PipelineStageFlag::COMPUTE_SHADER:
                return "PipelineStageFlag::COMPUTE_SHADER";
            case stormkit::gpu::PipelineStageFlag::DRAW_INDIRECT:
                return "PipelineStageFlag::DRAW_INDIRECT";
            case stormkit::gpu::PipelineStageFlag::EARLY_FRAGMENT_TESTS:
                return "PipelineStageFlag::EARLY_FRAGMENT_TESTS";
            case stormkit::gpu::PipelineStageFlag::FRAGMENT_SHADER:
                return "PipelineStageFlag::FRAGMENT_SHADER";
            case stormkit::gpu::PipelineStageFlag::GEOMETRY_SHADER:
                return "PipelineStageFlag::GEOMETRY_SHADER";
            case stormkit::gpu::PipelineStageFlag::HOST: return "PipelineStageFlag::HOST";
            case stormkit::gpu::PipelineStageFlag::LATE_FRAGMENT_TESTS:
                return "PipelineStageFlag::LATE_FRAGMENT_TESTS";
            case stormkit::gpu::PipelineStageFlag::TESSELLATION_CONTROL_SHADER:
                return "PipelineStageFlag::TESSELLATION_CONTROL_SHADER";
            case stormkit::gpu::PipelineStageFlag::TESSELLATION_EVALUATION_SHADER:
                return "PipelineStageFlag::TESSELLATION_EVALUATION_SHADER";
            case stormkit::gpu::PipelineStageFlag::TOP_OF_PIPE:
                return "PipelineStageFlag::TOP_OF_PIPE";
            case stormkit::gpu::PipelineStageFlag::TRANSFER: return "PipelineStageFlag::TRANSFER";
            case stormkit::gpu::PipelineStageFlag::VERTEX_INPUT:
                return "PipelineStageFlag::VERTEX_INPUT";
            case stormkit::gpu::PipelineStageFlag::VERTEX_SHADER:
                return "PipelineStageFlag::VERTEX_SHADER";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::PixelFormat)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::PixelFormat>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::PixelFormat::A1_RGB5_UNORM_PACK16,
            stormkit::gpu::PixelFormat::A2_RGB10I_PACK32,
            stormkit::gpu::PixelFormat::A2_RGB10_SNORM_PACK32,
            stormkit::gpu::PixelFormat::A2_RGB10_UNORM_PACK32,
            stormkit::gpu::PixelFormat::A2_RGB10U_PACK32,
            stormkit::gpu::PixelFormat::B10_GR11UF_PACK32,
            stormkit::gpu::PixelFormat::BGR8_UNORM,
            stormkit::gpu::PixelFormat::BGRA8_UNORM,
            stormkit::gpu::PixelFormat::DEPTH16_UNORM,
            stormkit::gpu::PixelFormat::DEPTH16_UNORM_STENCIL8U,
            stormkit::gpu::PixelFormat::DEPTH24_UNORM_PACK32,
            stormkit::gpu::PixelFormat::DEPTH24_UNORM_STENCIL8U,
            stormkit::gpu::PixelFormat::DEPTH32F,
            stormkit::gpu::PixelFormat::DEPTH32F_STENCIL8U,
            stormkit::gpu::PixelFormat::R16F,
            stormkit::gpu::PixelFormat::R16I,
            stormkit::gpu::PixelFormat::R16_SNORM,
            stormkit::gpu::PixelFormat::R16U,
            stormkit::gpu::PixelFormat::R16_UNORM,
            stormkit::gpu::PixelFormat::R32F,
            stormkit::gpu::PixelFormat::R32I,
            stormkit::gpu::PixelFormat::R32U,
            stormkit::gpu::PixelFormat::R5_G6_B5_UNORM_PACK16,
            stormkit::gpu::PixelFormat::R8I,
            stormkit::gpu::PixelFormat::R8_SNORM,
            stormkit::gpu::PixelFormat::R8U,
            stormkit::gpu::PixelFormat::R8_UNORM,
            stormkit::gpu::PixelFormat::RG16F,
            stormkit::gpu::PixelFormat::RG16I,
            stormkit::gpu::PixelFormat::RG16_SNORM,
            stormkit::gpu::PixelFormat::RG16U,
            stormkit::gpu::PixelFormat::RG16_UNORM,
            stormkit::gpu::PixelFormat::RG32F,
            stormkit::gpu::PixelFormat::RG32I,
            stormkit::gpu::PixelFormat::RG32U,
            stormkit::gpu::PixelFormat::RG8I,
            stormkit::gpu::PixelFormat::RG8_SNORM,
            stormkit::gpu::PixelFormat::RG8U,
            stormkit::gpu::PixelFormat::RG8_UNORM,
            stormkit::gpu::PixelFormat::RGB16F,
            stormkit::gpu::PixelFormat::RGB16I,
            stormkit::gpu::PixelFormat::RGB16_SNORM,
            stormkit::gpu::PixelFormat::RGB16U,
            stormkit::gpu::PixelFormat::RGB16_UNORM,
            stormkit::gpu::PixelFormat::RGB32F,
            stormkit::gpu::PixelFormat::RGB32I,
            stormkit::gpu::PixelFormat::RGB32U,
            stormkit::gpu::PixelFormat::RGB8I,
            stormkit::gpu::PixelFormat::RGB8_SNORM,
            stormkit::gpu::PixelFormat::RGB8U,
            stormkit::gpu::PixelFormat::RGB8_UNORM,
            stormkit::gpu::PixelFormat::RGBA16F,
            stormkit::gpu::PixelFormat::RGBA16I,
            stormkit::gpu::PixelFormat::RGBA16_SNORM,
            stormkit::gpu::PixelFormat::RGBA16U,
            stormkit::gpu::PixelFormat::RGBA16_UNORM,
            stormkit::gpu::PixelFormat::RGBA32F,
            stormkit::gpu::PixelFormat::RGBA32I,
            stormkit::gpu::PixelFormat::RGBA32U,
            stormkit::gpu::PixelFormat::RGBA4_UNORM_PACK16,
            stormkit::gpu::PixelFormat::RGBA8I,
            stormkit::gpu::PixelFormat::RGBA8_SNORM,
            stormkit::gpu::PixelFormat::RGBA8U,
            stormkit::gpu::PixelFormat::RGBA8_UNORM,
            stormkit::gpu::PixelFormat::SBGR8,
            stormkit::gpu::PixelFormat::SBGRA8,
            stormkit::gpu::PixelFormat::SR8,
            stormkit::gpu::PixelFormat::SRG8,
            stormkit::gpu::PixelFormat::SRGB8,
            stormkit::gpu::PixelFormat::SRGBA8,
            stormkit::gpu::PixelFormat::UNDEFINED,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<stormkit::gpu::PixelFormat>(stormkit::gpu::PixelFormat
                                                                           value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::PixelFormat::A1_RGB5_UNORM_PACK16:
                return "PixelFormat::A1_RGB5_UNORM_PACK16";
            case stormkit::gpu::PixelFormat::A2_RGB10I_PACK32:
                return "PixelFormat::A2_RGB10I_PACK32";
            case stormkit::gpu::PixelFormat::A2_RGB10_SNORM_PACK32:
                return "PixelFormat::A2_RGB10_SNORM_PACK32";
            case stormkit::gpu::PixelFormat::A2_RGB10_UNORM_PACK32:
                return "PixelFormat::A2_RGB10_UNORM_PACK32";
            case stormkit::gpu::PixelFormat::A2_RGB10U_PACK32:
                return "PixelFormat::A2_RGB10U_PACK32";
            case stormkit::gpu::PixelFormat::B10_GR11UF_PACK32:
                return "PixelFormat::B10_GR11UF_PACK32";
            case stormkit::gpu::PixelFormat::BGR8_UNORM: return "PixelFormat::BGR8_UNORM";
            case stormkit::gpu::PixelFormat::BGRA8_UNORM: return "PixelFormat::BGRA8_UNORM";
            case stormkit::gpu::PixelFormat::DEPTH16_UNORM: return "PixelFormat::DEPTH16_UNORM";
            case stormkit::gpu::PixelFormat::DEPTH16_UNORM_STENCIL8U:
                return "PixelFormat::DEPTH16_UNORM_STENCIL8U";
            case stormkit::gpu::PixelFormat::DEPTH24_UNORM_PACK32:
                return "PixelFormat::DEPTH24_UNORM_PACK32";
            case stormkit::gpu::PixelFormat::DEPTH24_UNORM_STENCIL8U:
                return "PixelFormat::DEPTH24_UNORM_STENCIL8U";
            case stormkit::gpu::PixelFormat::DEPTH32F: return "PixelFormat::DEPTH32F";
            case stormkit::gpu::PixelFormat::DEPTH32F_STENCIL8U:
                return "PixelFormat::DEPTH32F_STENCIL8U";
            case stormkit::gpu::PixelFormat::R16F: return "PixelFormat::R16F";
            case stormkit::gpu::PixelFormat::R16I: return "PixelFormat::R16I";
            case stormkit::gpu::PixelFormat::R16_SNORM: return "PixelFormat::R16_SNORM";
            case stormkit::gpu::PixelFormat::R16U: return "PixelFormat::R16U";
            case stormkit::gpu::PixelFormat::R16_UNORM: return "PixelFormat::R16_UNORM";
            case stormkit::gpu::PixelFormat::R32F: return "PixelFormat::R32F";
            case stormkit::gpu::PixelFormat::R32I: return "PixelFormat::R32I";
            case stormkit::gpu::PixelFormat::R32U: return "PixelFormat::R32U";
            case stormkit::gpu::PixelFormat::R5_G6_B5_UNORM_PACK16:
                return "PixelFormat::R5_G6_B5_UNORM_PACK16";
            case stormkit::gpu::PixelFormat::R8I: return "PixelFormat::R8I";
            case stormkit::gpu::PixelFormat::R8_SNORM: return "PixelFormat::R8_SNORM";
            case stormkit::gpu::PixelFormat::R8U: return "PixelFormat::R8U";
            case stormkit::gpu::PixelFormat::R8_UNORM: return "PixelFormat::R8_UNORM";
            case stormkit::gpu::PixelFormat::RG16F: return "PixelFormat::RG16F";
            case stormkit::gpu::PixelFormat::RG16I: return "PixelFormat::RG16I";
            case stormkit::gpu::PixelFormat::RG16_SNORM: return "PixelFormat::RG16_SNORM";
            case stormkit::gpu::PixelFormat::RG16U: return "PixelFormat::RG16U";
            case stormkit::gpu::PixelFormat::RG16_UNORM: return "PixelFormat::RG16_UNORM";
            case stormkit::gpu::PixelFormat::RG32F: return "PixelFormat::RG32F";
            case stormkit::gpu::PixelFormat::RG32I: return "PixelFormat::RG32I";
            case stormkit::gpu::PixelFormat::RG32U: return "PixelFormat::RG32U";
            case stormkit::gpu::PixelFormat::RG8I: return "PixelFormat::RG8I";
            case stormkit::gpu::PixelFormat::RG8_SNORM: return "PixelFormat::RG8_SNORM";
            case stormkit::gpu::PixelFormat::RG8U: return "PixelFormat::RG8U";
            case stormkit::gpu::PixelFormat::RG8_UNORM: return "PixelFormat::RG8_UNORM";
            case stormkit::gpu::PixelFormat::RGB16F: return "PixelFormat::RGB16F";
            case stormkit::gpu::PixelFormat::RGB16I: return "PixelFormat::RGB16I";
            case stormkit::gpu::PixelFormat::RGB16_SNORM: return "PixelFormat::RGB16_SNORM";
            case stormkit::gpu::PixelFormat::RGB16U: return "PixelFormat::RGB16U";
            case stormkit::gpu::PixelFormat::RGB16_UNORM: return "PixelFormat::RGB16_UNORM";
            case stormkit::gpu::PixelFormat::RGB32F: return "PixelFormat::RGB32F";
            case stormkit::gpu::PixelFormat::RGB32I: return "PixelFormat::RGB32I";
            case stormkit::gpu::PixelFormat::RGB32U: return "PixelFormat::RGB32U";
            case stormkit::gpu::PixelFormat::RGB8I: return "PixelFormat::RGB8I";
            case stormkit::gpu::PixelFormat::RGB8_SNORM: return "PixelFormat::RGB8_SNORM";
            case stormkit::gpu::PixelFormat::RGB8U: return "PixelFormat::RGB8U";
            case stormkit::gpu::PixelFormat::RGB8_UNORM: return "PixelFormat::RGB8_UNORM";
            case stormkit::gpu::PixelFormat::RGBA16F: return "PixelFormat::RGBA16F";
            case stormkit::gpu::PixelFormat::RGBA16I: return "PixelFormat::RGBA16I";
            case stormkit::gpu::PixelFormat::RGBA16_SNORM: return "PixelFormat::RGBA16_SNORM";
            case stormkit::gpu::PixelFormat::RGBA16U: return "PixelFormat::RGBA16U";
            case stormkit::gpu::PixelFormat::RGBA16_UNORM: return "PixelFormat::RGBA16_UNORM";
            case stormkit::gpu::PixelFormat::RGBA32F: return "PixelFormat::RGBA32F";
            case stormkit::gpu::PixelFormat::RGBA32I: return "PixelFormat::RGBA32I";
            case stormkit::gpu::PixelFormat::RGBA32U: return "PixelFormat::RGBA32U";
            case stormkit::gpu::PixelFormat::RGBA4_UNORM_PACK16:
                return "PixelFormat::RGBA4_UNORM_PACK16";
            case stormkit::gpu::PixelFormat::RGBA8I: return "PixelFormat::RGBA8I";
            case stormkit::gpu::PixelFormat::RGBA8_SNORM: return "PixelFormat::RGBA8_SNORM";
            case stormkit::gpu::PixelFormat::RGBA8U: return "PixelFormat::RGBA8U";
            case stormkit::gpu::PixelFormat::RGBA8_UNORM: return "PixelFormat::RGBA8_UNORM";
            case stormkit::gpu::PixelFormat::SBGR8: return "PixelFormat::SBGR8";
            case stormkit::gpu::PixelFormat::SBGRA8: return "PixelFormat::SBGRA8";
            case stormkit::gpu::PixelFormat::SR8: return "PixelFormat::SR8";
            case stormkit::gpu::PixelFormat::SRG8: return "PixelFormat::SRG8";
            case stormkit::gpu::PixelFormat::SRGB8: return "PixelFormat::SRGB8";
            case stormkit::gpu::PixelFormat::SRGBA8: return "PixelFormat::SRGBA8";
            case stormkit::gpu::PixelFormat::UNDEFINED: return "PixelFormat::UNDEFINED";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<stormkit::gpu::PixelFormat>(stormkit::gpu::PixelFormat
                                                                           value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::PixelFormat::A1_RGB5_UNORM_PACK16:
                return "PixelFormat::A1_RGB5_UNORM_PACK16";
            case stormkit::gpu::PixelFormat::A2_RGB10I_PACK32:
                return "PixelFormat::A2_RGB10I_PACK32";
            case stormkit::gpu::PixelFormat::A2_RGB10_SNORM_PACK32:
                return "PixelFormat::A2_RGB10_SNORM_PACK32";
            case stormkit::gpu::PixelFormat::A2_RGB10_UNORM_PACK32:
                return "PixelFormat::A2_RGB10_UNORM_PACK32";
            case stormkit::gpu::PixelFormat::A2_RGB10U_PACK32:
                return "PixelFormat::A2_RGB10U_PACK32";
            case stormkit::gpu::PixelFormat::B10_GR11UF_PACK32:
                return "PixelFormat::B10_GR11UF_PACK32";
            case stormkit::gpu::PixelFormat::BGR8_UNORM: return "PixelFormat::BGR8_UNORM";
            case stormkit::gpu::PixelFormat::BGRA8_UNORM: return "PixelFormat::BGRA8_UNORM";
            case stormkit::gpu::PixelFormat::DEPTH16_UNORM: return "PixelFormat::DEPTH16_UNORM";
            case stormkit::gpu::PixelFormat::DEPTH16_UNORM_STENCIL8U:
                return "PixelFormat::DEPTH16_UNORM_STENCIL8U";
            case stormkit::gpu::PixelFormat::DEPTH24_UNORM_PACK32:
                return "PixelFormat::DEPTH24_UNORM_PACK32";
            case stormkit::gpu::PixelFormat::DEPTH24_UNORM_STENCIL8U:
                return "PixelFormat::DEPTH24_UNORM_STENCIL8U";
            case stormkit::gpu::PixelFormat::DEPTH32F: return "PixelFormat::DEPTH32F";
            case stormkit::gpu::PixelFormat::DEPTH32F_STENCIL8U:
                return "PixelFormat::DEPTH32F_STENCIL8U";
            case stormkit::gpu::PixelFormat::R16F: return "PixelFormat::R16F";
            case stormkit::gpu::PixelFormat::R16I: return "PixelFormat::R16I";
            case stormkit::gpu::PixelFormat::R16_SNORM: return "PixelFormat::R16_SNORM";
            case stormkit::gpu::PixelFormat::R16U: return "PixelFormat::R16U";
            case stormkit::gpu::PixelFormat::R16_UNORM: return "PixelFormat::R16_UNORM";
            case stormkit::gpu::PixelFormat::R32F: return "PixelFormat::R32F";
            case stormkit::gpu::PixelFormat::R32I: return "PixelFormat::R32I";
            case stormkit::gpu::PixelFormat::R32U: return "PixelFormat::R32U";
            case stormkit::gpu::PixelFormat::R5_G6_B5_UNORM_PACK16:
                return "PixelFormat::R5_G6_B5_UNORM_PACK16";
            case stormkit::gpu::PixelFormat::R8I: return "PixelFormat::R8I";
            case stormkit::gpu::PixelFormat::R8_SNORM: return "PixelFormat::R8_SNORM";
            case stormkit::gpu::PixelFormat::R8U: return "PixelFormat::R8U";
            case stormkit::gpu::PixelFormat::R8_UNORM: return "PixelFormat::R8_UNORM";
            case stormkit::gpu::PixelFormat::RG16F: return "PixelFormat::RG16F";
            case stormkit::gpu::PixelFormat::RG16I: return "PixelFormat::RG16I";
            case stormkit::gpu::PixelFormat::RG16_SNORM: return "PixelFormat::RG16_SNORM";
            case stormkit::gpu::PixelFormat::RG16U: return "PixelFormat::RG16U";
            case stormkit::gpu::PixelFormat::RG16_UNORM: return "PixelFormat::RG16_UNORM";
            case stormkit::gpu::PixelFormat::RG32F: return "PixelFormat::RG32F";
            case stormkit::gpu::PixelFormat::RG32I: return "PixelFormat::RG32I";
            case stormkit::gpu::PixelFormat::RG32U: return "PixelFormat::RG32U";
            case stormkit::gpu::PixelFormat::RG8I: return "PixelFormat::RG8I";
            case stormkit::gpu::PixelFormat::RG8_SNORM: return "PixelFormat::RG8_SNORM";
            case stormkit::gpu::PixelFormat::RG8U: return "PixelFormat::RG8U";
            case stormkit::gpu::PixelFormat::RG8_UNORM: return "PixelFormat::RG8_UNORM";
            case stormkit::gpu::PixelFormat::RGB16F: return "PixelFormat::RGB16F";
            case stormkit::gpu::PixelFormat::RGB16I: return "PixelFormat::RGB16I";
            case stormkit::gpu::PixelFormat::RGB16_SNORM: return "PixelFormat::RGB16_SNORM";
            case stormkit::gpu::PixelFormat::RGB16U: return "PixelFormat::RGB16U";
            case stormkit::gpu::PixelFormat::RGB16_UNORM: return "PixelFormat::RGB16_UNORM";
            case stormkit::gpu::PixelFormat::RGB32F: return "PixelFormat::RGB32F";
            case stormkit::gpu::PixelFormat::RGB32I: return "PixelFormat::RGB32I";
            case stormkit::gpu::PixelFormat::RGB32U: return "PixelFormat::RGB32U";
            case stormkit::gpu::PixelFormat::RGB8I: return "PixelFormat::RGB8I";
            case stormkit::gpu::PixelFormat::RGB8_SNORM: return "PixelFormat::RGB8_SNORM";
            case stormkit::gpu::PixelFormat::RGB8U: return "PixelFormat::RGB8U";
            case stormkit::gpu::PixelFormat::RGB8_UNORM: return "PixelFormat::RGB8_UNORM";
            case stormkit::gpu::PixelFormat::RGBA16F: return "PixelFormat::RGBA16F";
            case stormkit::gpu::PixelFormat::RGBA16I: return "PixelFormat::RGBA16I";
            case stormkit::gpu::PixelFormat::RGBA16_SNORM: return "PixelFormat::RGBA16_SNORM";
            case stormkit::gpu::PixelFormat::RGBA16U: return "PixelFormat::RGBA16U";
            case stormkit::gpu::PixelFormat::RGBA16_UNORM: return "PixelFormat::RGBA16_UNORM";
            case stormkit::gpu::PixelFormat::RGBA32F: return "PixelFormat::RGBA32F";
            case stormkit::gpu::PixelFormat::RGBA32I: return "PixelFormat::RGBA32I";
            case stormkit::gpu::PixelFormat::RGBA32U: return "PixelFormat::RGBA32U";
            case stormkit::gpu::PixelFormat::RGBA4_UNORM_PACK16:
                return "PixelFormat::RGBA4_UNORM_PACK16";
            case stormkit::gpu::PixelFormat::RGBA8I: return "PixelFormat::RGBA8I";
            case stormkit::gpu::PixelFormat::RGBA8_SNORM: return "PixelFormat::RGBA8_SNORM";
            case stormkit::gpu::PixelFormat::RGBA8U: return "PixelFormat::RGBA8U";
            case stormkit::gpu::PixelFormat::RGBA8_UNORM: return "PixelFormat::RGBA8_UNORM";
            case stormkit::gpu::PixelFormat::SBGR8: return "PixelFormat::SBGR8";
            case stormkit::gpu::PixelFormat::SBGRA8: return "PixelFormat::SBGRA8";
            case stormkit::gpu::PixelFormat::SR8: return "PixelFormat::SR8";
            case stormkit::gpu::PixelFormat::SRG8: return "PixelFormat::SRG8";
            case stormkit::gpu::PixelFormat::SRGB8: return "PixelFormat::SRGB8";
            case stormkit::gpu::PixelFormat::SRGBA8: return "PixelFormat::SRGBA8";
            case stormkit::gpu::PixelFormat::UNDEFINED: return "PixelFormat::UNDEFINED";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::PolygonMode)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::PolygonMode>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::PolygonMode::FILL,
            stormkit::gpu::PolygonMode::LINE,
            stormkit::gpu::PolygonMode::POINT,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<stormkit::gpu::PolygonMode>(stormkit::gpu::PolygonMode
                                                                           value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::PolygonMode::FILL: return "PolygonMode::FILL";
            case stormkit::gpu::PolygonMode::LINE: return "PolygonMode::LINE";
            case stormkit::gpu::PolygonMode::POINT: return "PolygonMode::POINT";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<stormkit::gpu::PolygonMode>(stormkit::gpu::PolygonMode
                                                                           value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::PolygonMode::FILL: return "PolygonMode::FILL";
            case stormkit::gpu::PolygonMode::LINE: return "PolygonMode::LINE";
            case stormkit::gpu::PolygonMode::POINT: return "PolygonMode::POINT";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::PresentMode)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::PresentMode>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::PresentMode::FIFO,
            stormkit::gpu::PresentMode::FIFO_RELAXED,
            stormkit::gpu::PresentMode::IMMEDIATE,
            stormkit::gpu::PresentMode::MAILBOX,
            stormkit::gpu::PresentMode::SHARED_CONTINUOUS_REFRESH,
            stormkit::gpu::PresentMode::SHARED_DEMAND_REFRESH,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<stormkit::gpu::PresentMode>(stormkit::gpu::PresentMode
                                                                           value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::PresentMode::FIFO: return "PresentMode::FIFO";
            case stormkit::gpu::PresentMode::FIFO_RELAXED: return "PresentMode::FIFO_RELAXED";
            case stormkit::gpu::PresentMode::IMMEDIATE: return "PresentMode::IMMEDIATE";
            case stormkit::gpu::PresentMode::MAILBOX: return "PresentMode::MAILBOX";
            case stormkit::gpu::PresentMode::SHARED_CONTINUOUS_REFRESH:
                return "PresentMode::SHARED_CONTINUOUS_REFRESH";
            case stormkit::gpu::PresentMode::SHARED_DEMAND_REFRESH:
                return "PresentMode::SHARED_DEMAND_REFRESH";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<stormkit::gpu::PresentMode>(stormkit::gpu::PresentMode
                                                                           value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::PresentMode::FIFO: return "PresentMode::FIFO";
            case stormkit::gpu::PresentMode::FIFO_RELAXED: return "PresentMode::FIFO_RELAXED";
            case stormkit::gpu::PresentMode::IMMEDIATE: return "PresentMode::IMMEDIATE";
            case stormkit::gpu::PresentMode::MAILBOX: return "PresentMode::MAILBOX";
            case stormkit::gpu::PresentMode::SHARED_CONTINUOUS_REFRESH:
                return "PresentMode::SHARED_CONTINUOUS_REFRESH";
            case stormkit::gpu::PresentMode::SHARED_DEMAND_REFRESH:
                return "PresentMode::SHARED_DEMAND_REFRESH";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::PrimitiveTopology)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::PrimitiveTopology>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::PrimitiveTopology::LINE_LIST,
            stormkit::gpu::PrimitiveTopology::LINE_STRIP,
            stormkit::gpu::PrimitiveTopology::POINT_LIST,
            stormkit::gpu::PrimitiveTopology::TRIANGLE_FAN,
            stormkit::gpu::PrimitiveTopology::TRIANGLE_LIST,
            stormkit::gpu::PrimitiveTopology::TRIANGLE_STRIP,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<
      stormkit::gpu::PrimitiveTopology>(stormkit::gpu::PrimitiveTopology value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::PrimitiveTopology::LINE_LIST: return "PrimitiveTopology::LINE_LIST";
            case stormkit::gpu::PrimitiveTopology::LINE_STRIP:
                return "PrimitiveTopology::LINE_STRIP";
            case stormkit::gpu::PrimitiveTopology::POINT_LIST:
                return "PrimitiveTopology::POINT_LIST";
            case stormkit::gpu::PrimitiveTopology::TRIANGLE_FAN:
                return "PrimitiveTopology::TRIANGLE_FAN";
            case stormkit::gpu::PrimitiveTopology::TRIANGLE_LIST:
                return "PrimitiveTopology::TRIANGLE_LIST";
            case stormkit::gpu::PrimitiveTopology::TRIANGLE_STRIP:
                return "PrimitiveTopology::TRIANGLE_STRIP";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<
      stormkit::gpu::PrimitiveTopology>(stormkit::gpu::PrimitiveTopology value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::PrimitiveTopology::LINE_LIST: return "PrimitiveTopology::LINE_LIST";
            case stormkit::gpu::PrimitiveTopology::LINE_STRIP:
                return "PrimitiveTopology::LINE_STRIP";
            case stormkit::gpu::PrimitiveTopology::POINT_LIST:
                return "PrimitiveTopology::POINT_LIST";
            case stormkit::gpu::PrimitiveTopology::TRIANGLE_FAN:
                return "PrimitiveTopology::TRIANGLE_FAN";
            case stormkit::gpu::PrimitiveTopology::TRIANGLE_LIST:
                return "PrimitiveTopology::TRIANGLE_LIST";
            case stormkit::gpu::PrimitiveTopology::TRIANGLE_STRIP:
                return "PrimitiveTopology::TRIANGLE_STRIP";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::QueueFlag)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::QueueFlag>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::QueueFlag::COMPUTE,        stormkit::gpu::QueueFlag::GRAPHICS,
            stormkit::gpu::QueueFlag::NONE,           stormkit::gpu::QueueFlag::PROTECTED,
            stormkit::gpu::QueueFlag::SPARSE_BINDING, stormkit::gpu::QueueFlag::TRANSFER,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<stormkit::gpu::QueueFlag>(stormkit::gpu::QueueFlag
                                                                         value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::QueueFlag::COMPUTE: return "QueueFlag::COMPUTE";
            case stormkit::gpu::QueueFlag::GRAPHICS: return "QueueFlag::GRAPHICS";
            case stormkit::gpu::QueueFlag::NONE: return "QueueFlag::NONE";
            case stormkit::gpu::QueueFlag::PROTECTED: return "QueueFlag::PROTECTED";
            case stormkit::gpu::QueueFlag::SPARSE_BINDING: return "QueueFlag::SPARSE_BINDING";
            case stormkit::gpu::QueueFlag::TRANSFER: return "QueueFlag::TRANSFER";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<stormkit::gpu::QueueFlag>(stormkit::gpu::QueueFlag
                                                                         value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::QueueFlag::COMPUTE: return "QueueFlag::COMPUTE";
            case stormkit::gpu::QueueFlag::GRAPHICS: return "QueueFlag::GRAPHICS";
            case stormkit::gpu::QueueFlag::NONE: return "QueueFlag::NONE";
            case stormkit::gpu::QueueFlag::PROTECTED: return "QueueFlag::PROTECTED";
            case stormkit::gpu::QueueFlag::SPARSE_BINDING: return "QueueFlag::SPARSE_BINDING";
            case stormkit::gpu::QueueFlag::TRANSFER: return "QueueFlag::TRANSFER";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::Result)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::Result>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::Result::ERROR_DEVICE_LOST,
            stormkit::gpu::Result::ERROR_EXTENSION_NOT_PRESENT,
            stormkit::gpu::Result::ERROR_FEATURE_NOT_PRESENT,
            stormkit::gpu::Result::ERROR_FORMAT_NOT_SUPPORTED,
            stormkit::gpu::Result::ERROR_FRAGMENTATION,
            stormkit::gpu::Result::ERROR_FRAGMENTED_POOL,
            stormkit::gpu::Result::ERROR_FULLSCREEN_EXCLUSIVE_MODE_LOST,
            stormkit::gpu::Result::ERROR_INCOMPATIBLE_DISPLAY,
            stormkit::gpu::Result::ERROR_INCOMPATIBLE_DRIVER,
            stormkit::gpu::Result::ERROR_INITIALIZATION_FAILED,
            stormkit::gpu::Result::ERROR_INVALID_EXTERNAL_HANDLE,
            stormkit::gpu::Result::ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS,
            stormkit::gpu::Result::ERROR_LAYER_NOT_PRESENT,
            stormkit::gpu::Result::ERROR_MEMORY_MAP_FAILED,
            stormkit::gpu::Result::ERROR_NATIVE_WINDOW_IN_USE,
            stormkit::gpu::Result::ERROR_NOT_PERMITTED,
            stormkit::gpu::Result::ERROR_OUT_OF_DATE,
            stormkit::gpu::Result::ERROR_OUT_OF_DEVICE_MEMORY,
            stormkit::gpu::Result::ERROR_OUT_OF_HOST_MEMORY,
            stormkit::gpu::Result::ERROR_OUT_OF_POOL_MEMORY,
            stormkit::gpu::Result::ERROR_SURFACE_LOST,
            stormkit::gpu::Result::ERROR_TOO_MANY_OBJECTS,
            stormkit::gpu::Result::ERROR_UNKNOWN,
            stormkit::gpu::Result::ERROR_VALIDATION_FAILED,
            stormkit::gpu::Result::EVENT_RESET,
            stormkit::gpu::Result::EVENT_SET,
            stormkit::gpu::Result::INCOMPLETE,
            stormkit::gpu::Result::NOT_READY,
            stormkit::gpu::Result::OPERATION_DEFERRED,
            stormkit::gpu::Result::OPERATION_NOT_DEFERRED,
            stormkit::gpu::Result::PIPELINE_COMPILE_REQUIRED,
            stormkit::gpu::Result::SUBOPTIMAL,
            stormkit::gpu::Result::SUCCESS,
            stormkit::gpu::Result::THREAD_DONE,
            stormkit::gpu::Result::THREAD_IDLE,
            stormkit::gpu::Result::TIMEOUT,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<stormkit::gpu::Result>(stormkit::gpu::Result
                                                                      value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::Result::ERROR_DEVICE_LOST: return "Result::ERROR_DEVICE_LOST";
            case stormkit::gpu::Result::ERROR_EXTENSION_NOT_PRESENT:
                return "Result::ERROR_EXTENSION_NOT_PRESENT";
            case stormkit::gpu::Result::ERROR_FEATURE_NOT_PRESENT:
                return "Result::ERROR_FEATURE_NOT_PRESENT";
            case stormkit::gpu::Result::ERROR_FORMAT_NOT_SUPPORTED:
                return "Result::ERROR_FORMAT_NOT_SUPPORTED";
            case stormkit::gpu::Result::ERROR_FRAGMENTATION: return "Result::ERROR_FRAGMENTATION";
            case stormkit::gpu::Result::ERROR_FRAGMENTED_POOL:
                return "Result::ERROR_FRAGMENTED_POOL";
            case stormkit::gpu::Result::ERROR_FULLSCREEN_EXCLUSIVE_MODE_LOST:
                return "Result::ERROR_FULLSCREEN_EXCLUSIVE_MODE_LOST";
            case stormkit::gpu::Result::ERROR_INCOMPATIBLE_DISPLAY:
                return "Result::ERROR_INCOMPATIBLE_DISPLAY";
            case stormkit::gpu::Result::ERROR_INCOMPATIBLE_DRIVER:
                return "Result::ERROR_INCOMPATIBLE_DRIVER";
            case stormkit::gpu::Result::ERROR_INITIALIZATION_FAILED:
                return "Result::ERROR_INITIALIZATION_FAILED";
            case stormkit::gpu::Result::ERROR_INVALID_EXTERNAL_HANDLE:
                return "Result::ERROR_INVALID_EXTERNAL_HANDLE";
            case stormkit::gpu::Result::ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS:
                return "Result::ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS";
            case stormkit::gpu::Result::ERROR_LAYER_NOT_PRESENT:
                return "Result::ERROR_LAYER_NOT_PRESENT";
            case stormkit::gpu::Result::ERROR_MEMORY_MAP_FAILED:
                return "Result::ERROR_MEMORY_MAP_FAILED";
            case stormkit::gpu::Result::ERROR_NATIVE_WINDOW_IN_USE:
                return "Result::ERROR_NATIVE_WINDOW_IN_USE";
            case stormkit::gpu::Result::ERROR_NOT_PERMITTED: return "Result::ERROR_NOT_PERMITTED";
            case stormkit::gpu::Result::ERROR_OUT_OF_DATE: return "Result::ERROR_OUT_OF_DATE";
            case stormkit::gpu::Result::ERROR_OUT_OF_DEVICE_MEMORY:
                return "Result::ERROR_OUT_OF_DEVICE_MEMORY";
            case stormkit::gpu::Result::ERROR_OUT_OF_HOST_MEMORY:
                return "Result::ERROR_OUT_OF_HOST_MEMORY";
            case stormkit::gpu::Result::ERROR_OUT_OF_POOL_MEMORY:
                return "Result::ERROR_OUT_OF_POOL_MEMORY";
            case stormkit::gpu::Result::ERROR_SURFACE_LOST: return "Result::ERROR_SURFACE_LOST";
            case stormkit::gpu::Result::ERROR_TOO_MANY_OBJECTS:
                return "Result::ERROR_TOO_MANY_OBJECTS";
            case stormkit::gpu::Result::ERROR_UNKNOWN: return "Result::ERROR_UNKNOWN";
            case stormkit::gpu::Result::ERROR_VALIDATION_FAILED:
                return "Result::ERROR_VALIDATION_FAILED";
            case stormkit::gpu::Result::EVENT_RESET: return "Result::EVENT_RESET";
            case stormkit::gpu::Result::EVENT_SET: return "Result::EVENT_SET";
            case stormkit::gpu::Result::INCOMPLETE: return "Result::INCOMPLETE";
            case stormkit::gpu::Result::NOT_READY: return "Result::NOT_READY";
            case stormkit::gpu::Result::OPERATION_DEFERRED: return "Result::OPERATION_DEFERRED";
            case stormkit::gpu::Result::OPERATION_NOT_DEFERRED:
                return "Result::OPERATION_NOT_DEFERRED";
            case stormkit::gpu::Result::PIPELINE_COMPILE_REQUIRED:
                return "Result::PIPELINE_COMPILE_REQUIRED";
            case stormkit::gpu::Result::SUBOPTIMAL: return "Result::SUBOPTIMAL";
            case stormkit::gpu::Result::SUCCESS: return "Result::SUCCESS";
            case stormkit::gpu::Result::THREAD_DONE: return "Result::THREAD_DONE";
            case stormkit::gpu::Result::THREAD_IDLE: return "Result::THREAD_IDLE";
            case stormkit::gpu::Result::TIMEOUT: return "Result::TIMEOUT";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<stormkit::gpu::Result>(stormkit::gpu::Result
                                                                      value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::Result::ERROR_DEVICE_LOST: return "Result::ERROR_DEVICE_LOST";
            case stormkit::gpu::Result::ERROR_EXTENSION_NOT_PRESENT:
                return "Result::ERROR_EXTENSION_NOT_PRESENT";
            case stormkit::gpu::Result::ERROR_FEATURE_NOT_PRESENT:
                return "Result::ERROR_FEATURE_NOT_PRESENT";
            case stormkit::gpu::Result::ERROR_FORMAT_NOT_SUPPORTED:
                return "Result::ERROR_FORMAT_NOT_SUPPORTED";
            case stormkit::gpu::Result::ERROR_FRAGMENTATION: return "Result::ERROR_FRAGMENTATION";
            case stormkit::gpu::Result::ERROR_FRAGMENTED_POOL:
                return "Result::ERROR_FRAGMENTED_POOL";
            case stormkit::gpu::Result::ERROR_FULLSCREEN_EXCLUSIVE_MODE_LOST:
                return "Result::ERROR_FULLSCREEN_EXCLUSIVE_MODE_LOST";
            case stormkit::gpu::Result::ERROR_INCOMPATIBLE_DISPLAY:
                return "Result::ERROR_INCOMPATIBLE_DISPLAY";
            case stormkit::gpu::Result::ERROR_INCOMPATIBLE_DRIVER:
                return "Result::ERROR_INCOMPATIBLE_DRIVER";
            case stormkit::gpu::Result::ERROR_INITIALIZATION_FAILED:
                return "Result::ERROR_INITIALIZATION_FAILED";
            case stormkit::gpu::Result::ERROR_INVALID_EXTERNAL_HANDLE:
                return "Result::ERROR_INVALID_EXTERNAL_HANDLE";
            case stormkit::gpu::Result::ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS:
                return "Result::ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS";
            case stormkit::gpu::Result::ERROR_LAYER_NOT_PRESENT:
                return "Result::ERROR_LAYER_NOT_PRESENT";
            case stormkit::gpu::Result::ERROR_MEMORY_MAP_FAILED:
                return "Result::ERROR_MEMORY_MAP_FAILED";
            case stormkit::gpu::Result::ERROR_NATIVE_WINDOW_IN_USE:
                return "Result::ERROR_NATIVE_WINDOW_IN_USE";
            case stormkit::gpu::Result::ERROR_NOT_PERMITTED: return "Result::ERROR_NOT_PERMITTED";
            case stormkit::gpu::Result::ERROR_OUT_OF_DATE: return "Result::ERROR_OUT_OF_DATE";
            case stormkit::gpu::Result::ERROR_OUT_OF_DEVICE_MEMORY:
                return "Result::ERROR_OUT_OF_DEVICE_MEMORY";
            case stormkit::gpu::Result::ERROR_OUT_OF_HOST_MEMORY:
                return "Result::ERROR_OUT_OF_HOST_MEMORY";
            case stormkit::gpu::Result::ERROR_OUT_OF_POOL_MEMORY:
                return "Result::ERROR_OUT_OF_POOL_MEMORY";
            case stormkit::gpu::Result::ERROR_SURFACE_LOST: return "Result::ERROR_SURFACE_LOST";
            case stormkit::gpu::Result::ERROR_TOO_MANY_OBJECTS:
                return "Result::ERROR_TOO_MANY_OBJECTS";
            case stormkit::gpu::Result::ERROR_UNKNOWN: return "Result::ERROR_UNKNOWN";
            case stormkit::gpu::Result::ERROR_VALIDATION_FAILED:
                return "Result::ERROR_VALIDATION_FAILED";
            case stormkit::gpu::Result::EVENT_RESET: return "Result::EVENT_RESET";
            case stormkit::gpu::Result::EVENT_SET: return "Result::EVENT_SET";
            case stormkit::gpu::Result::INCOMPLETE: return "Result::INCOMPLETE";
            case stormkit::gpu::Result::NOT_READY: return "Result::NOT_READY";
            case stormkit::gpu::Result::OPERATION_DEFERRED: return "Result::OPERATION_DEFERRED";
            case stormkit::gpu::Result::OPERATION_NOT_DEFERRED:
                return "Result::OPERATION_NOT_DEFERRED";
            case stormkit::gpu::Result::PIPELINE_COMPILE_REQUIRED:
                return "Result::PIPELINE_COMPILE_REQUIRED";
            case stormkit::gpu::Result::SUBOPTIMAL: return "Result::SUBOPTIMAL";
            case stormkit::gpu::Result::SUCCESS: return "Result::SUCCESS";
            case stormkit::gpu::Result::THREAD_DONE: return "Result::THREAD_DONE";
            case stormkit::gpu::Result::THREAD_IDLE: return "Result::THREAD_IDLE";
            case stormkit::gpu::Result::TIMEOUT: return "Result::TIMEOUT";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::SampleCountFlag)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::SampleCountFlag>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::SampleCountFlag::C1, stormkit::gpu::SampleCountFlag::C16,
            stormkit::gpu::SampleCountFlag::C2, stormkit::gpu::SampleCountFlag::C32,
            stormkit::gpu::SampleCountFlag::C4, stormkit::gpu::SampleCountFlag::C64,
            stormkit::gpu::SampleCountFlag::C8,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<
      stormkit::gpu::SampleCountFlag>(stormkit::gpu::SampleCountFlag value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::SampleCountFlag::C1: return "SampleCountFlag::C1";
            case stormkit::gpu::SampleCountFlag::C16: return "SampleCountFlag::C16";
            case stormkit::gpu::SampleCountFlag::C2: return "SampleCountFlag::C2";
            case stormkit::gpu::SampleCountFlag::C32: return "SampleCountFlag::C32";
            case stormkit::gpu::SampleCountFlag::C4: return "SampleCountFlag::C4";
            case stormkit::gpu::SampleCountFlag::C64: return "SampleCountFlag::C64";
            case stormkit::gpu::SampleCountFlag::C8: return "SampleCountFlag::C8";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<
      stormkit::gpu::SampleCountFlag>(stormkit::gpu::SampleCountFlag value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::SampleCountFlag::C1: return "SampleCountFlag::C1";
            case stormkit::gpu::SampleCountFlag::C16: return "SampleCountFlag::C16";
            case stormkit::gpu::SampleCountFlag::C2: return "SampleCountFlag::C2";
            case stormkit::gpu::SampleCountFlag::C32: return "SampleCountFlag::C32";
            case stormkit::gpu::SampleCountFlag::C4: return "SampleCountFlag::C4";
            case stormkit::gpu::SampleCountFlag::C64: return "SampleCountFlag::C64";
            case stormkit::gpu::SampleCountFlag::C8: return "SampleCountFlag::C8";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::SamplerAddressMode)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::SamplerAddressMode>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::SamplerAddressMode::CLAMP_TO_BORDER,
            stormkit::gpu::SamplerAddressMode::CLAMP_TO_EDGE,
            stormkit::gpu::SamplerAddressMode::MIRROR_CLAMP_TO_EDGE,
            stormkit::gpu::SamplerAddressMode::MIRRORED_REPEAT,
            stormkit::gpu::SamplerAddressMode::REPEAT,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<
      stormkit::gpu::SamplerAddressMode>(stormkit::gpu::SamplerAddressMode value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::SamplerAddressMode::CLAMP_TO_BORDER:
                return "SamplerAddressMode::CLAMP_TO_BORDER";
            case stormkit::gpu::SamplerAddressMode::CLAMP_TO_EDGE:
                return "SamplerAddressMode::CLAMP_TO_EDGE";
            case stormkit::gpu::SamplerAddressMode::MIRROR_CLAMP_TO_EDGE:
                return "SamplerAddressMode::MIRROR_CLAMP_TO_EDGE";
            case stormkit::gpu::SamplerAddressMode::MIRRORED_REPEAT:
                return "SamplerAddressMode::MIRRORED_REPEAT";
            case stormkit::gpu::SamplerAddressMode::REPEAT: return "SamplerAddressMode::REPEAT";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<
      stormkit::gpu::SamplerAddressMode>(stormkit::gpu::SamplerAddressMode value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::SamplerAddressMode::CLAMP_TO_BORDER:
                return "SamplerAddressMode::CLAMP_TO_BORDER";
            case stormkit::gpu::SamplerAddressMode::CLAMP_TO_EDGE:
                return "SamplerAddressMode::CLAMP_TO_EDGE";
            case stormkit::gpu::SamplerAddressMode::MIRROR_CLAMP_TO_EDGE:
                return "SamplerAddressMode::MIRROR_CLAMP_TO_EDGE";
            case stormkit::gpu::SamplerAddressMode::MIRRORED_REPEAT:
                return "SamplerAddressMode::MIRRORED_REPEAT";
            case stormkit::gpu::SamplerAddressMode::REPEAT: return "SamplerAddressMode::REPEAT";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::SamplerMipmapMode)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::SamplerMipmapMode>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::SamplerMipmapMode::LINEAR,
            stormkit::gpu::SamplerMipmapMode::NEAREST,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<
      stormkit::gpu::SamplerMipmapMode>(stormkit::gpu::SamplerMipmapMode value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::SamplerMipmapMode::LINEAR: return "SamplerMipmapMode::LINEAR";
            case stormkit::gpu::SamplerMipmapMode::NEAREST: return "SamplerMipmapMode::NEAREST";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<
      stormkit::gpu::SamplerMipmapMode>(stormkit::gpu::SamplerMipmapMode value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::SamplerMipmapMode::LINEAR: return "SamplerMipmapMode::LINEAR";
            case stormkit::gpu::SamplerMipmapMode::NEAREST: return "SamplerMipmapMode::NEAREST";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::ShaderStageFlag)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::ShaderStageFlag>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::ShaderStageFlag::COMPUTE,  stormkit::gpu::ShaderStageFlag::FRAGMENT,
            stormkit::gpu::ShaderStageFlag::GEOMETRY, stormkit::gpu::ShaderStageFlag::NONE,
            stormkit::gpu::ShaderStageFlag::VERTEX,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<
      stormkit::gpu::ShaderStageFlag>(stormkit::gpu::ShaderStageFlag value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::ShaderStageFlag::COMPUTE: return "ShaderStageFlag::COMPUTE";
            case stormkit::gpu::ShaderStageFlag::FRAGMENT: return "ShaderStageFlag::FRAGMENT";
            case stormkit::gpu::ShaderStageFlag::GEOMETRY: return "ShaderStageFlag::GEOMETRY";
            case stormkit::gpu::ShaderStageFlag::NONE: return "ShaderStageFlag::NONE";
            case stormkit::gpu::ShaderStageFlag::VERTEX: return "ShaderStageFlag::VERTEX";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<
      stormkit::gpu::ShaderStageFlag>(stormkit::gpu::ShaderStageFlag value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::ShaderStageFlag::COMPUTE: return "ShaderStageFlag::COMPUTE";
            case stormkit::gpu::ShaderStageFlag::FRAGMENT: return "ShaderStageFlag::FRAGMENT";
            case stormkit::gpu::ShaderStageFlag::GEOMETRY: return "ShaderStageFlag::GEOMETRY";
            case stormkit::gpu::ShaderStageFlag::NONE: return "ShaderStageFlag::NONE";
            case stormkit::gpu::ShaderStageFlag::VERTEX: return "ShaderStageFlag::VERTEX";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::StencilFaceFlag)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::StencilFaceFlag>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::StencilFaceFlag::BACK,
            stormkit::gpu::StencilFaceFlag::FRONT,
            stormkit::gpu::StencilFaceFlag::FRONT_AND_BACK,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<
      stormkit::gpu::StencilFaceFlag>(stormkit::gpu::StencilFaceFlag value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::StencilFaceFlag::BACK: return "StencilFaceFlag::BACK";
            case stormkit::gpu::StencilFaceFlag::FRONT: return "StencilFaceFlag::FRONT";
            case stormkit::gpu::StencilFaceFlag::FRONT_AND_BACK:
                return "StencilFaceFlag::FRONT_AND_BACK";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<
      stormkit::gpu::StencilFaceFlag>(stormkit::gpu::StencilFaceFlag value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::StencilFaceFlag::BACK: return "StencilFaceFlag::BACK";
            case stormkit::gpu::StencilFaceFlag::FRONT: return "StencilFaceFlag::FRONT";
            case stormkit::gpu::StencilFaceFlag::FRONT_AND_BACK:
                return "StencilFaceFlag::FRONT_AND_BACK";
        }
        std::unreachable();
    }
    FLAG_ENUM(stormkit::gpu::VertexInputRate)

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::meta::enumerate<stormkit::gpu::VertexInputRate>() noexcept
      -> decltype(auto) {
        return std::array {
            stormkit::gpu::VertexInputRate::INSTANCE,
            stormkit::gpu::VertexInputRate::VERTEX,

        };
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::as_string<
      stormkit::gpu::VertexInputRate>(stormkit::gpu::VertexInputRate value) noexcept
      -> std::string_view {
        switch (value) {
            case stormkit::gpu::VertexInputRate::INSTANCE: return "VertexInputRate::INSTANCE";
            case stormkit::gpu::VertexInputRate::VERTEX: return "VertexInputRate::VERTEX";
        }
        std::unreachable();
    }

    template<>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto stormkit::core::to_string<
      stormkit::gpu::VertexInputRate>(stormkit::gpu::VertexInputRate value) noexcept
      -> std::string {
        switch (value) {
            case stormkit::gpu::VertexInputRate::INSTANCE: return "VertexInputRate::INSTANCE";
            case stormkit::gpu::VertexInputRate::VERTEX: return "VertexInputRate::VERTEX";
        }
        std::unreachable();
    }

    // enum class Format : u8 {
    //     BYTE,
    //     BYTE2,
    //     BYTE3,
    //     BYTE4,

    //    BYTE_NORM,
    //    BYTE2_NORM,
    //    BYTE3_NORM,
    //    BYTE4_NORM,

    //    BYTE_SCALED,
    //    BYTE2_SCALED,
    //    BYTE3_SCALED,
    //    BYTE4_SCALED,

    //    UBYTE,
    //    UBYTE2,
    //    UBYTE3,
    //    UBYTE4,

    //    UBYTE_NORM,
    //    UBYTE2_NORM,
    //    UBYTE3_NORM,
    //    UBYTE4_NORM,

    //    UBYTE_UCALED,
    //    UBYTE2_UCALED,
    //    UBYTE3_UCALED,
    //    UBYTE4_UCALED,

    //    SHORT,
    //    SHORT2,
    //    SHORT3,
    //    SHORT4,

    //    SHORT_NORM,
    //    SHORT2_NORM,
    //    SHORT3_NORM,
    //    SHORT4_NORM,

    //    SHORT_SCALED,
    //    SHORT2_SCALED,
    //    SHORT3_SCALED,
    //    SHORT4_SCALED,

    //    USHORT,
    //    USHORT2,
    //    USHORT3,
    //    USHORT4,

    //    USHORT_NORM,
    //    USHORT2_NORM,
    //    USHORT3_NORM,
    //    USHORT4_NORM,

    //    USHORT_UCALED,
    //    USHORT2_UCALED,
    //    USHORT3_UCALED,
    //    USHORT4_UCALED,

    //    INT,
    //    INT2,
    //    INT3,
    //    INT4,

    //    UINT,
    //    UINT2,
    //    UINT3,
    //    UINT4,

    //    LONG,
    //    LONG2,
    //    LONG3,
    //    LONG4,

    //    ULONG,
    //    ULONG2,
    //    ULONG3,
    //    ULONG4,

    //    FLOAT,
    //    FLOAT2,
    //    FLOAT3,
    //    FLOAT4,

    //    DOUBLE,
    //    DOUBLE2,
    //    DOUBLE3,
    //    DOUBLE4,

    //    UNDEFINED,
    // };
}

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit::gpu {
    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    constexpr auto is_depth_only_format(PixelFormat format) noexcept -> bool {
        return format == PixelFormat::DEPTH16_UNORM
               or format == PixelFormat::DEPTH24_UNORM_PACK32
               or format == PixelFormat::DEPTH32F;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    constexpr auto is_depth_stencil_format(PixelFormat format) noexcept -> bool {
        return format == PixelFormat::DEPTH16_UNORM_STENCIL8U
               or format == PixelFormat::DEPTH24_UNORM_STENCIL8U
               or format == PixelFormat::DEPTH32F_STENCIL8U;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    constexpr auto is_depth_format(PixelFormat format) noexcept -> bool {
        return is_depth_only_format(format) or is_depth_stencil_format(format);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    constexpr auto get_format_channel_count(PixelFormat format) noexcept -> u8 {
        switch (format) {
            case PixelFormat::R8_SNORM:
            case PixelFormat::R8_UNORM:
            case PixelFormat::R16_SNORM:
            case PixelFormat::R16_UNORM:
            case PixelFormat::R8I:
            case PixelFormat::R8U:
            case PixelFormat::R16I:
            case PixelFormat::R16U:
            case PixelFormat::R32I:
            case PixelFormat::R32U:
            case PixelFormat::R16F:
            case PixelFormat::R32F:
            case PixelFormat::DEPTH16_UNORM:
            case PixelFormat::DEPTH24_UNORM_PACK32:
            case PixelFormat::DEPTH32F: return 1;

            case PixelFormat::RG8_SNORM:
            case PixelFormat::RG8_UNORM:
            case PixelFormat::RG16_SNORM:
            case PixelFormat::RG16_UNORM:
            case PixelFormat::RG8I:
            case PixelFormat::RG8U:
            case PixelFormat::RG16I:
            case PixelFormat::RG16U:
            case PixelFormat::RG32I:
            case PixelFormat::RG32U:
            case PixelFormat::RG16F:
            case PixelFormat::RG32F:
            case PixelFormat::DEPTH16_UNORM_STENCIL8U:
            case PixelFormat::DEPTH24_UNORM_STENCIL8U:
            case PixelFormat::DEPTH32F_STENCIL8U: return 2;

            case PixelFormat::RGB8_SNORM:
            case PixelFormat::RGB8_UNORM:
            case PixelFormat::RGB16_SNORM:
            case PixelFormat::RGB16_UNORM:
            case PixelFormat::BGR8_UNORM:
            case PixelFormat::RGB8I:
            case PixelFormat::RGB8U:
            case PixelFormat::RGB16I:
            case PixelFormat::RGB16U:
            case PixelFormat::RGB32I:
            case PixelFormat::RGB32U:
            case PixelFormat::RGB16F:
            case PixelFormat::RGB32F:
            case PixelFormat::SRGB8:
            case PixelFormat::SBGR8:
            case PixelFormat::R5_G6_B5_UNORM_PACK16:
            case PixelFormat::B10_GR11UF_PACK32: return 3;

            case PixelFormat::RGBA8_SNORM:
            case PixelFormat::RGBA8_UNORM:
            case PixelFormat::RGBA16_SNORM:
            case PixelFormat::RGBA16_UNORM:
            case PixelFormat::BGRA8_UNORM:
            case PixelFormat::RGBA8I:
            case PixelFormat::RGBA8U:
            case PixelFormat::RGBA16I:
            case PixelFormat::RGBA16U:
            case PixelFormat::RGBA32I:
            case PixelFormat::RGBA32U:
            case PixelFormat::RGBA16F:
            case PixelFormat::RGBA32F:
            case PixelFormat::SRGBA8:
            case PixelFormat::SBGRA8: return 4;

            default: break;
        }

        return 0u;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    constexpr auto get_format_element_count(PixelFormat format) noexcept -> u8 {
        switch (format) {
            case PixelFormat::R8_SNORM:
            case PixelFormat::R8_UNORM:
            case PixelFormat::RG8_SNORM:
            case PixelFormat::RG8_UNORM:
            case PixelFormat::R8I:
            case PixelFormat::R8U:
            case PixelFormat::RG8I:
            case PixelFormat::RG8U:
            case PixelFormat::RGB8_SNORM:
            case PixelFormat::RGB8_UNORM:
            case PixelFormat::BGR8_UNORM:
            case PixelFormat::RGB8I:
            case PixelFormat::RGB8U:
            case PixelFormat::RGBA8_SNORM:
            case PixelFormat::RGBA8_UNORM:
            case PixelFormat::RGBA16_SNORM:
            case PixelFormat::BGRA8_UNORM:
            case PixelFormat::SRGB8:
            case PixelFormat::SBGR8:
            case PixelFormat::SRGBA8:
            case PixelFormat::SBGRA8: return 1u;

            case PixelFormat::R16_SNORM:
            case PixelFormat::R16_UNORM:
            case PixelFormat::R16I:
            case PixelFormat::R16U:
            case PixelFormat::RG16_SNORM:
            case PixelFormat::RG16_UNORM:
            case PixelFormat::RG16I:
            case PixelFormat::RG16U:
            case PixelFormat::RG16F:
            case PixelFormat::RGB16I:
            case PixelFormat::RGB16U:
            case PixelFormat::RGB16F:
            case PixelFormat::RGBA16I:
            case PixelFormat::RGBA16U:
            case PixelFormat::RGBA16F:
            case PixelFormat::R16F: return 2u;

            case PixelFormat::R32I:
            case PixelFormat::R32U:
            case PixelFormat::R32F:
            case PixelFormat::RG32I:
            case PixelFormat::RG32U:
            case PixelFormat::RG32F:
            case PixelFormat::RGB16_SNORM:
            case PixelFormat::RGB32I:
            case PixelFormat::RGB32U:
            case PixelFormat::RGB32F:
            case PixelFormat::RGBA8I:
            case PixelFormat::RGBA8U:
            case PixelFormat::RGBA32I:
            case PixelFormat::RGBA32U:
            case PixelFormat::RGBA32F: return 4u;

            default: break;
        }

        return 0u;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T = VkFlags, meta::IsVulkanEnumeration U>
        requires(core::meta::IsPlainEnumeration<T> or core::meta::Is<T, VkFlags>)
    STORMKIT_FORCE_INLINE
    STORMKIT_INTRINSIC
    constexpr auto to_vk(U value) noexcept -> T {
        return narrow<T>(value);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<meta::IsVulkanEnumeration T, typename U>
        requires(core::meta::IsPlainEnumeration<U> or core::meta::Is<U, VkFlags>)
    STORMKIT_FORCE_INLINE
    STORMKIT_INTRINSIC
    constexpr auto from_vk(U value) noexcept -> T {
        return narrow<T>(value);
    }
} // namespace stormkit::gpu

template stormkit::gpu::AccessFlag stormkit::gpu::from_vk<stormkit::gpu::AccessFlag,
                                                          VkFlags>(VkFlags);
template stormkit::gpu::AccessFlag stormkit::gpu::from_vk<stormkit::gpu::AccessFlag,
                                                          VkAccessFlagBits>(VkAccessFlagBits);
template VkFlags                   stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::AccessFlag);
template VkAccessFlagBits stormkit::gpu::to_vk<VkAccessFlagBits>(stormkit::gpu::AccessFlag);

template stormkit::gpu::AttachmentLoadOperation stormkit::gpu::
  from_vk<stormkit::gpu::AttachmentLoadOperation, VkFlags>(VkFlags);
template stormkit::gpu::AttachmentLoadOperation stormkit::gpu::
  from_vk<stormkit::gpu::AttachmentLoadOperation, VkAttachmentLoadOp>(VkAttachmentLoadOp);
template VkFlags            stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::AttachmentLoadOperation);
template VkAttachmentLoadOp stormkit::gpu::to_vk<
  VkAttachmentLoadOp>(stormkit::gpu::AttachmentLoadOperation);

template stormkit::gpu::AttachmentStoreOperation stormkit::gpu::
  from_vk<stormkit::gpu::AttachmentStoreOperation, VkFlags>(VkFlags);
template stormkit::gpu::AttachmentStoreOperation stormkit::gpu::
  from_vk<stormkit::gpu::AttachmentStoreOperation, VkAttachmentStoreOp>(VkAttachmentStoreOp);
template VkFlags             stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::AttachmentStoreOperation);
template VkAttachmentStoreOp stormkit::gpu::to_vk<
  VkAttachmentStoreOp>(stormkit::gpu::AttachmentStoreOperation);

template stormkit::gpu::BlendFactor stormkit::gpu::from_vk<stormkit::gpu::BlendFactor,
                                                           VkFlags>(VkFlags);
template stormkit::gpu::BlendFactor stormkit::gpu::from_vk<stormkit::gpu::BlendFactor,
                                                           VkBlendFactor>(VkBlendFactor);
template VkFlags                    stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::BlendFactor);
template VkBlendFactor              stormkit::gpu::to_vk<VkBlendFactor>(stormkit::gpu::BlendFactor);

template stormkit::gpu::BlendOperation stormkit::gpu::from_vk<stormkit::gpu::BlendOperation,
                                                              VkFlags>(VkFlags);
template stormkit::gpu::BlendOperation stormkit::gpu::from_vk<stormkit::gpu::BlendOperation,
                                                              VkBlendOp>(VkBlendOp);
template VkFlags                       stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::BlendOperation);
template VkBlendOp stormkit::gpu::to_vk<VkBlendOp>(stormkit::gpu::BlendOperation);

template stormkit::gpu::BorderColor stormkit::gpu::from_vk<stormkit::gpu::BorderColor,
                                                           VkFlags>(VkFlags);
template stormkit::gpu::BorderColor stormkit::gpu::from_vk<stormkit::gpu::BorderColor,
                                                           VkBorderColor>(VkBorderColor);
template VkFlags                    stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::BorderColor);
template VkBorderColor              stormkit::gpu::to_vk<VkBorderColor>(stormkit::gpu::BorderColor);

template stormkit::gpu::BufferUsageFlag stormkit::gpu::from_vk<stormkit::gpu::BufferUsageFlag,
                                                               VkFlags>(VkFlags);
template stormkit::gpu::BufferUsageFlag stormkit::gpu::
  from_vk<stormkit::gpu::BufferUsageFlag, VkBufferUsageFlagBits>(VkBufferUsageFlagBits);
template VkFlags               stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::BufferUsageFlag);
template VkBufferUsageFlagBits stormkit::gpu::to_vk<
  VkBufferUsageFlagBits>(stormkit::gpu::BufferUsageFlag);

template stormkit::gpu::ColorComponentFlag stormkit::gpu::from_vk<stormkit::gpu::ColorComponentFlag,
                                                                  VkFlags>(VkFlags);
template stormkit::gpu::ColorComponentFlag stormkit::gpu::
  from_vk<stormkit::gpu::ColorComponentFlag, VkColorComponentFlagBits>(VkColorComponentFlagBits);
template VkFlags                  stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::ColorComponentFlag);
template VkColorComponentFlagBits stormkit::gpu::to_vk<
  VkColorComponentFlagBits>(stormkit::gpu::ColorComponentFlag);

template stormkit::gpu::ColorSpace stormkit::gpu::from_vk<stormkit::gpu::ColorSpace,
                                                          VkFlags>(VkFlags);
template stormkit::gpu::ColorSpace stormkit::gpu::from_vk<stormkit::gpu::ColorSpace,
                                                          VkColorSpaceKHR>(VkColorSpaceKHR);
template VkFlags                   stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::ColorSpace);
template VkColorSpaceKHR           stormkit::gpu::to_vk<VkColorSpaceKHR>(stormkit::gpu::ColorSpace);

template stormkit::gpu::CommandBufferLevel stormkit::gpu::from_vk<stormkit::gpu::CommandBufferLevel,
                                                                  VkFlags>(VkFlags);
template stormkit::gpu::CommandBufferLevel stormkit::gpu::
  from_vk<stormkit::gpu::CommandBufferLevel, VkCommandBufferLevel>(VkCommandBufferLevel);
template VkFlags              stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::CommandBufferLevel);
template VkCommandBufferLevel stormkit::gpu::to_vk<
  VkCommandBufferLevel>(stormkit::gpu::CommandBufferLevel);

template stormkit::gpu::CompareOperation stormkit::gpu::from_vk<stormkit::gpu::CompareOperation,
                                                                VkFlags>(VkFlags);
template stormkit::gpu::CompareOperation stormkit::gpu::from_vk<stormkit::gpu::CompareOperation,
                                                                VkCompareOp>(VkCompareOp);
template VkFlags     stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::CompareOperation);
template VkCompareOp stormkit::gpu::to_vk<VkCompareOp>(stormkit::gpu::CompareOperation);

template stormkit::gpu::CullModeFlag stormkit::gpu::from_vk<stormkit::gpu::CullModeFlag,
                                                            VkFlags>(VkFlags);
template stormkit::gpu::CullModeFlag stormkit::gpu::from_vk<stormkit::gpu::CullModeFlag,
                                                            VkCullModeFlagBits>(VkCullModeFlagBits);
template VkFlags                     stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::CullModeFlag);
template VkCullModeFlagBits stormkit::gpu::to_vk<VkCullModeFlagBits>(stormkit::gpu::CullModeFlag);

template stormkit::gpu::DebugObjectType stormkit::gpu::from_vk<stormkit::gpu::DebugObjectType,
                                                               VkFlags>(VkFlags);
template stormkit::gpu::DebugObjectType stormkit::gpu::from_vk<stormkit::gpu::DebugObjectType,
                                                               VkObjectType>(VkObjectType);
template VkFlags      stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::DebugObjectType);
template VkObjectType stormkit::gpu::to_vk<VkObjectType>(stormkit::gpu::DebugObjectType);

template stormkit::gpu::DependencyFlag stormkit::gpu::from_vk<stormkit::gpu::DependencyFlag,
                                                              VkFlags>(VkFlags);
template stormkit::gpu::DependencyFlag stormkit::gpu::
  from_vk<stormkit::gpu::DependencyFlag, VkDependencyFlagBits>(VkDependencyFlagBits);
template VkFlags              stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::DependencyFlag);
template VkDependencyFlagBits stormkit::gpu::to_vk<
  VkDependencyFlagBits>(stormkit::gpu::DependencyFlag);

template stormkit::gpu::DescriptorType stormkit::gpu::from_vk<stormkit::gpu::DescriptorType,
                                                              VkFlags>(VkFlags);
template stormkit::gpu::DescriptorType stormkit::gpu::from_vk<stormkit::gpu::DescriptorType,
                                                              VkDescriptorType>(VkDescriptorType);
template VkFlags                       stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::DescriptorType);
template VkDescriptorType stormkit::gpu::to_vk<VkDescriptorType>(stormkit::gpu::DescriptorType);

template stormkit::gpu::DynamicState stormkit::gpu::from_vk<stormkit::gpu::DynamicState,
                                                            VkFlags>(VkFlags);
template stormkit::gpu::DynamicState stormkit::gpu::from_vk<stormkit::gpu::DynamicState,
                                                            VkDynamicState>(VkDynamicState);
template VkFlags                     stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::DynamicState);
template VkDynamicState stormkit::gpu::to_vk<VkDynamicState>(stormkit::gpu::DynamicState);

template stormkit::gpu::Filter stormkit::gpu::from_vk<stormkit::gpu::Filter, VkFlags>(VkFlags);
template stormkit::gpu::Filter stormkit::gpu::from_vk<stormkit::gpu::Filter, VkFilter>(VkFilter);
template VkFlags               stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::Filter);
template VkFilter              stormkit::gpu::to_vk<VkFilter>(stormkit::gpu::Filter);

template stormkit::gpu::FormatFeatureFlag stormkit::gpu::from_vk<stormkit::gpu::FormatFeatureFlag,
                                                                 VkFlags>(VkFlags);
template stormkit::gpu::FormatFeatureFlag stormkit::gpu::
  from_vk<stormkit::gpu::FormatFeatureFlag, VkFormatFeatureFlagBits>(VkFormatFeatureFlagBits);
template VkFlags                 stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::FormatFeatureFlag);
template VkFormatFeatureFlagBits stormkit::gpu::to_vk<
  VkFormatFeatureFlagBits>(stormkit::gpu::FormatFeatureFlag);

template stormkit::gpu::FrontFace stormkit::gpu::from_vk<stormkit::gpu::FrontFace,
                                                         VkFlags>(VkFlags);
template stormkit::gpu::FrontFace stormkit::gpu::from_vk<stormkit::gpu::FrontFace,
                                                         VkFrontFace>(VkFrontFace);
template VkFlags                  stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::FrontFace);
template VkFrontFace              stormkit::gpu::to_vk<VkFrontFace>(stormkit::gpu::FrontFace);

template stormkit::gpu::GeometryFlag stormkit::gpu::from_vk<stormkit::gpu::GeometryFlag,
                                                            VkFlags>(VkFlags);
template stormkit::gpu::GeometryFlag stormkit::gpu::
  from_vk<stormkit::gpu::GeometryFlag, VkGeometryFlagBitsKHR>(VkGeometryFlagBitsKHR);
template VkFlags               stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::GeometryFlag);
template VkGeometryFlagBitsKHR stormkit::gpu::to_vk<
  VkGeometryFlagBitsKHR>(stormkit::gpu::GeometryFlag);

template stormkit::gpu::GeometryType stormkit::gpu::from_vk<stormkit::gpu::GeometryType,
                                                            VkFlags>(VkFlags);
template stormkit::gpu::GeometryType stormkit::gpu::from_vk<stormkit::gpu::GeometryType,
                                                            VkGeometryTypeKHR>(VkGeometryTypeKHR);
template VkFlags                     stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::GeometryType);
template VkGeometryTypeKHR stormkit::gpu::to_vk<VkGeometryTypeKHR>(stormkit::gpu::GeometryType);

template stormkit::gpu::ImageAspectFlag stormkit::gpu::from_vk<stormkit::gpu::ImageAspectFlag,
                                                               VkFlags>(VkFlags);
template stormkit::gpu::ImageAspectFlag stormkit::gpu::
  from_vk<stormkit::gpu::ImageAspectFlag, VkImageAspectFlagBits>(VkImageAspectFlagBits);
template VkFlags               stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::ImageAspectFlag);
template VkImageAspectFlagBits stormkit::gpu::to_vk<
  VkImageAspectFlagBits>(stormkit::gpu::ImageAspectFlag);

template stormkit::gpu::ImageCreateFlag stormkit::gpu::from_vk<stormkit::gpu::ImageCreateFlag,
                                                               VkFlags>(VkFlags);
template stormkit::gpu::ImageCreateFlag stormkit::gpu::
  from_vk<stormkit::gpu::ImageCreateFlag, VkImageCreateFlagBits>(VkImageCreateFlagBits);
template VkFlags               stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::ImageCreateFlag);
template VkImageCreateFlagBits stormkit::gpu::to_vk<
  VkImageCreateFlagBits>(stormkit::gpu::ImageCreateFlag);

template stormkit::gpu::ImageLayout stormkit::gpu::from_vk<stormkit::gpu::ImageLayout,
                                                           VkFlags>(VkFlags);
template stormkit::gpu::ImageLayout stormkit::gpu::from_vk<stormkit::gpu::ImageLayout,
                                                           VkImageLayout>(VkImageLayout);
template VkFlags                    stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::ImageLayout);
template VkImageLayout              stormkit::gpu::to_vk<VkImageLayout>(stormkit::gpu::ImageLayout);

template stormkit::gpu::ImageTiling stormkit::gpu::from_vk<stormkit::gpu::ImageTiling,
                                                           VkFlags>(VkFlags);
template stormkit::gpu::ImageTiling stormkit::gpu::from_vk<stormkit::gpu::ImageTiling,
                                                           VkImageTiling>(VkImageTiling);
template VkFlags                    stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::ImageTiling);
template VkImageTiling              stormkit::gpu::to_vk<VkImageTiling>(stormkit::gpu::ImageTiling);

template stormkit::gpu::ImageType stormkit::gpu::from_vk<stormkit::gpu::ImageType,
                                                         VkFlags>(VkFlags);
template stormkit::gpu::ImageType stormkit::gpu::from_vk<stormkit::gpu::ImageType,
                                                         VkImageType>(VkImageType);
template VkFlags                  stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::ImageType);
template VkImageType              stormkit::gpu::to_vk<VkImageType>(stormkit::gpu::ImageType);

template stormkit::gpu::ImageUsageFlag stormkit::gpu::from_vk<stormkit::gpu::ImageUsageFlag,
                                                              VkFlags>(VkFlags);
template stormkit::gpu::ImageUsageFlag stormkit::gpu::
  from_vk<stormkit::gpu::ImageUsageFlag, VkImageUsageFlagBits>(VkImageUsageFlagBits);
template VkFlags              stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::ImageUsageFlag);
template VkImageUsageFlagBits stormkit::gpu::to_vk<
  VkImageUsageFlagBits>(stormkit::gpu::ImageUsageFlag);

template stormkit::gpu::ImageViewType stormkit::gpu::from_vk<stormkit::gpu::ImageViewType,
                                                             VkFlags>(VkFlags);
template stormkit::gpu::ImageViewType stormkit::gpu::from_vk<stormkit::gpu::ImageViewType,
                                                             VkImageViewType>(VkImageViewType);
template VkFlags                      stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::ImageViewType);
template VkImageViewType stormkit::gpu::to_vk<VkImageViewType>(stormkit::gpu::ImageViewType);

template stormkit::gpu::LogicOperation stormkit::gpu::from_vk<stormkit::gpu::LogicOperation,
                                                              VkFlags>(VkFlags);
template stormkit::gpu::LogicOperation stormkit::gpu::from_vk<stormkit::gpu::LogicOperation,
                                                              VkLogicOp>(VkLogicOp);
template VkFlags                       stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::LogicOperation);
template VkLogicOp stormkit::gpu::to_vk<VkLogicOp>(stormkit::gpu::LogicOperation);

template stormkit::gpu::MemoryPropertyFlag stormkit::gpu::from_vk<stormkit::gpu::MemoryPropertyFlag,
                                                                  VkFlags>(VkFlags);
template stormkit::gpu::MemoryPropertyFlag stormkit::gpu::
  from_vk<stormkit::gpu::MemoryPropertyFlag, VkMemoryPropertyFlagBits>(VkMemoryPropertyFlagBits);
template VkFlags                  stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::MemoryPropertyFlag);
template VkMemoryPropertyFlagBits stormkit::gpu::to_vk<
  VkMemoryPropertyFlagBits>(stormkit::gpu::MemoryPropertyFlag);

template stormkit::gpu::PhysicalDeviceType stormkit::gpu::from_vk<stormkit::gpu::PhysicalDeviceType,
                                                                  VkFlags>(VkFlags);
template stormkit::gpu::PhysicalDeviceType stormkit::gpu::
  from_vk<stormkit::gpu::PhysicalDeviceType, VkPhysicalDeviceType>(VkPhysicalDeviceType);
template VkFlags              stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::PhysicalDeviceType);
template VkPhysicalDeviceType stormkit::gpu::to_vk<
  VkPhysicalDeviceType>(stormkit::gpu::PhysicalDeviceType);

template stormkit::gpu::PipelineBindPoint stormkit::gpu::from_vk<stormkit::gpu::PipelineBindPoint,
                                                                 VkFlags>(VkFlags);
template stormkit::gpu::PipelineBindPoint stormkit::gpu::
  from_vk<stormkit::gpu::PipelineBindPoint, VkPipelineBindPoint>(VkPipelineBindPoint);
template VkFlags             stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::PipelineBindPoint);
template VkPipelineBindPoint stormkit::gpu::to_vk<
  VkPipelineBindPoint>(stormkit::gpu::PipelineBindPoint);

template stormkit::gpu::PipelineStageFlag stormkit::gpu::from_vk<stormkit::gpu::PipelineStageFlag,
                                                                 VkFlags>(VkFlags);
template stormkit::gpu::PipelineStageFlag stormkit::gpu::
  from_vk<stormkit::gpu::PipelineStageFlag, VkPipelineStageFlagBits>(VkPipelineStageFlagBits);
template VkFlags                 stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::PipelineStageFlag);
template VkPipelineStageFlagBits stormkit::gpu::to_vk<
  VkPipelineStageFlagBits>(stormkit::gpu::PipelineStageFlag);

template stormkit::gpu::PixelFormat stormkit::gpu::from_vk<stormkit::gpu::PixelFormat,
                                                           VkFlags>(VkFlags);
template stormkit::gpu::PixelFormat stormkit::gpu::from_vk<stormkit::gpu::PixelFormat,
                                                           VkFormat>(VkFormat);
template VkFlags                    stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::PixelFormat);
template VkFormat                   stormkit::gpu::to_vk<VkFormat>(stormkit::gpu::PixelFormat);

template stormkit::gpu::PolygonMode stormkit::gpu::from_vk<stormkit::gpu::PolygonMode,
                                                           VkFlags>(VkFlags);
template stormkit::gpu::PolygonMode stormkit::gpu::from_vk<stormkit::gpu::PolygonMode,
                                                           VkPolygonMode>(VkPolygonMode);
template VkFlags                    stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::PolygonMode);
template VkPolygonMode              stormkit::gpu::to_vk<VkPolygonMode>(stormkit::gpu::PolygonMode);

template stormkit::gpu::PresentMode stormkit::gpu::from_vk<stormkit::gpu::PresentMode,
                                                           VkFlags>(VkFlags);
template stormkit::gpu::PresentMode stormkit::gpu::from_vk<stormkit::gpu::PresentMode,
                                                           VkPresentModeKHR>(VkPresentModeKHR);
template VkFlags                    stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::PresentMode);
template VkPresentModeKHR stormkit::gpu::to_vk<VkPresentModeKHR>(stormkit::gpu::PresentMode);

template stormkit::gpu::PrimitiveTopology stormkit::gpu::from_vk<stormkit::gpu::PrimitiveTopology,
                                                                 VkFlags>(VkFlags);
template stormkit::gpu::PrimitiveTopology stormkit::gpu::
  from_vk<stormkit::gpu::PrimitiveTopology, VkPrimitiveTopology>(VkPrimitiveTopology);
template VkFlags             stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::PrimitiveTopology);
template VkPrimitiveTopology stormkit::gpu::to_vk<
  VkPrimitiveTopology>(stormkit::gpu::PrimitiveTopology);

template stormkit::gpu::QueueFlag stormkit::gpu::from_vk<stormkit::gpu::QueueFlag,
                                                         VkFlags>(VkFlags);
template stormkit::gpu::QueueFlag stormkit::gpu::from_vk<stormkit::gpu::QueueFlag,
                                                         VkQueueFlagBits>(VkQueueFlagBits);
template VkFlags                  stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::QueueFlag);
template VkQueueFlagBits          stormkit::gpu::to_vk<VkQueueFlagBits>(stormkit::gpu::QueueFlag);

template stormkit::gpu::Result stormkit::gpu::from_vk<stormkit::gpu::Result, VkFlags>(VkFlags);
template stormkit::gpu::Result stormkit::gpu::from_vk<stormkit::gpu::Result, VkResult>(VkResult);
template VkFlags               stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::Result);
template VkResult              stormkit::gpu::to_vk<VkResult>(stormkit::gpu::Result);

template stormkit::gpu::SampleCountFlag stormkit::gpu::from_vk<stormkit::gpu::SampleCountFlag,
                                                               VkFlags>(VkFlags);
template stormkit::gpu::SampleCountFlag stormkit::gpu::
  from_vk<stormkit::gpu::SampleCountFlag, VkSampleCountFlagBits>(VkSampleCountFlagBits);
template VkFlags               stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::SampleCountFlag);
template VkSampleCountFlagBits stormkit::gpu::to_vk<
  VkSampleCountFlagBits>(stormkit::gpu::SampleCountFlag);

template stormkit::gpu::SamplerAddressMode stormkit::gpu::from_vk<stormkit::gpu::SamplerAddressMode,
                                                                  VkFlags>(VkFlags);
template stormkit::gpu::SamplerAddressMode stormkit::gpu::
  from_vk<stormkit::gpu::SamplerAddressMode, VkSamplerAddressMode>(VkSamplerAddressMode);
template VkFlags              stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::SamplerAddressMode);
template VkSamplerAddressMode stormkit::gpu::to_vk<
  VkSamplerAddressMode>(stormkit::gpu::SamplerAddressMode);

template stormkit::gpu::SamplerMipmapMode stormkit::gpu::from_vk<stormkit::gpu::SamplerMipmapMode,
                                                                 VkFlags>(VkFlags);
template stormkit::gpu::SamplerMipmapMode stormkit::gpu::
  from_vk<stormkit::gpu::SamplerMipmapMode, VkSamplerMipmapMode>(VkSamplerMipmapMode);
template VkFlags             stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::SamplerMipmapMode);
template VkSamplerMipmapMode stormkit::gpu::to_vk<
  VkSamplerMipmapMode>(stormkit::gpu::SamplerMipmapMode);

template stormkit::gpu::ShaderStageFlag stormkit::gpu::from_vk<stormkit::gpu::ShaderStageFlag,
                                                               VkFlags>(VkFlags);
template stormkit::gpu::ShaderStageFlag stormkit::gpu::
  from_vk<stormkit::gpu::ShaderStageFlag, VkShaderStageFlagBits>(VkShaderStageFlagBits);
template VkFlags               stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::ShaderStageFlag);
template VkShaderStageFlagBits stormkit::gpu::to_vk<
  VkShaderStageFlagBits>(stormkit::gpu::ShaderStageFlag);

template stormkit::gpu::StencilFaceFlag stormkit::gpu::from_vk<stormkit::gpu::StencilFaceFlag,
                                                               VkFlags>(VkFlags);
template stormkit::gpu::StencilFaceFlag stormkit::gpu::
  from_vk<stormkit::gpu::StencilFaceFlag, VkStencilFaceFlagBits>(VkStencilFaceFlagBits);
template VkFlags               stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::StencilFaceFlag);
template VkStencilFaceFlagBits stormkit::gpu::to_vk<
  VkStencilFaceFlagBits>(stormkit::gpu::StencilFaceFlag);

template stormkit::gpu::VertexInputRate stormkit::gpu::from_vk<stormkit::gpu::VertexInputRate,
                                                               VkFlags>(VkFlags);
template stormkit::gpu::VertexInputRate stormkit::gpu::
  from_vk<stormkit::gpu::VertexInputRate, VkVertexInputRate>(VkVertexInputRate);
template VkFlags           stormkit::gpu::to_vk<VkFlags>(stormkit::gpu::VertexInputRate);
template VkVertexInputRate stormkit::gpu::to_vk<VkVertexInputRate>(stormkit::gpu::VertexInputRate);
