// Copyright (C) 2024 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

module;

#include <stormkit/core/platform_macro.hpp>

export module stormkit.core:math.linear.matrix;

import std;

import :meta.traits;
import :meta.concepts;

import :typesafe.integer;
import :typesafe.floating_point;

import :math.linear;

export namespace stormkit { inline namespace core { namespace math {
    template<typename T, usize M, usize N>
    using MatrixSpan = TensorSpan<T, M, N>;

    template<typename T, usize M, usize N>
    struct alignas(std::array<T, M * N>) mat {
        using value_type  = T;
        using size_type   = usize;
        using extent_type = u8;

        static constexpr auto EXTENT = std::array<extent_type, 2> { M, N };

        std::array<T, M * N> data;

        template<typename Self>
        constexpr auto operator[](this Self& self, usize i, usize j) noexcept
          -> meta::ForwardConst<Self, value_type&>;
    };

    template<typename T>
    using mat2x2 = mat<T, 2, 2>;

    using mat2x2f32 = mat2x2<f32>;
    using mat2x2f64 = mat2x2<f64>;
    using mat2x2f   = mat2x2f32;
    using mat2f     = mat2x2f;

    using mat2x2i32 = mat2x2<i32>;
    using mat2x2i64 = mat2x2<i64>;
    using mat2x2i   = mat2x2i32;
    using mat2i     = mat2x2i;

    using mat2x2u32 = mat2x2<u32>;
    using mat2x2u64 = mat2x2<u64>;
    using mat2x2u   = mat2x2u32;
    using mat2u     = mat2x2u;

    template<typename T>
    using mat3x3 = mat<T, 3, 3>;

    using mat3x3f32 = mat3x3<f32>;
    using mat3x3f64 = mat3x3<f64>;
    using mat3x3f   = mat3x3f32;
    using mat2f     = mat2x2f;

    using mat3x3i32 = mat3x3<i32>;
    using mat3x3i64 = mat3x3<i64>;
    using mat3x3i   = mat3x3i32;
    using mat3i     = mat3x3i;

    using mat3x3u32 = mat3x3<u32>;
    using mat3x3u64 = mat3x3<u64>;
    using mat3x3u   = mat3x3u32;
    using mat3u     = mat3x3u;

    template<typename T>
    using mat4x4 = mat<T, 4, 4>;

    using mat4x4f32 = mat4x4<f32>;
    using mat4x4f64 = mat4x4<f64>;
    using mat4x4f   = mat4x4f32;
    using mat4f     = mat4x4f;

    using mat4x4i32 = mat4x4<i32>;
    using mat4x4i64 = mat4x4<i64>;
    using mat4x4i   = mat4x4i32;
    using mat4i     = mat4x4i;

    using mat4x4u32 = mat4x4<u32>;
    using mat4x4u64 = mat4x4<u64>;
    using mat4x4u   = mat4x4u32;
    using mat4u     = mat4x4u;

    namespace meta {
        template<typename T>
        concept IsMat = core::meta::IsSpecializationWithNTTPOf<T, mat>;

        template<typename T, typename U>
        concept HasOneMatType = not(core::meta::IsMdspanType<T> and core::meta::IsMdspanType<U>)
                                or meta::IsMat<T>
                                or meta::IsMat<U>;
    } // namespace meta

    template<meta::IsMat T>
    [[nodiscard]]
    constexpr auto as_mdspan(T& value) noexcept
      -> MatrixSpan<core::meta::ForwardConst<T, typename T::value_type>,
                    T::EXTENT[0],
                    T::EXTENT[1]>;
}}} // namespace stormkit::core::math

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit { inline namespace core { namespace math {
    static_assert(sizeof(mat2x2i32) == sizeof(i32) * 2 * 2);
    static_assert(sizeof(mat2x2i64) == sizeof(i64) * 2 * 2);
    static_assert(sizeof(mat2x2u32) == sizeof(u32) * 2 * 2);
    static_assert(sizeof(mat2x2u64) == sizeof(u64) * 2 * 2);
    static_assert(sizeof(mat2x2f32) == sizeof(f32) * 2 * 2);
    static_assert(sizeof(mat2x2f64) == sizeof(f64) * 2 * 2);

    static_assert(sizeof(mat3x3i32) == sizeof(i32) * 3 * 3);
    static_assert(sizeof(mat3x3i64) == sizeof(i64) * 3 * 3);
    static_assert(sizeof(mat3x3u32) == sizeof(u32) * 3 * 3);
    static_assert(sizeof(mat3x3u64) == sizeof(u64) * 3 * 3);
    static_assert(sizeof(mat3x3f32) == sizeof(f32) * 3 * 3);
    static_assert(sizeof(mat3x3f64) == sizeof(f64) * 3 * 3);

    static_assert(sizeof(mat4x4i32) == sizeof(i32) * 4 * 4);
    static_assert(sizeof(mat4x4i64) == sizeof(i64) * 4 * 4);
    static_assert(sizeof(mat4x4u32) == sizeof(u32) * 4 * 4);
    static_assert(sizeof(mat4x4u64) == sizeof(u64) * 4 * 4);
    static_assert(sizeof(mat4x4f32) == sizeof(f32) * 4 * 4);
    static_assert(sizeof(mat4x4f64) == sizeof(f64) * 4 * 4);

    ////////////////////////////////////////
    ////////////////////////////////////////
    template<meta::IsMat T>
    STORMKIT_CONST STORMKIT_FORCE_INLINE
    constexpr auto as_mdspan(T& value) noexcept
      -> MatrixSpan<core::meta::ForwardConst<T, typename T::value_type>,
                    T::EXTENT[0],
                    T::EXTENT[1]> {
        return MatrixSpan<core::meta::ForwardConst<T, typename T::value_type>,
                          T::EXTENT[0],
                          T::EXTENT[1]> { &value.x, T::EXTENT };
    }
}}} // namespace stormkit::core::math
