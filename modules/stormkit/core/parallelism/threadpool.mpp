// Copyright (C) 2024 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

module;

#include <stormkit/core/platform_macro.hpp>

export module stormkit.core:parallelism.threadpool;

import std;

import :utils.algorithms;
import :utils.numeric_range;
import :typesafe.integer;
import :parallelism.threadutils;

export namespace stormkit { inline namespace core {
    class STORMKIT_API ThreadPool {
      public:
        static constexpr struct NoFutureType {
        } NoFuture;

        template<class T>
        using Callback = std::function<T()>;

        explicit ThreadPool(Int worker_count = std::thread::hardware_concurrency() / 2);
        ~ThreadPool();

        ThreadPool(const ThreadPool&)                    = delete;
        auto operator=(const ThreadPool&) -> ThreadPool& = delete;

        ThreadPool(ThreadPool&&) noexcept;
        auto operator=(ThreadPool&&) noexcept -> ThreadPool&;

        auto worker_count() const noexcept;

        template<class T>
        auto post_task(Callback<T> callback);

        template<class T>
        auto post_task(Callback<T> callback, NoFutureType);

        auto join_all() -> void;

        auto set_name(std::string_view name) noexcept -> void;

      private:
        struct Task {
            enum class Type {
                Standard,
                Terminate
            };

            Task() = default;

            STORMKIT_INLINE Task(Type _type, std::function<void()> _work)
                : type { _type }, work { std::move(_work) } {}

            Task(Task&&) noexcept                    = default;
            auto operator=(Task&&) noexcept -> Task& = default;

            Type                  type;
            std::function<void()> work;
        };

        template<class T>
        auto post_task(Task::Type type, Callback<T> callback);

        template<class T>
        auto post_task(Task::Type type, Callback<T> callback, NoFutureType);

        auto worker_main() noexcept -> void;

        Int m_worker_count = 0;

        std::vector<std::thread> m_workers;

        mutable std::mutex      m_mutex;
        std::condition_variable m_work_signal;
        std::queue<Task>        m_tasks;
    };

    template<std::ranges::range Range, std::invocable<class Range::element_type&> F>
    auto parallel_for(ThreadPool& pool, Range&& range, F&& f);

    template<std::ranges::range Range, std::invocable<class Range::element_type&> F>
    auto parallel_transform(ThreadPool& pool, Range&& range, F&& f)
        -> std::future<std::invoke_result_t<F, typename Range::element_type&>>;

    template<std::ranges::range                         Range,
             std::predicate<class Range::element_type&> Predicate,
             std::invocable<class Range::element_type&> F>
    auto parallel_transform_if(ThreadPool& pool, Range&& range, Predicate&& predicate, F&& f)
        -> std::future<std::invoke_result_t<F, typename Range::element_type&>>;
}} // namespace stormkit::core

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit { inline namespace core {
    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE ThreadPool::ThreadPool(Int worker_count)
        : m_worker_count { worker_count } {
        m_workers.reserve(m_worker_count);

        for (const auto i : range(m_worker_count)) {
            auto& worker = m_workers.emplace_back([this] { worker_main(); });
            set_thread_name(worker, std::format("StormKit:WorkerThread:{}", i));
        }
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE ThreadPool::~ThreadPool() {
        join_all();
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    STORMKIT_FORCE_INLINE auto ThreadPool::worker_count() const noexcept {
        return m_worker_count;
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    STORMKIT_FORCE_INLINE auto ThreadPool::set_name(std::string_view name) noexcept -> void {
        // for (auto&& [i, worker] : m_workers | std::views::enumerate) {
        auto i = 0;
        for (auto&& worker : m_workers) { set_thread_name(worker, std::format("{}:{}", name, i++)); }
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    template<class T>
    STORMKIT_FORCE_INLINE auto ThreadPool::post_task(Callback<T> callback) {
        return post_task<T>(Task::Type::Standard, std::move(callback));
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    template<class T>
    STORMKIT_FORCE_INLINE auto ThreadPool::post_task(Callback<T> callback, NoFutureType t) {
        post_task<T>(Task::Type::Standard, std::move(callback), t);
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    template<class T>
    auto ThreadPool::post_task(Task::Type type, Callback<T> callback) {
        auto packaged_task = std::make_shared<std::packaged_task<T()>>(std::move(callback));

        auto future = packaged_task->get_future();

        auto task = Task { type, [callback = std::move(packaged_task)]() { (*callback)(); } };

        {
            auto lock = std::unique_lock { m_mutex };

            m_tasks.emplace(std::move(task));
        }

        m_work_signal.notify_one();

        return future;
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    template<class T>
    auto ThreadPool::post_task(Task::Type type, Callback<T> callback, NoFutureType) {
        auto task = Task { type, [callback = std::move(callback)]() { callback(); } };

        {
            auto lock = std::unique_lock { m_mutex };

            m_tasks.emplace(std::move(task));
        }

        m_work_signal.notify_one();
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    template<std::ranges::range Range, std::invocable<class Range::element_type&> F>
    auto parallel_for(ThreadPool& pool, Range&& range, F&& f) {
        if constexpr (std::is_rvalue_reference_v<Range>) {
            return pool.post_task<void>([range = std::move(range), f = std::forward<F>(f)]() {
                auto futures = core::transform(range, [f = std::forward<F>(f)](auto& elem) {
                    return f(elem);
                });

                for (auto& future : futures) future.wait();
            });
        } else {
            return pool.post_task<void>([&range, f = std::forward<F>(f)]() {
                auto futures = core::transform(range, [f = std::forward<F>(f)](auto& elem) {
                    return f(elem);
                });

                for (auto& future : futures) future.wait();
            });
        }
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    template<std::ranges::range Range, std::invocable<class Range::element_type&> F>
    auto parallel_transform(ThreadPool& pool, Range&& range, F&& f)
        -> std::future<std::invoke_result_t<F, typename Range::element_type&>> {
        using Element    = typename Range::element_type;
        using OutputType = std::invoke_result_t<F, Element&>;

        if constexpr (std::is_rvalue_reference_v<Range>) {
            return pool.post_task<std::vector<class Range::element_type&>>(
                [range = std::move(range), f = std::forward<F>(f), &pool]() {
                    auto tasks = core::transform(range, [f = std::forward<F>(f)](auto& elem) {
                        return f(elem);
                    });

                    auto futures = core::transform(tasks, [&pool](auto& l) {
                        return pool.post_task<OutputType>(std::move(l));
                    });

                    return core::transform(futures, [](auto& future) { return future.get(); });
                });
        } else {
            return pool.post_task<std::vector<class Range::element_type&>>(
                [&range, f = std::forward<F>(f), &pool]() {
                    auto tasks = core::transform(range, [f = std::forward<F>(f)](auto& elem) {
                        return f(elem);
                    });

                    auto futures = core::transform(tasks, [&pool](auto& l) {
                        return pool.post_task<OutputType>(std::move(l));
                    });

                    return core::transform(futures, [](auto& future) { return future.get(); });
                });
        }
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    template<std::ranges::range                         Range,
             std::predicate<class Range::element_type&> Predicate,
             std::invocable<class Range::element_type&> F>
    auto parallel_transform_if(ThreadPool& pool, Range&& range, Predicate&& predicate, F&& f)
        -> std::future<std::invoke_result_t<F, typename Range::element_type&>> {
        using Element    = typename Range::element_type;
        using OutputType = std::invoke_result_t<F, Element&>;

        if constexpr (std::is_rvalue_reference_v<Range>) {
            return pool.post_task<std::vector<class Range::element_type&>>(
                [range     = std::move(range),
                 f         = std::forward<F>(f),
                 predicate = std::forward<Predicate>(predicate),
                 &pool]() {
                    auto tasks
                        = core::transform_if(range, predicate, [f = std::forward<F>(f)](auto& elem) {
                              return f(elem);
                          });

                    auto futures = core::transform(tasks, [&pool](auto& l) {
                        return pool.post_task<OutputType>(std::move(l));
                    });

                    return core::transform(futures, [](auto& future) { return future.get(); });
                });
        } else {
            return pool.post_task<std::vector<class Range::element_type&>>(
                [&range,
                 f         = std::forward<F>(f),
                 predicate = std::forward<Predicate>(predicate),
                 &pool]() {
                    auto tasks
                        = core::transform_if(range, predicate, [f = std::forward<F>(f)](auto& elem) {
                              return f(elem);
                          });

                    auto futures = core::transform(tasks, [&pool](auto& l) {
                        return pool.post_task<OutputType>(std::move(l));
                    });

                    return core::transform(futures, [](auto& future) { return future.get(); });
                });
        }
    }
}} // namespace stormkit::core
