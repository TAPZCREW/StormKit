// Copyright (C) 2024 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

export module stormkit.Image:QOIImage;

import std;

import frozen;

import stormkit.core;
import stormkit.Image;

export namespace stormkit::image::details {
    [[nodiscard]] auto loadQOI(std::span<const Byte> data) noexcept
        -> std::expected<image::Image, image::Image::Error>;

    [[nodiscard]] auto saveQOI(const image::Image&          image,
                               const std::filesystem::path& filepath) noexcept
        -> std::expected<void, image::Image::Error>;

    [[nodiscard]] auto saveQOI(const image::Image& image) noexcept
        -> std::expected<std::vector<Byte>, image::Image::Error>;
} // namespace stormkit::image::details

using namespace std::literals;

namespace stormkit::image::details {
    template<class E>
    using Unexpected = std::unexpected<E>;
    using Error      = image::Image::Error;
    using Reason     = image::Image::Error::Reason;

    struct QOIHeader {
        std::array<Byte, 4> magic;
        UInt32              width;
        UInt32              height;
        UInt8               channels;
        UInt8               colorspace;
    };

    namespace {
        constexpr auto SIZE_OF_HEADER = 14;

        constexpr auto CHANNELS_TO_FORMAT
            = frozen::make_unordered_map<Int32, std::array<image::Image::Format, 2>>({
                { 3, std::array { image::Image::Format::sRGB8, image::Image::Format::RGB8_UNorm } },
                { 4,
                 std::array { image::Image::Format::sRGBA8,
                               image::Image::Format::RGBA8_UNorm }                                }
        });

        constexpr auto END_OF_FILE = into_bytes(0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01);

        constexpr auto PIXEL_CACHE_SIZE = 64u;
    } // namespace

    enum class QOI_OPERATION : UInt8 {
        RGB   = 0b11111110,
        RGBA  = 0b11111111,
        INDEX = 0b00000000,
        DIFF  = 0b01000000,
        LUMA  = 0b10000000,
        RUN   = 0b11000000,
    };

    union Pixel {
        struct {
            UInt8 r = 0;
            UInt8 g = 0;
            UInt8 b = 0;
            UInt8 a = 0;
        } rgba;

        std::array<UInt8, 4> data;
    };

    /////////////////////////////////////
    /////////////////////////////////////
    constexpr auto indexHash(const Pixel& pixel) noexcept {
        return (pixel.rgba.r * 3u + pixel.rgba.g * 5u + pixel.rgba.b * 7u + pixel.rgba.a * 11u)
               % PIXEL_CACHE_SIZE;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    auto loadQOI([[maybe_unused]] std::span<const Byte> data) noexcept
        -> std::expected<image::Image, image::Image::Error> {
        const auto  raw_header = std::span<const Byte> { std::data(data), SIZE_OF_HEADER };
        const auto* header     = std::bit_cast<const QOIHeader*>(std::data(raw_header));

        const auto extent   = math::ExtentU { byte_swap(header->width), byte_swap(header->height) };
        const auto channels = header->channels;
        const auto format   = CHANNELS_TO_FORMAT.at(header->channels)[header->colorspace];

        auto pixel_cache = std::array<Pixel, PIXEL_CACHE_SIZE> {};

        const auto chunks
            = std::span { std::bit_cast<const UInt8*>(std::data(data)) + SIZE_OF_HEADER,
                          std::size(data) - SIZE_OF_HEADER };

        const auto output_size = extent.width * extent.height * channels;

        auto output = std::vector<Byte> {};
        output.reserve(output_size);

        auto previous_pixel = Pixel { .rgba = { .a = 255 } };

        auto run = 0;

        const auto diff = 4 - channels;
        auto       it   = std::ranges::begin(chunks);

        const auto chunks_size = output_size - std::size(END_OF_FILE);
        for ([[maybe_unused]] auto _ : range(output_size, channels)) {
            const auto tag = *it;

            const auto position = as<RangeExtent>(std::distance(std::ranges::begin(chunks), it));

            if (run > 0) --run;
            else if (std::memcmp(&*it, std::data(END_OF_FILE), std::size(END_OF_FILE)) == 0)
                [[unlikely]] {
                it = std::ranges::cend(chunks);
            } else if (position < chunks_size) {
                ++it;
                if (static_cast<QOI_OPERATION>(tag) == QOI_OPERATION::RGB) {
                    previous_pixel.rgba.r = *it;
                    previous_pixel.rgba.g = *(it + 1);
                    previous_pixel.rgba.b = *(it + 2);

                    it += 3;
                } else if (static_cast<QOI_OPERATION>(tag) == QOI_OPERATION::RGBA) {
                    previous_pixel.rgba.r = *it;
                    previous_pixel.rgba.g = *(it + 1);
                    previous_pixel.rgba.b = *(it + 2);
                    previous_pixel.rgba.a = *(it + 3);

                    it += 4;
                } else {
#define CHECK(op) (tag & 0b11000000) == static_cast<UInt8>(op)
                    if (CHECK(QOI_OPERATION::INDEX)) {
                        const auto index = tag;

                        previous_pixel = pixel_cache[index];
                    } else if (CHECK(QOI_OPERATION::DIFF)) {
                        const auto r_diff = as<UInt8>(((tag >> 4) & 0x03) - 2);
                        const auto g_diff = as<UInt8>(((tag >> 2) & 0x03) - 2);
                        const auto b_diff = as<UInt8>((tag & 0x03) - 2);

                        previous_pixel.rgba.r += r_diff;
                        previous_pixel.rgba.g += g_diff;
                        previous_pixel.rgba.b += b_diff;

                    } else if (CHECK(QOI_OPERATION::LUMA)) {
                        const auto g_diff = (tag & 0x3f) - 32;

                        const auto current_r = ((*it) >> 4) & 0x0f;
                        const auto current_b = (*it) & 0x0f;

                        previous_pixel.rgba.r += as<UInt8>(g_diff - 8 + current_r);
                        previous_pixel.rgba.g += as<UInt8>(g_diff);
                        previous_pixel.rgba.b += as<UInt8>(g_diff - 8 + current_b);

                        ++it;
                    } else if (CHECK(QOI_OPERATION::RUN)) {
                        run = (tag & 0x3f);
                    }
#undef CHECK
                }

                auto& cached = pixel_cache[indexHash(previous_pixel)];
                cached       = previous_pixel;
            }

            std::ranges::transform(std::begin(previous_pixel.data),
                                   std::end(previous_pixel.data) - diff,
                                   std::back_inserter(output),
                                   monadic::as<Byte>());
        }

        auto image_data = image::Image::ImageData { .extent            = extent,
                                                    .channel_count     = channels,
                                                    .bytes_per_channel = getSizeof(format),
                                                    .layers            = 1u,
                                                    .faces             = 1u,
                                                    .mip_levels        = 1u,
                                                    .format            = format,
                                                    .data              = std::move(output)

        };

        return image::Image { std::move(image_data) };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    auto saveQOI(const image::Image& image, const std::filesystem::path& filepath) noexcept
        -> std::expected<void, image::Image::Error> {
        auto result = saveQOI(image);

        if (!result) return std::unexpected(result.error());

        auto stream = std::ofstream { filepath, std::ios::binary };
        write(stream, *result);

        return {};
    }

    /////////////////////////////////////
    /////////////////////////////////////
    [[nodiscard]] auto saveQOI([[maybe_unused]] const image::Image& image) noexcept
        -> std::expected<std::vector<Byte>, image::Image::Error> {
        return std::unexpected(
            Error { .reason = Reason::Not_Implemented, .str_error = "save to file" });
    }
} // namespace stormkit::image::details
