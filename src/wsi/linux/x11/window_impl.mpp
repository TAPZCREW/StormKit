// Copyright (C) 2021 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

module;

#include <stormkit/core/memory_macro.hpp>
#include <stormkit/core/platform_macro.hpp>

extern "C" {
    STORMKIT_PUSH_WARNINGS
#pragma GCC diagnostic ignored "-Wkeyword-macro"
#include <xkbcommon/xkbcommon-x11.h>
#include <xkbcommon/xkbcommon.h>

#include <xcb/xcb.h>
#define explicit _explicit
#include <xcb/xkb.h>
#undef explicit
#include <xcb/randr.h>
#include <xcb/xcb_icccm.h>
#include <xcb/xcb_keysyms.h>
#include <xcb/xfixes.h>
#include <xcb/xinput.h>
    STORMKIT_POP_WARNINGS
}

export module stormkit.wsi:linux.x11.window_impl;

import std;

import stormkit.core;
import stormkit.wsi;

import :common.window_impl_base;
import :linux.common.xkb;
import :linux.x11.xcb;
import :linux.x11.log;
import :linux.x11.utils;

namespace stdr = std::ranges;

export namespace stormkit::wsi::linux::x11 {
    STORMKIT_RAII_CAPSULE_OPAQUE(
      XCBWindow,
      xcb_window_t,
      []() noexcept { return XCB_WINDOW_NONE; },
      [](auto window) noexcept { xcb_destroy_window(get_xcb_connection(), window); },
      XCB_WINDOW_NONE)
    STORMKIT_RAII_CAPSULE(XCBKeySymbols, xcb_key_symbols_t, xcb_key_symbols_free)

    class WindowImpl: public ::stormkit::wsi::common::WindowImplBase {
      public:
        struct Handles {
            xcb_connection_t*  connection;
            xcb_window_t       window;
            xcb_key_symbols_t* key_symbols;
            xkb_state*         state;
        };

        WindowImpl();
        WindowImpl(std::string title, const math::Extent2<u32>& size, WindowStyle style);
        ~WindowImpl();

        WindowImpl(const WindowImpl&) noexcept                    = delete;
        auto operator=(const WindowImpl&) noexcept -> WindowImpl& = delete;

        WindowImpl(WindowImpl&&) noexcept;
        auto operator=(WindowImpl&&) noexcept -> WindowImpl&;

        auto create(std::string title, const math::Extent2<u32>& size, WindowStyle style) -> void;
        auto close() noexcept -> void;

        [[nodiscard]]
        auto poll_event(Event& event) noexcept -> bool;
        [[nodiscard]]
        auto wait_event(Event& event) noexcept -> bool;

        auto set_title(std::string title) noexcept -> void;
        auto set_extent(const math::Extent2<u32>& size) noexcept -> void;
        auto toggle_fullscreen(bool enabled) noexcept -> void;

        auto lock_mouse() noexcept -> void;
        auto unlock_mouse() noexcept -> void;

        auto hide_mouse() noexcept -> void;
        auto unhide_mouse() noexcept -> void;

        [[nodiscard]]
        auto extent() const noexcept -> const math::Extent2<u32>&;
        [[nodiscard]]
        auto title() const noexcept -> const std::string&;

        [[nodiscard]]
        auto is_open() const noexcept -> bool;
        [[nodiscard]]
        auto visible() const noexcept -> bool;

        [[nodiscard]]
        auto native_handle() const noexcept -> NativeHandle;
        [[nodiscard]]
        auto xcb_handles() const noexcept -> const Handles&;

        [[nodiscard]]
        auto is_mouse_locked() const noexcept -> bool;
        [[nodiscard]]
        auto mouseHidden() const noexcept -> bool;
        [[nodiscard]]
        auto fullscreen() const noexcept -> bool;

        auto toggle_key_repeat(bool enabled) noexcept -> void;
        [[nodiscard]]
        auto is_key_repeat_enabled() const noexcept -> bool;

        auto toggle_virtual_keyboard_visibility(bool visible) noexcept -> void;

        auto        set_mouse_position(const math::Vector2I& position) noexcept -> void;
        static auto set_mouse_position_on_desktop(const math::Vector2U& position) noexcept -> void;

        [[nodiscard]]
        static auto get_monitor_settings() -> std::vector<Monitor>;

      private:
        auto process_events(xcb_generic_event_t* xevent) -> void;
        auto update_keymap() -> void;

        auto handle_key_event(xcb_keycode_t keycode, bool up) noexcept -> void;

        Ref<xcb_connection_t>    m_connection;
        common::XKBContextScoped m_xkb_context = nullptr;
        XCBWindowScoped          m_window;
        XCBKeySymbolsScoped      m_key_symbols;

        common::XKBKeymapScoped m_xkb_keymap;
        common::XKBStateScoped  m_xkb_state;

        common::XKBMods m_xkb_mods;

        struct WindowHints {
            uint32_t flags       = 0;
            uint32_t functions   = 0;
            uint32_t decorations = 0;
            int32_t  input_mode  = 0;
            uint32_t state       = 0;
        } m_window_hints;

        std::string m_title;
        bool        m_is_mouse_locked = false;
        bool        m_mouse_hided     = false;
        bool        m_fullscreen      = false;

        math::Extent2<u32> m_extent;

        int m_xi_opcode;

        bool m_open               = false;
        bool m_visible            = false;
        bool m_key_repeat_enabled = true;

        Handles m_handles;

        math::Vector2I         m_locked_mouse_position;
        mutable math::Vector2I m_mouse_position;
    };
} // namespace stormkit::wsi::linux::x11

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit::wsi::linux::x11 {

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto WindowImpl::set_extent(const math::Extent2<u32>& extent) noexcept -> void {
        m_extent = extent;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto WindowImpl::title() const noexcept -> const std::string& {
        return m_title;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto WindowImpl::is_mouse_locked() const noexcept -> bool {
        return m_is_mouse_locked;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto WindowImpl::mouseHidden() const noexcept -> bool {
        return m_mouse_hided;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto WindowImpl::fullscreen() const noexcept -> bool {
        return m_fullscreen;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto WindowImpl::is_open() const noexcept -> bool {
        return m_open;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto WindowImpl::visible() const noexcept -> bool {
        return m_visible;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto WindowImpl::xcb_handles() const noexcept -> const Handles& {
        return m_handles;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto WindowImpl::extent() const noexcept -> const math::Extent2<u32>& {
        return m_extent;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto WindowImpl::is_key_repeat_enabled() const noexcept -> bool {
        return m_key_repeat_enabled;
    }
} // namespace stormkit::wsi::linux::x11

namespace stormkit::wsi::linux::x11 {
    namespace {
        [[maybe_unused]]
        constexpr auto WM_HINTS_STR
          = std::string_view("_MOTIF_WM_HINTS");
        constexpr auto WM_PROTOCOLS            = std::string_view("WM_PROTOCOLS");
        constexpr auto WM_DELETE_WINDOW        = std::string_view("WM_DELETE_WINDOW");
        constexpr auto WM_STATE_STR            = std::string_view("_NET_WM_STATE");
        constexpr auto WM_STATE_FULLSCREEN_STR = std::string_view("_NET_WM_STATE_FULLSCREEN");

        constexpr auto _NET_WM_STATE_REMOVE = 0; // remove/unset property
        constexpr auto _NET_WM_STATE_ADD    = 1; // add/set property
        [[maybe_unused]]
        constexpr auto _NET_WM_STATE_TOGGLE
          = 2; // toggle property

        constexpr auto MOUSE_RAW_EVENTS    = u32 { XCB_INPUT_XI_EVENT_MASK_RAW_BUTTON_PRESS
                                                | XCB_INPUT_XI_EVENT_MASK_RAW_BUTTON_RELEASE
                                                | XCB_INPUT_XI_EVENT_MASK_RAW_MOTION };
        constexpr auto KEYBOARD_RAW_EVENTS = u32 { XCB_INPUT_XI_EVENT_MASK_RAW_KEY_PRESS
                                                   | XCB_INPUT_XI_EVENT_MASK_RAW_KEY_RELEASE };
        constexpr auto KEYBOARD_EVENTS     = u32 { XCB_INPUT_XI_EVENT_MASK_KEY_PRESS
                                               | XCB_INPUT_XI_EVENT_MASK_KEY_RELEASE };

        constexpr auto XINPUT_MASK_MODIFIERS = u32 { XCB_INPUT_MODIFIER_MASK_ANY };
    } // namespace

    auto is_ext_event(xcb_generic_event_t* event, int opcode) noexcept -> bool {
        return std::bit_cast<xcb_ge_generic_event_t*>(event)->extension == opcode;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    WindowImpl::WindowImpl() : m_connection { get_xcb_connection() } {
        m_xkb_context = common::get_xkb_context();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    WindowImpl::WindowImpl(std::string title, const math::Extent2<u32>& extent, WindowStyle style)
        : WindowImpl {} {
        create(std::move(title), extent, style);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    WindowImpl::~WindowImpl() {
        xcb_flush(get_xcb_connection());
    }

    /////////////////////////////////////
    /////////////////////////////////////
    WindowImpl::WindowImpl(WindowImpl&&) noexcept = default;

    /////////////////////////////////////
    /////////////////////////////////////
    auto WindowImpl::operator=(WindowImpl&&) noexcept -> WindowImpl& = default;

    /////////////////////////////////////
    /////////////////////////////////////
    auto WindowImpl::create(std::string title, const math::Extent2<u32>& extent, WindowStyle style)
      -> void {
        if (xcb_connection_has_error(m_connection)) [[unlikely]] {
            elog("ERROR {}", std::bit_cast<void*>(m_connection.get()));
            return;
        }

        static constexpr const auto EVENTS = XCB_EVENT_MASK_FOCUS_CHANGE
                                             | XCB_EVENT_MASK_BUTTON_PRESS
                                             | XCB_EVENT_MASK_BUTTON_RELEASE
                                             | XCB_EVENT_MASK_BUTTON_MOTION
                                             | XCB_EVENT_MASK_POINTER_MOTION
                                             | XCB_EVENT_MASK_KEY_PRESS
                                             | XCB_EVENT_MASK_KEY_RELEASE
                                             | XCB_EVENT_MASK_STRUCTURE_NOTIFY
                                             | XCB_EVENT_MASK_ENTER_WINDOW
                                             | XCB_EVENT_MASK_LEAVE_WINDOW
                                             | XCB_EVENT_MASK_VISIBILITY_CHANGE
                                             | XCB_EVENT_MASK_PROPERTY_CHANGE
                                             | XCB_EVENT_MASK_EXPOSURE;

        auto screen = xcb_setup_roots_iterator(xcb_get_setup(m_connection)).data;
        m_window.reset(xcb_generate_id(m_connection));

        {
            u32  value_list[] = { screen->white_pixel, screen->black_pixel, EVENTS };
            auto cookie       = xcb_create_window_checked(m_connection,
                                                    XCB_COPY_FROM_PARENT,
                                                    m_window,
                                                    screen->root,
                                                    0,
                                                    0,
                                                    as<u16>(extent.width),
                                                    as<u16>(extent.height),
                                                    1,
                                                    XCB_WINDOW_CLASS_INPUT_OUTPUT,
                                                    screen->root_visual,
                                                    XCB_CW_BACK_PIXEL
                                                      | XCB_CW_BORDER_PIXEL
                                                      | XCB_CW_EVENT_MASK,
                                                    value_list);

            auto error = xcb_request_check(m_connection, cookie);
            if (error) [[unlikely]] {
                elog("Failed to create window\n    > reason: {}", get_xcb_error(as_ref_mut(error)));
                return;
            }
        }

        m_extent = extent;

        m_locked_mouse_position.x = m_extent.width / 2;
        m_locked_mouse_position.y = m_extent.height / 2;

        // init key_symbol map, this is needed to extract the keysymbol from event
        m_key_symbols.reset(xcb_key_symbols_alloc(m_connection));
        ensures(m_key_symbols.get(), "Failed to initialize XKB symbols map");

        auto xkb_ext_reply = xcb_get_extension_data(m_connection, &xcb_xkb_id);
        ensures(xkb_ext_reply, "Failed to get XCB_XKB extension data");
        {
            static constexpr auto major_version = XCB_XKB_MAJOR_VERSION;
            static constexpr auto minor_version = XCB_XKB_MINOR_VERSION;
            STORMKIT_RAII_CAPSULE(Reply, xcb_xkb_use_extension_reply_t, std::free)
            auto cookie = xcb_xkb_use_extension(m_connection, major_version, minor_version);
            auto reply = ReplyScoped { xcb_xkb_use_extension_reply(m_connection, cookie, nullptr) };

            ensures(reply != nullptr, "Failed to enable XCB_XKB extension");
            ensures(reply->supported, "The XCB_XKB extension is not supported on this X server");
            dlog("XCB_XKB extension loaded, version: {}.{}", major_version, minor_version);
        }

        auto xfixes_ext_reply = xcb_get_extension_data(m_connection, &xcb_xfixes_id);
        ensures(xfixes_ext_reply, "Failed to enable XCB_XFIXES extension");
        {
            STORMKIT_RAII_CAPSULE(Reply, xcb_xfixes_query_version_reply_t, std::free)

            auto cookie = xcb_xfixes_query_version(m_connection, 4, 0);
            auto reply  = ReplyScoped {
                xcb_xfixes_query_version_reply(m_connection, cookie, nullptr)
            };

            ensures(reply != nullptr, "Failed to query XCB_XFIXES extension version");
            dlog("XCB_XFIXES extension loaded, version: {}.{}",
                 reply->major_version,
                 reply->minor_version);
        }

        auto xcb_input_ext_reply = xcb_get_extension_data(m_connection, &xcb_input_id);
        ensures(xcb_input_ext_reply, "Failed to enable XCB_INPUT extension");
        {
            STORMKIT_RAII_CAPSULE(Reply, xcb_input_xi_query_version_reply_t, std::free)

            auto cookie = xcb_input_xi_query_version(m_connection, 2, XCB_INPUT_MINOR_VERSION);
            auto reply  = ReplyScoped {
                xcb_input_xi_query_version_reply(m_connection, cookie, nullptr)
            };

            ensures(reply != nullptr, "Failed to query XCB_INPUT_XI extension version");
            dlog("XCB_INPUT_XI extension loaded, version: {}.{}",
                 reply->major_version,
                 reply->minor_version);

            m_xi_opcode = xcb_input_ext_reply->major_opcode;
        }

        update_keymap();

        constexpr auto required_map_parts = u16 {
            XCB_XKB_MAP_PART_KEY_TYPES
            | XCB_XKB_MAP_PART_KEY_SYMS
            | XCB_XKB_MAP_PART_MODIFIER_MAP
            | XCB_XKB_MAP_PART_EXPLICIT_COMPONENTS
            | XCB_XKB_MAP_PART_KEY_ACTIONS
            | XCB_XKB_MAP_PART_KEY_BEHAVIORS
            | XCB_XKB_MAP_PART_VIRTUAL_MODS
            | XCB_XKB_MAP_PART_VIRTUAL_MOD_MAP
        };

        constexpr auto required_events = u16 { XCB_XKB_EVENT_TYPE_NEW_KEYBOARD_NOTIFY
                                               | XCB_XKB_EVENT_TYPE_MAP_NOTIFY
                                               | XCB_XKB_EVENT_TYPE_STATE_NOTIFY };

        // XKB events are reported to all interested clients without regard
        // to the current keyboard input focus or grab state
        xcb_xkb_select_events_checked(m_connection,
                                      XCB_XKB_ID_USE_CORE_KBD,
                                      required_events,
                                      0,
                                      required_events,
                                      required_map_parts,
                                      required_map_parts,
                                      nullptr);

        auto mask = KEYBOARD_EVENTS | MOUSE_RAW_EVENTS;

        xcb_input_xi_passive_grab_device(m_connection,
                                         XCB_CURRENT_TIME,
                                         m_window,
                                         XCB_CURSOR_NONE,
                                         0,
                                         XCB_INPUT_DEVICE_ALL,
                                         1,
                                         1,
                                         XCB_INPUT_GRAB_TYPE_BUTTON | XCB_INPUT_GRAB_TYPE_KEYCODE,
                                         XCB_INPUT_GRAB_MODE_22_ASYNC,
                                         XCB_INPUT_GRAB_MODE_22_ASYNC,
                                         XCB_INPUT_GRAB_OWNER_NO_OWNER,
                                         &mask,
                                         &XINPUT_MASK_MODIFIERS);

        // set the.wsi.name
        set_title(std::move(title));

        // set the.wsi.s style
        // checking if the.wsi.manager support.wsi.decoration
        constexpr auto MWM_HINTS_FUNCTIONS   = 1 << 0;
        constexpr auto MWM_HINTS_DECORATIONS = 1 << 1;

        constexpr auto MWM_DECOR_BORDER   = 1 << 1;
        constexpr auto MWM_DECOR_RESIZE   = 1 << 2;
        constexpr auto MWM_DECOR_TITLE    = 1 << 3;
        constexpr auto MWM_DECOR_MENU     = 1 << 4;
        constexpr auto MWM_DECOR_MINIMIZE = 1 << 5;
        constexpr auto MWM_DECOR_MAXIMIZE = 1 << 6;

        constexpr auto MWM_FUNC_RESIZE   = 1 << 1;
        constexpr auto MWM_FUNC_MOVE     = 1 << 2;
        constexpr auto MWM_FUNC_MINIMIZE = 1 << 3;
        constexpr auto MWM_FUNC_MAXIMIZE = 1 << 4;
        constexpr auto MWM_FUNC_CLOSE    = 1 << 5;

        m_window_hints.flags = MWM_HINTS_FUNCTIONS | MWM_HINTS_DECORATIONS;

        if (check_flag_bit(style, WindowStyle::TITLE_BAR)) {
            m_window_hints.decorations |= MWM_DECOR_BORDER | MWM_DECOR_TITLE | MWM_DECOR_MENU;
            m_window_hints.functions |= MWM_FUNC_MOVE;
        }

        if (check_flag_bit(style, WindowStyle::CLOSE)) {
            m_window_hints.decorations |= 0;
            m_window_hints.functions |= MWM_FUNC_CLOSE;
        }

        if (check_flag_bit(style, WindowStyle::MINIMIZABLE)) {
            m_window_hints.decorations |= MWM_DECOR_MINIMIZE;
            m_window_hints.functions |= MWM_FUNC_MINIMIZE;
        }

        if (check_flag_bit(style, WindowStyle::RESIZEABLE)) {
            m_window_hints.decorations |= MWM_DECOR_RESIZE | MWM_DECOR_MAXIMIZE;
            m_window_hints.functions |= MWM_FUNC_RESIZE | MWM_FUNC_MAXIMIZE;
        } else {
            auto size_hints = xcb_size_hints_t {};

            xcb_icccm_size_hints_set_min_size(&size_hints,
                                              as<i32>(m_extent.width),
                                              as<i32>(m_extent.height));
            xcb_icccm_size_hints_set_max_size(&size_hints,
                                              as<i32>(m_extent.width),
                                              as<i32>(m_extent.height));

            xcb_icccm_set_wm_normal_hints(m_connection, m_window, &size_hints);
        }

        xcb_flush(m_connection);

        m_handles.connection  = m_connection;
        m_handles.window      = m_window;
        m_handles.key_symbols = m_key_symbols.get();

        auto close_atom    = get_xcb_atom(WM_DELETE_WINDOW, false);
        auto protocol_atom = get_xcb_atom(WM_PROTOCOLS, true);
        if (!protocol_atom) [[unlikely]]
            elog("Failed to get atom {}\n    > reason: {}",
                 WM_PROTOCOLS,
                 protocol_atom.error().message);
        else if (!close_atom) [[unlikely]]
            elog("Failed to get atom {}\n    > reason: {}",
                 WM_DELETE_WINDOW,
                 close_atom.error().message);
        else
            xcb_change_property(m_connection,
                                XCB_PROP_MODE_REPLACE,
                                m_window,
                                *protocol_atom,
                                XCB_ATOM_ATOM,
                                32,
                                1,
                                &(*close_atom));

        auto state_atom = get_xcb_atom(WM_STATE_STR, false);
        if (!state_atom) [[unlikely]]
            elog("Failed to get atom {}\n    > reason: {}",
                 WM_STATE_STR,
                 state_atom.error().message);
        else
            xcb_change_property(m_connection,
                                XCB_PROP_MODE_REPLACE,
                                m_window,
                                *state_atom,
                                XCB_ATOM_ATOM,
                                32,
                                0,
                                nullptr);

        xcb_map_window(m_connection, m_window);

        xcb_flush(m_connection);

        m_title   = std::move(title);
        m_visible = true;
        m_open    = true;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    auto WindowImpl::close() noexcept -> void {
        m_window.reset();

        m_title.clear();
        m_open    = false;
        m_visible = false;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    auto WindowImpl::poll_event(Event& event) noexcept -> bool {
        STORMKIT_RAII_CAPSULE(Event, xcb_generic_event_t, std::free)

        for (auto xevent = EventScoped { xcb_poll_for_event(m_connection) }; xevent;
             xevent.reset(xcb_poll_for_event(m_connection)))
            process_events(xevent.get());

        return WindowImplBase::poll_event(event);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    auto WindowImpl::wait_event(Event& event) noexcept -> bool {
        auto xevent = xcb_poll_for_event(m_connection);

        while (!xevent) xevent = xcb_poll_for_event(m_connection);

        process_events(xevent);

        return WindowImplBase::wait_event(event);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    auto WindowImpl::set_title(std::string title) noexcept -> void {
        xcb_change_property(m_connection,
                            XCB_PROP_MODE_REPLACE,
                            m_window,
                            XCB_ATOM_WM_NAME,
                            XCB_ATOM_STRING,
                            8,
                            as<u32>(title.length()),
                            title.c_str());

        xcb_flush(m_connection);

        m_title = std::move(title);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    auto WindowImpl::toggle_fullscreen(bool enabled) noexcept -> void {
        auto fullscreen_atom = get_xcb_atom(WM_STATE_FULLSCREEN_STR, false);
        if (!fullscreen_atom) [[unlikely]] {
            elog("Failed to setup fullscreen\n     > Failed to get atom {}\n        > reason: {}",
                 WM_STATE_STR,
                 fullscreen_atom.error().message);
            return;
        }

        auto state_atom = get_xcb_atom(WM_STATE_FULLSCREEN_STR, false);
        if (!state_atom) [[unlikely]] {
            elog("Failed to setup fullscreen\n    > Failed to get atom {}\n        > reason: {}",
                 WM_STATE_STR,
                 state_atom.error().message);
            return;
        }

        auto ev           = xcb_client_message_event_t {};
        ev.response_type  = XCB_CLIENT_MESSAGE;
        ev.type           = *state_atom;
        ev.format         = 32;
        ev.window         = m_window;
        ev.data.data32[0] = enabled ? _NET_WM_STATE_ADD : _NET_WM_STATE_REMOVE;
        ev.data.data32[1] = *fullscreen_atom;
        ev.data.data32[2] = XCB_ATOM_NONE;
        ev.data.data32[3] = 0;
        ev.data.data32[4] = 0;

        xcb_send_event(m_connection,
                       1,
                       m_window,
                       XCB_EVENT_MASK_SUBSTRUCTURE_REDIRECT | XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY,
                       std::bit_cast<const char*>(&ev));

        m_fullscreen = enabled;

        xcb_flush(m_connection);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    auto WindowImpl::lock_mouse() noexcept -> void {
        xcb_warp_pointer(m_connection,
                         XCB_NONE,
                         m_window,
                         0,
                         0,
                         0,
                         0,
                         as<i16>(m_extent.width / 2),
                         as<i16>(m_extent.height / 2));

        xcb_flush(m_connection);

        auto cookie = xcb_grab_pointer(m_connection,
                                       1,
                                       m_window,
                                       XCB_EVENT_MASK_BUTTON_PRESS
                                         | XCB_EVENT_MASK_BUTTON_RELEASE
                                         | XCB_EVENT_MASK_BUTTON_MOTION
                                         | XCB_EVENT_MASK_POINTER_MOTION,
                                       XCB_GRAB_MODE_ASYNC,
                                       XCB_GRAB_MODE_ASYNC,
                                       m_window,
                                       XCB_NONE,
                                       XCB_CURRENT_TIME);
        xcb_grab_pointer_reply(m_connection, cookie, nullptr);
        xcb_flush(m_connection);

        m_is_mouse_locked = true;

        hide_mouse();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    auto WindowImpl::unlock_mouse() noexcept -> void {
        xcb_ungrab_pointer(m_connection, XCB_CURRENT_TIME);
        xcb_flush(m_connection);

        m_is_mouse_locked = false;

        unhide_mouse();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    auto WindowImpl::hide_mouse() noexcept -> void {
        xcb_xfixes_hide_cursor(m_connection, m_window);
        xcb_flush(m_connection);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    auto WindowImpl::unhide_mouse() noexcept -> void {
        xcb_xfixes_show_cursor(m_connection, m_window);
        xcb_flush(m_connection);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    auto WindowImpl::native_handle() const noexcept -> NativeHandle {
        return std::bit_cast<NativeHandle>(&m_handles);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    auto WindowImpl::toggle_key_repeat(bool enabled) noexcept -> void {
        auto mask = ((enabled) ? KEYBOARD_EVENTS : KEYBOARD_RAW_EVENTS) | MOUSE_RAW_EVENTS;

        xcb_input_xi_passive_grab_device(m_connection,
                                         XCB_CURRENT_TIME,
                                         m_window,
                                         XCB_CURSOR_NONE,
                                         0,
                                         XCB_INPUT_DEVICE_ALL,
                                         1,
                                         1,
                                         XCB_INPUT_GRAB_TYPE_KEYCODE,
                                         XCB_INPUT_GRAB_MODE_22_ASYNC,
                                         XCB_INPUT_GRAB_MODE_22_ASYNC,
                                         XCB_INPUT_GRAB_OWNER_NO_OWNER,
                                         &mask,
                                         &XINPUT_MASK_MODIFIERS);

        xcb_flush(m_connection);

        m_key_repeat_enabled = enabled;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    auto WindowImpl::toggle_virtual_keyboard_visibility([[maybe_unused]] bool visible) noexcept
      -> void {
        elog("x11::WindowImpl::toggle_virtual_keyboard_visibility isn't yet implemented");
    }

    /////////////////////////////////////
    /////////////////////////////////////
    auto WindowImpl::set_mouse_position(const math::Vector2I& position) noexcept -> void {
        auto connection = get_xcb_connection();

        xcb_warp_pointer(connection,
                         XCB_NONE,
                         m_window,
                         0,
                         0,
                         0,
                         0,
                         as<i16>(position.x),
                         as<i16>(position.y));

        xcb_flush(connection);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    auto WindowImpl::set_mouse_position_on_desktop(const math::Vector2U& position) noexcept
      -> void {
        auto connection = get_xcb_connection();

        const auto default_screen_id = 0;
        auto       root_window       = default_root_window(connection, default_screen_id);

        xcb_warp_pointer(connection,
                         XCB_NONE,
                         root_window,
                         0,
                         0,
                         0,
                         0,
                         as<i16>(position.x),
                         as<i16>(position.y));

        xcb_flush(connection);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    auto WindowImpl::get_monitor_settings() -> std::vector<Monitor> {
        STORMKIT_RAII_CAPSULE(Monitors, xcb_randr_get_monitors_reply_t, std::free)
        STORMKIT_RAII_CAPSULE(Output, xcb_randr_get_output_info_reply_t, std::free)
        STORMKIT_RAII_CAPSULE(CRTC, xcb_randr_get_crtc_info_reply_t, std::free)

        auto connection = get_xcb_connection();
        auto root       = xcb_setup_roots_iterator(xcb_get_setup(connection)).data;

        auto xcb_monitors = MonitorsScoped {
            xcb_randr_get_monitors_reply(connection,
                                         xcb_randr_get_monitors(connection, root->root, 0),
                                         nullptr)
        };
        auto monitors = std::vector<Monitor> {};

        auto xcb_monitor_iter = xcb_randr_get_monitors_monitors_iterator(xcb_monitors.get());
        for (auto i = 0; xcb_monitor_iter.rem;
             xcb_randr_monitor_info_next(&xcb_monitor_iter), ++i) {
            auto monitor_info = xcb_monitor_iter.data;

            xcb_randr_select_input(connection, root->root, true);

            auto& monitor = monitors.emplace_back();
            if (monitor_info->primary) monitor.flags = Monitor::Flags::PRIMARY;

            auto name = get_xcb_atom_name(monitor_info->name);
            if (!name) monitor.name = std::format("Monitor {}", i);
            else
                monitor.name = std::move(*name);

            auto len     = xcb_randr_monitor_info_outputs_length(monitor_info);
            auto outputs = xcb_randr_monitor_info_outputs(monitor_info);

            for (auto j : range(len)) {
                auto output_cookie = xcb_randr_get_output_info(connection,
                                                               outputs[j],
                                                               xcb_monitors->timestamp);
                auto output        = OutputScoped {
                    xcb_randr_get_output_info_reply(connection, output_cookie, nullptr)
                };

                if (!output) continue;
                if (output->connection != XCB_RANDR_CONNECTION_CONNECTED) continue;
                if (output->crtc != XCB_NONE) continue;

                auto crtc_cookie = xcb_randr_get_crtc_info(connection,
                                                           output->crtc,
                                                           output->timestamp);
                auto crtc        = CRTCScoped {
                    xcb_randr_get_crtc_info_reply(connection, crtc_cookie, nullptr)
                };

                if (crtc == nullptr) {}

                monitor.extents
                  .emplace_back(math::Extent2<u32> { as<u32>(crtc->width), as<u32>(crtc->height) });
            }

            if (stdr::empty(monitor.extents))
                monitor.extents
                  .emplace_back(math::Extent2<u32> { as<u32>(xcb_monitor_iter.data->width),
                                                     as<u32>(xcb_monitor_iter.data->height) });
        }
        return monitors;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    auto WindowImpl::process_events(xcb_generic_event_t* event) -> void {
        auto*      xevent        = event;
        const auto response_type = xevent->response_type & ~0x80;

        switch (response_type) {
            case XCB_KEY_PRESS: {
                auto kevent = std::bit_cast<xcb_key_press_event_t*>(xevent);
                handle_key_event(kevent->detail, true);
                break;
            }
            case XCB_KEY_RELEASE: {
                auto kevent = std::bit_cast<xcb_key_release_event_t*>(xevent);
                handle_key_event(kevent->detail, false);
                break;
            }
            case XCB_MOTION_NOTIFY: {
                auto mouse_event = std::bit_cast<xcb_motion_notify_event_t*>(xevent);

                const auto x = as<u32>(mouse_event->event_x);
                const auto y = as<u32>(mouse_event->event_y);

                if (m_is_mouse_locked) {
                    if (x != m_extent.width / 2 || y != m_extent.height / 2) {
                        auto dx = x - as<u32>(m_mouse_position.x);
                        auto dy = y - as<u32>(m_mouse_position.y);

                        m_locked_mouse_position.x += dx;
                        m_locked_mouse_position.x += dy;

                        WindowImplBase::mouse_move_event(m_locked_mouse_position.x,
                                                         m_locked_mouse_position.y);
                    }
                    m_mouse_position.x = as<i32>(x);
                    m_mouse_position.y = as<i32>(y);
                } else {
                    m_mouse_position.x = as<i32>(x);
                    m_mouse_position.y = as<i32>(y);
                    WindowImplBase::mouse_move_event(m_mouse_position.x, m_mouse_position.y);
                }

                break;
            }
            case XCB_BUTTON_PRESS: {
                auto button_event = std::bit_cast<xcb_button_press_event_t*>(xevent);

                auto button = button_event->detail;
                WindowImplBase::mouse_down_event(x11_button_to_stormkit(button),
                                                 button_event->event_x,
                                                 button_event->event_y);
                break;
            }
            case XCB_BUTTON_RELEASE: {
                auto button_event = std::bit_cast<xcb_button_press_event_t*>(xevent);

                auto button = button_event->detail;
                WindowImplBase::mouse_up_event(x11_button_to_stormkit(button),
                                               button_event->event_x,
                                               button_event->event_y);
                break;
            }
            case XCB_CONFIGURE_NOTIFY: {
                auto configure_event = std::bit_cast<xcb_configure_notify_event_t*>(xevent);

                if ((configure_event->width != m_extent.width)
                    || (configure_event->height != m_extent.height)) {
                    m_extent.width  = configure_event->width;
                    m_extent.height = configure_event->height;
                    WindowImplBase::resize_event(configure_event->width, configure_event->height);
                }
                break;
            }
            case XCB_ENTER_NOTIFY: WindowImplBase::mouse_entered_event(); break;
            case XCB_LEAVE_NOTIFY: WindowImplBase::mouse_exited_event(); break;
            case XCB_VISIBILITY_NOTIFY: // TODO XCB_VISIBILITY_NOTIFY
                /*if(xevent.xvisibility.wsi.== m_window
                        m_is_visible = xevent.xvisibility.state !=
                   VisibilityFullyObscured;*/
                break;
            case XCB_DESTROY_NOTIFY: // TODO XCB_DESTROY_NOTIFY
                break;
            case XCB_CLIENT_MESSAGE: {
                auto close_atom = get_xcb_atom(WM_DELETE_WINDOW, false);
                if (!close_atom) [[unlikely]]
                    elog("Failed to get atom {}\n    > reason: {}",
                         WM_DELETE_WINDOW,
                         close_atom.error().message);

                if (std::bit_cast<xcb_client_message_event_t*>(xevent)->data.data32[0]
                    == *close_atom)
                    WindowImplBase::close_event();
                break;
            }
            case XCB_MAPPING_NOTIFY: {
                auto mapping_notify_event = std::bit_cast<xcb_mapping_notify_event_t*>(xevent);

                if (mapping_notify_event->request != XCB_MAPPING_POINTER) {
                    xcb_refresh_keyboard_mapping(m_key_symbols.get(), mapping_notify_event);
                    update_keymap();
                }
                break;
            }
            case XCB_GE_GENERIC: {
                if (is_ext_event(xevent, m_xi_opcode)) {
                    auto xievent = std::bit_cast<xcb_ge_generic_event_t*>(xevent);
                    switch (xievent->event_type) {
                        case XCB_INPUT_KEY_PRESS: [[fallthrough]];
                        case XCB_INPUT_RAW_KEY_PRESS: {
                            auto _xievent = std::bit_cast<xcb_input_key_press_event_t*>(xevent);
                            handle_key_event(as<xcb_keycode_t>(_xievent->detail), true);
                            break;
                        }
                        case XCB_INPUT_KEY_RELEASE: [[fallthrough]];
                        case XCB_INPUT_RAW_KEY_RELEASE: {
                            auto _xievent = std::bit_cast<xcb_input_key_press_event_t*>(xevent);
                            handle_key_event(as<xcb_keycode_t>(_xievent->detail), false);
                            break;
                        }
                        case XCB_INPUT_BUTTON_PRESS: [[fallthrough]];
                        case XCB_INPUT_RAW_BUTTON_PRESS: {
                            auto button_event = std::bit_cast<
                              xcb_input_button_press_event_t*>(xevent);

                            auto button = button_event->detail;
                            WindowImplBase::
                              mouse_down_event(x11_button_to_stormkit(as<xcb_button_t>(button)),
                                               button_event->event_x,
                                               button_event->event_y);
                            break;
                        }
                        case XCB_INPUT_BUTTON_RELEASE: [[fallthrough]];
                        case XCB_INPUT_RAW_BUTTON_RELEASE: {
                            auto button_event = std::bit_cast<
                              xcb_input_button_release_event_t*>(xevent);

                            auto button = button_event->detail;
                            WindowImplBase::
                              mouse_down_event(x11_button_to_stormkit(as<xcb_button_t>(button)),
                                               button_event->event_x,
                                               button_event->event_y);
                            break;
                        }
                    }
                    break;
                }
            }
        }
    }

    /////////////////////////////////////
    /////////////////////////////////////
    auto WindowImpl::update_keymap() -> void {
        const auto device_id = xkb_x11_get_core_keyboard_device_id(m_connection);

        m_xkb_keymap.reset(xkb_x11_keymap_new_from_device(m_xkb_context,
                                                          m_connection,
                                                          device_id,
                                                          XKB_KEYMAP_COMPILE_NO_FLAGS));

        if (!m_xkb_keymap) {
            elog("Failed to compile a keymap");
            return;
        }

        m_xkb_state
          .reset(xkb_x11_state_new_from_device(m_xkb_keymap.get(), m_connection, device_id));

        if (!m_xkb_state) {
            elog("Failed to create XKB state");
            return;
        }

        m_handles.state = m_xkb_state.get();

        m_xkb_mods = common::XKBMods {
            .shift   = xkb_keymap_mod_get_index(m_xkb_keymap.get(), XKB_MOD_NAME_SHIFT),
            .lock    = xkb_keymap_mod_get_index(m_xkb_keymap.get(), XKB_MOD_NAME_CAPS),
            .control = xkb_keymap_mod_get_index(m_xkb_keymap.get(), XKB_MOD_NAME_CTRL),
            .mod1    = xkb_keymap_mod_get_index(m_xkb_keymap.get(), "Mod1"),
            .mod2    = xkb_keymap_mod_get_index(m_xkb_keymap.get(), "Mod2"),
            .mod3    = xkb_keymap_mod_get_index(m_xkb_keymap.get(), "Mod3"),
            .mod4    = xkb_keymap_mod_get_index(m_xkb_keymap.get(), "Mod4"),
            .mod5    = xkb_keymap_mod_get_index(m_xkb_keymap.get(), "Mod5")
        };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    auto WindowImpl::handle_key_event(xcb_keycode_t keycode, bool down) noexcept -> void {
        auto symbol = xkb_keysym_t {};

        auto character = char {};
        symbol         = xkb_state_key_get_one_sym(m_xkb_state.get(), keycode);
        xkb_state_key_get_utf8(m_xkb_state.get(),
                               keycode,
                               std::bit_cast<char*>(&character),
                               sizeof(char));

        auto key = common::xkb_key_to_stormkit(symbol);

        if (down) WindowImplBase::key_down_event(key, character);
        else
            WindowImplBase::key_up_event(key, character);
    }
} // namespace stormkit::wsi::linux::x11
