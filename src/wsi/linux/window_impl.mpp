// Copyright (C) 2021 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

module;

#include <stormkit/core/platform_macro.hpp>

export module stormkit.wsi:linux.window_impl;

import std;

import stormkit.core;
import stormkit.wsi;

import :common.window_impl_base;
import :linux.x11.window_impl;
import :linux.wayland.window_impl;

export namespace stormkit::wsi::linux {
    class WindowImpl: public ::stormkit::wsi::common::WindowImplBase {
      public:
        explicit WindowImpl(WM wm);
        WindowImpl(WM wm, std::string title, const math::Extent2<u32>& size, WindowFlag flags);
        ~WindowImpl();

        WindowImpl(const WindowImpl&) noexcept                    = delete;
        auto operator=(const WindowImpl&) noexcept -> WindowImpl& = delete;

        WindowImpl(WindowImpl&&) noexcept;
        auto operator=(WindowImpl&&) noexcept -> WindowImpl&;

        auto create(std::string title, const math::Extent2<u32>& size, WindowFlag flags) noexcept
          -> void;
        auto close() noexcept -> void;

        auto clear(const RGBColorU& color = RGBColorDef::BLACK<u8>) noexcept -> void;
        auto set_pixels_to(std::span<const RGBColorU> colors) noexcept -> void;

        [[nodiscard]]
        auto is_open() const noexcept -> bool;

        [[nodiscard]]
        auto poll_event(Event& event) noexcept -> bool;
        [[nodiscard]]
        auto wait_event(Event& event) noexcept -> bool;

        [[nodiscard]]
        auto visible() const noexcept -> bool;

        auto set_title(std::string title) noexcept -> void;
        [[nodiscard]]
        auto title() const noexcept -> const std::string&;

        auto set_extent(const math::Extent2<u32>& extent) noexcept -> void;
        [[nodiscard]]
        auto extent() const noexcept -> math::Extent2<u32>;
        [[nodiscard]]
        auto framebuffer_extent() const noexcept -> math::Extent2<u32>;

        auto set_fullscreen(bool fullscreen) noexcept -> void;
        [[nodiscard]]
        auto fullscreen() const noexcept -> bool;

        auto confine_mouse(bool confined = true, u32 mouse_id = 0) noexcept -> void;
        [[nodiscard]]
        auto is_mouse_confined(u32 mouse_id) const noexcept -> bool;

        auto lock_mouse(bool locked = true, u32 mouse_id = 0) noexcept -> void;
        [[nodiscard]]
        auto is_mouse_locked(u32 mouse_id) const noexcept -> bool;

        auto hide_mouse(bool hidden = true, u32 mouse_id = 0) noexcept -> void;
        [[nodiscard]]
        auto is_mouse_hidden(u32 mouse_id) const noexcept -> bool;

        auto set_relative_mouse(bool enabled, u32 mouse_id = 0) noexcept -> void;
        [[nodiscard]]
        auto is_mouse_relative(u32 mouse_id = 0) const noexcept -> bool;

        auto set_key_repeat(bool enabled, u32 keyboard_id = 0) noexcept -> void;
        [[nodiscard]]
        auto is_key_repeat_enabled(u32 keyboard_id = 0) const noexcept -> bool;

        auto show_virtual_keyboard(bool visible = true) noexcept -> void;
        [[nodiscard]]
        auto is_virtual_keyboard_visible() const noexcept -> bool;

        auto set_mouse_position(const math::vec2i& position, u32 mouse_id = 0) noexcept -> void;
        static auto set_mouse_position_on_desktop(WM                 wm,
                                                  const math::vec2u& position,
                                                  u32                mouse_id = 0) noexcept -> void;

        [[nodiscard]]
        static auto get_monitor_settings(WM wm) -> std::vector<Monitor>;

        [[nodiscard]]
        auto native_handle() const noexcept -> NativeHandle;

      private:
        struct Sentinelle {};

        using BackendWindowImpl = std::
          variant<x11::WindowImpl, wayland::WindowImpl, std::monostate>;

        WM m_wm;

        BackendWindowImpl m_impl = std::monostate {};
    };
} // namespace stormkit::wsi::linux

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit::wsi::linux {
    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline WindowImpl::WindowImpl(WM wm)
        : m_wm { wm } {
        if (m_wm == WM::X11) m_impl = x11::WindowImpl {};
        else if (m_wm == WM::WAYLAND)
            m_impl = wayland::WindowImpl {};
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline WindowImpl::~WindowImpl() = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline WindowImpl::WindowImpl(WM                        wm,
                                  std::string               title,
                                  const math::Extent2<u32>& extent,
                                  WindowFlag                flags)
        : m_wm { wm } {
        if (m_wm == WM::X11) m_impl = x11::WindowImpl { std::move(title), extent, flags };
        else if (m_wm == WM::WAYLAND)
            m_impl = wayland::WindowImpl { title, extent, flags };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline WindowImpl::WindowImpl(WindowImpl&&) noexcept = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto WindowImpl::operator=(WindowImpl&&) noexcept -> WindowImpl& = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto WindowImpl::create(std::string               title,
                                   const math::Extent2<u32>& extent,
                                   WindowFlag                flags) noexcept -> void {
        switch (m_wm) {
            case WM::X11:
                as<x11::WindowImpl>(m_impl).create(std::move(title), extent, flags);
                break;
            case WM::WAYLAND:
                as<wayland::WindowImpl>(m_impl).create(std::move(title), extent, flags);
                break;

            default: std::unreachable();
        }
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto WindowImpl::close() noexcept -> void {
        switch (m_wm) {
            case WM::X11: as<x11::WindowImpl>(m_impl).close(); break;
            case WM::WAYLAND: as<wayland::WindowImpl>(m_impl).close(); break;

            default: std::unreachable();
        }
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto WindowImpl::clear(const RGBColorU& color) noexcept -> void {
        switch (m_wm) {
            case WM::X11: as<x11::WindowImpl>(m_impl).clear(color); break;
            case WM::WAYLAND: as<wayland::WindowImpl>(m_impl).clear(color); break;

            default: std::unreachable();
        }
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto WindowImpl::set_pixels_to(std::span<const RGBColorU> colors) noexcept -> void {
        switch (m_wm) {
            case WM::X11: as<x11::WindowImpl>(m_impl).set_pixels_to(colors); break;
            case WM::WAYLAND: as<wayland::WindowImpl>(m_impl).set_pixels_to(colors); break;

            default: std::unreachable();
        }
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_CONST STORMKIT_FORCE_INLINE
    inline auto WindowImpl::is_open() const noexcept -> bool {
        switch (m_wm) {
            case WM::X11: return as<x11::WindowImpl>(m_impl).is_open();
            case WM::WAYLAND: return as<wayland::WindowImpl>(m_impl).is_open();

            default: break;
        }

        std::unreachable();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_CONST STORMKIT_FORCE_INLINE
    inline auto WindowImpl::poll_event(Event& event) noexcept -> bool {
        switch (m_wm) {
            case WM::X11: return as<x11::WindowImpl>(m_impl).poll_event(event);
            case WM::WAYLAND: return as<wayland::WindowImpl>(m_impl).poll_event(event);

            default: break;
        }

        std::unreachable();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_CONST STORMKIT_FORCE_INLINE
    inline auto WindowImpl::wait_event(Event& event) noexcept -> bool {
        switch (m_wm) {
            case WM::X11: return as<x11::WindowImpl>(m_impl).wait_event(event);
            case WM::WAYLAND: return as<wayland::WindowImpl>(m_impl).wait_event(event);

            default: break;
        }

        std::unreachable();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_CONST STORMKIT_FORCE_INLINE
    inline auto WindowImpl::visible() const noexcept -> bool {
        switch (m_wm) {
            case WM::X11: return as<x11::WindowImpl>(m_impl).visible();
            case WM::WAYLAND: return as<wayland::WindowImpl>(m_impl).visible();

            default: break;
        }

        std::unreachable();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto WindowImpl::set_title(std::string title) noexcept -> void {
        switch (m_wm) {
            case WM::X11: as<x11::WindowImpl>(m_impl).set_title(std::move(title)); break;
            case WM::WAYLAND: as<wayland::WindowImpl>(m_impl).set_title(std::move(title)); break;

            default: std::unreachable();
        }
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_CONST STORMKIT_FORCE_INLINE
    inline auto WindowImpl::title() const noexcept -> const std::string& {
        switch (m_wm) {
            case WM::X11: return as<x11::WindowImpl>(m_impl).title();
            case WM::WAYLAND: return as<wayland::WindowImpl>(m_impl).title();

            default: break;
        }

        std::unreachable();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto WindowImpl::set_extent(const math::Extent2<u32>& extent) noexcept -> void {
        switch (m_wm) {
            case WM::X11: as<x11::WindowImpl>(m_impl).set_extent(extent); break;
            case WM::WAYLAND: as<wayland::WindowImpl>(m_impl).set_extent(extent); break;

            default: std::unreachable();
        }
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_CONST STORMKIT_FORCE_INLINE
    inline auto WindowImpl::extent() const noexcept -> stormkit::math::Extent2<u32> {
        switch (m_wm) {
            case WM::X11: return as<x11::WindowImpl>(m_impl).extent();
            case WM::WAYLAND: return as<wayland::WindowImpl>(m_impl).extent();

            default: break;
        }

        std::unreachable();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_CONST STORMKIT_FORCE_INLINE
    inline auto WindowImpl::framebuffer_extent() const noexcept -> stormkit::math::Extent2<u32> {
        switch (m_wm) {
            case WM::X11: return as<x11::WindowImpl>(m_impl).framebuffer_extent();
            case WM::WAYLAND: return as<wayland::WindowImpl>(m_impl).framebuffer_extent();

            default: break;
        }

        std::unreachable();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto WindowImpl::set_fullscreen(bool enabled) noexcept -> void {
        switch (m_wm) {
            case WM::X11: as<x11::WindowImpl>(m_impl).set_fullscreen(enabled); break;
            case WM::WAYLAND: as<wayland::WindowImpl>(m_impl).set_fullscreen(enabled); break;

            default: std::unreachable();
        }
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_CONST STORMKIT_FORCE_INLINE
    inline auto WindowImpl::fullscreen() const noexcept -> bool {
        switch (m_wm) {
            case WM::X11: return as<x11::WindowImpl>(m_impl).fullscreen();
            case WM::WAYLAND: return as<wayland::WindowImpl>(m_impl).fullscreen();

            default: break;
        }

        std::unreachable();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto WindowImpl::confine_mouse(bool confined, u32 mouse_id) noexcept -> void {
        switch (m_wm) {
            case WM::X11: as<x11::WindowImpl>(m_impl).confine_mouse(confined, mouse_id); break;
            case WM::WAYLAND:
                as<wayland::WindowImpl>(m_impl).confine_mouse(confined, mouse_id);
                break;

            default: std::unreachable();
        }
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_CONST STORMKIT_FORCE_INLINE
    inline auto WindowImpl::is_mouse_confined(u32 mouse_id) const noexcept -> bool {
        switch (m_wm) {
            case WM::X11: return as<x11::WindowImpl>(m_impl).is_mouse_confined(mouse_id);
            case WM::WAYLAND: return as<wayland::WindowImpl>(m_impl).is_mouse_confined(mouse_id);

            default: break;
        }

        std::unreachable();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto WindowImpl::lock_mouse(bool locked, u32 mouse_id) noexcept -> void {
        switch (m_wm) {
            case WM::X11: as<x11::WindowImpl>(m_impl).lock_mouse(locked, mouse_id); break;
            case WM::WAYLAND: as<wayland::WindowImpl>(m_impl).lock_mouse(locked, mouse_id); break;

            default: std::unreachable();
        }
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_CONST STORMKIT_FORCE_INLINE
    inline auto WindowImpl::is_mouse_locked(u32 mouse_id) const noexcept -> bool {
        switch (m_wm) {
            case WM::X11: return as<x11::WindowImpl>(m_impl).is_mouse_locked(mouse_id);
            case WM::WAYLAND: return as<wayland::WindowImpl>(m_impl).is_mouse_locked(mouse_id);

            default: break;
        }

        std::unreachable();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto WindowImpl::hide_mouse(bool hidden, u32 mouse_id) noexcept -> void {
        switch (m_wm) {
            case WM::X11: as<x11::WindowImpl>(m_impl).hide_mouse(hidden, mouse_id); break;
            case WM::WAYLAND: as<wayland::WindowImpl>(m_impl).hide_mouse(hidden, mouse_id); break;

            default: std::unreachable();
        }
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_CONST STORMKIT_FORCE_INLINE
    inline auto WindowImpl::is_mouse_hidden(u32 mouse_id) const noexcept -> bool {
        switch (m_wm) {
            case WM::X11: return as<x11::WindowImpl>(m_impl).is_mouse_hidden(mouse_id);
            case WM::WAYLAND: return as<wayland::WindowImpl>(m_impl).is_mouse_hidden(mouse_id);

            default: break;
        }

        std::unreachable();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto WindowImpl::set_relative_mouse(bool enabled, u32 mouse_id) noexcept -> void {
        switch (m_wm) {
            case WM::X11: as<x11::WindowImpl>(m_impl).set_relative_mouse(enabled, mouse_id); break;
            case WM::WAYLAND:
                as<wayland::WindowImpl>(m_impl).set_relative_mouse(enabled, mouse_id);
                break;

            default: std::unreachable();
        }
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_CONST STORMKIT_FORCE_INLINE
    inline auto WindowImpl::is_mouse_relative(u32 mouse_id) const noexcept -> bool {
        switch (m_wm) {
            case WM::X11: return as<x11::WindowImpl>(m_impl).is_mouse_relative(mouse_id);
            case WM::WAYLAND: return as<wayland::WindowImpl>(m_impl).is_mouse_relative(mouse_id);

            default: break;
        }

        std::unreachable();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto WindowImpl::set_key_repeat(bool enabled, u32 keyboard_id) noexcept -> void {
        switch (m_wm) {
            case WM::X11: return as<x11::WindowImpl>(m_impl).set_key_repeat(enabled, keyboard_id);
            case WM::WAYLAND:
                return as<wayland::WindowImpl>(m_impl).set_key_repeat(enabled, keyboard_id);

            default: break;
        }

        std::unreachable();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_CONST STORMKIT_FORCE_INLINE
    inline auto WindowImpl::is_key_repeat_enabled(u32 keyboard_id) const noexcept -> bool {
        switch (m_wm) {
            case WM::X11: return as<x11::WindowImpl>(m_impl).is_key_repeat_enabled(keyboard_id);
            case WM::WAYLAND:
                return as<wayland::WindowImpl>(m_impl).is_key_repeat_enabled(keyboard_id);

            default: break;
        }

        std::unreachable();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto WindowImpl::show_virtual_keyboard(bool visible) noexcept -> void {
        switch (m_wm) {
            case WM::X11: as<x11::WindowImpl>(m_impl).show_virtual_keyboard(visible); break;
            case WM::WAYLAND: as<wayland::WindowImpl>(m_impl).show_virtual_keyboard(visible); break;

            default: std::unreachable();
        }
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_CONST STORMKIT_FORCE_INLINE
    inline auto WindowImpl::is_virtual_keyboard_visible() const noexcept -> bool {
        switch (m_wm) {
            case WM::X11: return as<x11::WindowImpl>(m_impl).is_virtual_keyboard_visible();
            case WM::WAYLAND: return as<wayland::WindowImpl>(m_impl).is_virtual_keyboard_visible();

            default: break;
        }

        std::unreachable();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto WindowImpl::set_mouse_position(const math::vec2i& position, u32 mouse_id) noexcept
      -> void {
        switch (m_wm) {
            case WM::X11: as<x11::WindowImpl>(m_impl).set_mouse_position(position, mouse_id); break;
            case WM::WAYLAND:
                as<wayland::WindowImpl>(m_impl).set_mouse_position(position, mouse_id);
                break;

            default: std::unreachable();
        }
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto WindowImpl::set_mouse_position_on_desktop(WM                 wm,
                                                          const math::vec2u& position,
                                                          u32 mouse_id) noexcept -> void {
        switch (wm) {
            case WM::X11: x11::WindowImpl::set_mouse_position_on_desktop(position, mouse_id); break;
            case WM::WAYLAND:
                wayland::WindowImpl::set_mouse_position_on_desktop(position, mouse_id);
                break;

            default: std::unreachable();
        }
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_CONST STORMKIT_FORCE_INLINE
    inline auto WindowImpl::get_monitor_settings(WM wm) -> std::vector<Monitor> {
        switch (wm) {
            case WM::X11: return x11::WindowImpl::get_monitor_settings(); break;
            case WM::WAYLAND: return wayland::WindowImpl::get_monitor_settings(); break;
            default: break;
        }

        std::unreachable();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_CONST STORMKIT_FORCE_INLINE
    inline auto WindowImpl::native_handle() const noexcept -> NativeHandle {
        switch (m_wm) {
            case WM::X11: return as<x11::WindowImpl>(m_impl).native_handle();
            case WM::WAYLAND: return as<wayland::WindowImpl>(m_impl).native_handle();
            default: break;
        }

        std::unreachable();
    }
} // namespace stormkit::wsi::linux
